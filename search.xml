<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-string-easy-551-387]]></title>
    <url>%2F2018%2F08%2F16%2Fleetcode-string-easy-551-387%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是551，387 题目：551. Student Attendance Record I描述：You are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present.A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record例子：1234Input: &quot;PPALLP&quot;Output: TrueInput: &quot;PPALLL&quot;Output: False 代码：12345678910111213141516bool Solution551::checkRecord(string s)&#123; //int a_num = 0; //int l_num = 0; //for (int i = 0; i &lt; s.size(); ++i) //&#123; // if (s[i] == 'A')a_num++; // else if (s[i] == 'L' &amp;&amp; i &gt; 1) // &#123; // if (s[i - 1] == 'L' &amp;&amp; s[i - 2] == 'L')return false; // &#125; // if (a_num &gt; 1)return false; //&#125; //return true; return s.find("LLL") == SIZE_MAX &amp;&amp; s.find_first_of('A') == s.find_last_of('A');//如何理解SIZE_MAX&#125; 别人提供的方法二真的是一目了然，赏心悦目，但是对于s.find(&quot;LLL&quot;) == SIZE_MAX要好好理解 题目：387. First Unique Character in a String描述：Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.例子：12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. 代码：123456789101112131415161718192021222324252627282930313233int Solution387::firstUniqChar(string s)&#123; vector&lt;pair&lt;int,int&gt;&gt; _s1(26);//第一个位置存储第一次出现的位置，第二个位置存储出现的次数 for (int i = 0; i &lt; s.size(); ++i) &#123; if (_s1[s[i] - 'a'].second == 0) &#123; _s1[s[i] - 'a'].second++; _s1[s[i] - 'a'].first = i; &#125; else _s1[s[i] - 'a'].second++; &#125; int res = -1; for (int i = 0; i &lt; 26; ++i) &#123; if (_s1[i].second == 1 &amp;&amp; res == -1) &#123; res = _s1[i].first; &#125; else if (_s1[i].second == 1 &amp;&amp; res &gt; _s1[i].first) res = _s1[i].first; &#125; return res; //int len = s.size(), count[26] = &#123; 0 &#125;, i, j; //for (i = 0; i&lt;len; i++) // count[s[i] - 'a']++; //for (i = 0; i&lt;len; i++) // if (count[s[i] - 'a'] == 1) // return i; //return -1;&#125; vector&lt;pair&lt;int,int&gt;&gt; _s1(26)用我自己的方法我骄傲~^~]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-819-383-21]]></title>
    <url>%2F2018%2F08%2F15%2Fleetcode-string-easy-819-383-21%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是819,383，21打卡链表 题目：819. Most Common Word描述：Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn’t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.例子：123paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot; 代码：123456789101112131415161718192021222324252627282930313233343536373839string Solution819::mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned)&#123; unordered_map&lt;string, int&gt;map; unordered_set&lt;string&gt;sets(banned.begin(), banned.end()); int j = 0; string s; int max = 0; string res; for (int i = 1; i &lt; paragraph.size(); ++i) &#123; if (paragraph[i] == ' ' || paragraph[i] == ',' || paragraph[i] == '.' || paragraph[i] == '?' || paragraph[i] == '!' || paragraph[i] == ';' || paragraph[i] == '\'') &#123; s = paragraph.substr(j, i - j); transform(s.begin(), s.end(), s.begin(), ::tolower); if (sets.find(s) == sets.end()) &#123; map[s]++; if (map[s] &gt; max) &#123; res = s; max = map[s]; &#125; &#125; if (paragraph[i] != ' ')++i; j = i + 1; &#125; else if (i == paragraph.size() - 1) &#123; s = paragraph.substr(j, i -j + 1); transform(s.begin(), s.end(), s.begin(), ::tolower); if (sets.find(s) == sets.end()) &#123; map[s]++; if (map[s] &gt; max)res = s; &#125; &#125; &#125; return res;&#125; 题目：383. Ransom Note描述：Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. 例子：123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 代码：12345678910111213141516171819202122232425262728293031bool Solution383::canConstruct(string ransomNote, string magazine)&#123; //if (ransomNote.size() == 0)return true; //unordered_map&lt;char, int&gt;_ransom; //unordered_map&lt;char, int&gt;_mag; //for (char c : ransomNote) //&#123; // _ransom[c]++; //&#125; //for (char c : magazine) //&#123; // _mag[c]++; //&#125; //for (auto s : _ransom) //&#123; // if (s.second &gt; _mag[s.first])return false; //&#125; //return true; //way 2 以空间换时间 vector&lt;int&gt;_ransom(26); vector&lt;int&gt;_mag(26); for (char c : ransomNote) _ransom[c - 'a']++; for (char c : magazine) _mag[c - 'a']++; for (int i = 0; i &lt; 26; ++i) &#123; if (_ransom[i] &gt; _mag[i])return false; &#125; return true;&#125; 题目：21. Merge Two Sorted Lists描述：Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 例子：12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 代码：1234567891011121314151617181920212223242526272829303132333435363738394041 struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;;ListNode* Solution21::mergeTwoLists(ListNode* l1, ListNode* l2)&#123; if (l1 == NULL)return l2; if (l2 == NULL)return l1; ListNode *res = new ListNode(-1); ListNode *_res = res; ListNode *p = l1; ListNode *q = l2; while (q != NULL &amp;&amp; p != NULL) &#123; if (p-&gt;val &lt; q-&gt;val) &#123; res-&gt;next = p; p = p-&gt;next; &#125; else if(p-&gt;val &gt; q-&gt;val)&#123; res-&gt;next = q; q = q-&gt;next; &#125; else &#123; res-&gt;next = p; p = p-&gt;next; res = res-&gt;next; res-&gt;next = q; q = q-&gt;next; &#125; res = res-&gt;next; &#125; if (q != NULL) res-&gt;next = q; if (p != NULL) res-&gt;next = p; return _res-&gt;next;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吾日三省吾身]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[改掉不健康思维，easy life 为自己减压自从上次出现情绪之后，也没有刻意的去想怎样去解决，但是也在有意无意的寻找答案看过叔本华的《人生的智慧》之后，也有了一些收获和感悟除了自身之外其他一切的地位都只能排在第二等级，只有自身才是最重要的健康、幸福、处世态度、思维……总之，一切以自己为中心才能收获恒久的幸福把当下的许多时光用于回忆、用于对将来的担忧中，那一生都将是苦闷的，当下的我，只有享受当下的时光才能深刻体会生活的乐趣“所有急切而不愿意等待的人都是它的受害者。想要迫使正常、示中地行进着的时间加快脚步，需要符出高昂的代价。因此，我们一定要避免欠下时间巨额的高利贷”避免对自己的要求过高，顺其自然，一切的决定都凭借当下的想法衡量行事，不过分提前可以对自己要求，减少任务的压迫感任何事情都没有最好，自己为未来的期待并不超出自己的能力，都只是时间问题，所以不用操之过急对于感情的事，顺其自然，也要调节好自己的心态，不要因此过分独立，也不要因此而影响彼此的生活 也许我不是一个勇敢的人想说一句，好想骑车好想骑车好想骑车啊已经心痒痒了很久，一直在纠结自己是否有时间骑车，是否需要再买辆车，但是已经一年半没有骑车的我好难受啊每次路过捷安特看到有人在那里检查车，就忍不住多看几眼自从上次摔车之后自己的胆子就变小了，知道了安全的重要性，但是希望自己可以突破心理障碍，来一次骑行，并且在骑行前做好准备工作 还有就是最近迷上了画画，看那些大触的分享，简直停不下来，最近经常有画画的念头，但是我要克制呀，一幅画几个小时啥都不用干了，而且我这一画起来就心痒痒，很难把一幅画扯到一个星期画完我想画人像我想画人像我想画人像但是我怕毁……不知道啥时候能开始第一幅人像 重头再来深度学习之前写了两个kaggle，也看了一些教程代码，但是没有深入思考，理论不扎实，包括机器学习，所以希望可以从零开始有个扎实的基础，今天参加的机器学习的训练营开营了，希望有一个系统的学习，不知道这个训练营水不水……，总之希望打下扎实的基础，另外，强化学习让我很苦恼，希望能不太急于求成，看到GitHub上有100天学习深度学习，那希望也可以做这样的一个工作？ 讨厌的事情却不得不做？那就学着爱上它开发经验本来就不多，代码能力也不强，假期第一次接触游戏开发，内心无比的抵触，真的是懵，学长在给我分配任务，我在跟学长沟通需求的时候，我隔着屏幕感受到了无奈前天将项目前两周所有的代码看了一遍，内心透彻了许多，而且渐渐找到了一些有乐趣的地方，在这个项目中涉及了Websocket协议、Stream流和canvas绘图，昨天看了一篇游戏开发优化的思路，对游戏开发流程有了一个大概的了解，而且对工程流程了解了一下之后，发现也没有那么抵触它了，而且写需求容易了一些，提高了自己的效率同理，强化学习搞起来 发现我好奇的事情太多排不上日程啦我的量化、我的react so easy study,easy life]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-13-606]]></title>
    <url>%2F2018%2F08%2F13%2Fleetcode-string-easy-13-606%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是13,606 题目：13. Roman to Integer描述：Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.例子：123456789101112Input: &quot;III&quot;Output: 3Input: &quot;IV&quot;Output: 4Input: &quot;IX&quot;Output: 9Input: &quot;LVIII&quot;Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 代码：12345678910111213141516171819202122232425int Solution13::order(char c)&#123; if (c == 'I')return 1; else if (c == 'V') return 5; else if (c == 'X')return 10; else if (c == 'L') return 50; else if (c == 'C')return 100; else if (c == 'D')return 500; else if (c == 'M')return 1000; return -1;&#125;int Solution13::romanToInt(string s)&#123; int sum = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (i &lt; s.size() &amp;&amp; order(s[i]) &lt; order(s[i + 1])) &#123; sum += order(s[i + 1]) - order(s[i]); ++i; &#125; else sum += order(s[i]); &#125; return sum;&#125; 题目：606. Construct String from Binary Tree描述：You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. 例子：123456789101112131415161718192021222324Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;.Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 代码：12345678910111213141516171819202122 struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;string Solution606::tree2str(TreeNode* t)&#123; if (t == NULL)return ""; string s; s += to_string(t-&gt;val); if (t-&gt;left != NULL) s += "(" + tree2str(t-&gt;left) + ")"; if (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) s += "()"; if (t-&gt;right != NULL) s += "(" + tree2str(t-&gt;right) + ")"; return s;&#125; 请好心人告诉我，应该怎样测试606QAQ 2018-8-14日补充，昨天问了chai学长，补充我这个小白空洞的脑壳下面附上在VS正确的写法：Solution606.h把 结构体的定义放在类外面，只在类内部声明即可12345678910111213141516#pragma once#include&lt;string&gt;using namespace std;struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution606&#123;public: string tree2str(TreeNode* t); Solution606(); ~Solution606();&#125;; Solution606.cpp123456789101112131415string Solution606::tree2str(TreeNode* t)&#123; if (t == NULL)return ""; string s; s += to_string(t-&gt;val); if (t-&gt;left != NULL) s += "(" + tree2str(t-&gt;left) + ")"; if (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) s += "()"; if (t-&gt;right != NULL) s += "(" + tree2str(t-&gt;right) + ")"; return s;&#125; Source.cpp注意结构体TreeNode的初始化方法，结构体中的最后一行实际上是结构体的构造方法12345678910111213#include&lt;iostream&gt;#include "Solution606.h"using namespace std;int main() &#123; TreeNode *tt = new TreeNode(2); TreeNode *right = new TreeNode(3); tt-&gt;left = right; Solution606 s; string k = s.tree2str(tt); cout &lt;&lt; k &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《c++ primer plus》读书笔记]]></title>
    <url>%2F2018%2F08%2F13%2F%E3%80%8Ac-primer-plus%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[hexo 的目录结构太好了 预备知识c++在c语言的基础上添加了面向对象编程和泛型编程 c语言诞生的背景：贝尔实验室开发UNIX操作系统，需要一种高级语言代替汇编语言，避免在每台计算机上执行不同的汇编程序 c语言编程的原理（强调的是算法） 需要处理的概念——数据和算法 结构化编程和自顶向下的编程方法，将程序不断划分成程序单元，便于阅读和管理 面向对象编程： 面向对象编程强调数据，用类描述特定的数据结构 首先设计类，然后再设计程序解决问题，从低级组织到高级组织的处理过程叫做自下向上的编程 面向对象编程的优点： 有助于创建可重用的代码 信息隐藏可以保护数据 多态能够为运算符和函数创建多个定义，通过编程上下文确定使用哪个定义 继承能够使用旧类派生出新类 泛型编程： 目标：使重用代码和抽象通用概念的技术更简单 强调独立于特定数据类型 提供了执行常见任务的工具，即泛型编程与面向对象编程的应用场景不同 泛型指的是创建独立于类型的代码，比如设计一个排序函数，此排序函数不单独为整形、浮点型所设计，而泛型编程对语言进行扩展，以便可以只编写一个泛型函数 可移植性在不修改代码的情况下，更换计算机平台，重新编译程序后，程序运行良好，则该程序是可移植性的 可移植性的挑战： 硬件——避免 语言——标准：异常、运行阶段类型识别、模板和便准模板库 编译和链接使用visual c++2015进行编程步骤： 新建项目 选择win32–win32 console application 选择空项目 IDE环境 compile对当前打开的文件中的代码编译 build和make编译项目中所有源代码文件的代码，重新编译新修改文件 build all重新编译所有源代码文件 为了查看程序输出，可以在程序的最后加上下面的代码123cin.get();cin.get();return 0; cin.get()语句读取下一次键击，上述语句让程序等待，直到按下Enter键。如果程序在常规输入后留下一个没有被处理的键击，那么第二条语句是必需的，enter键将被第一个cin.get()吸收 问题问题1：什么是泛型编程？对编程语言进行扩展，以使程序不针对特定数据类型而适用 问题2：什么是多态和编程上下文？ 2018/7/14 开始学习c++一个简单的c++程序：123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; cout &lt;&lt; "hello world" &lt;&lt; endl; system("pause"); return 0;&#125; main()函数int main()叫函数头，{}包含的部分叫函数体 作为接口的函数头 函数头描述了函数与调用它的函数之间的接口，函数名前面的部分叫做函数返回类型，函数名后括号中的而部分叫做形参列表。通常main()被启动代码调用，启动代码是由编译器添加到程序中的，是程序和编译系统之间的桥梁 如果编译器到达main()函数末尾时没有遇到返回语句，认为以return 0结尾 c语言中，省略返回类型相当于函数类型为int，但是c++淘汰了这种用法 注释c++注释：// c注释：/**/ c++预处理器和iostream文件如果需要使用c++的输入或者输出工具，需要提供下面两行代码：12#include &lt;iostream&gt;using namespace std; 该编译指令使预处理器将iostream文件的内容添加到程序中，这涉及程序与外部世界之间的通信，iostream文件中的内容，将取代第一行代码，因此使用cin和cout的程序必须包含iostream c头文件的扩展名为h,c++头文件没有扩展名 名称空间名称空间编译指令using namespace std; 名称空间所解决的问题：名称空间支持是c++一项特性，在引用他人代码组合起来的时候解决函数名称共用问题。所引用的代码封装在名称空间单元中，可以用名称空间的名称来指出用哪个厂商的产品，比如wanda()函数的全称为Microflop::wanda() Piscine::wanda()，这样程序可以根据名称空间区分不同版本 所以cout实际上是std::cout,endl实际上是std::endl 所以也可以使用下面的代码代替using namespace std;123using std::cout;using std::endl;using std::cin; 使用cout进行c++输出cout是一个预定义的对象，&lt;&lt;表示信息流动方向，实际上是运算符重载 问题：什么是运算符重载？允许用户定义的类型重新定义运算符的含义 endl：重起一行，位于名称空间std中，在iostream中定义的,保证程序继续运行前刷新输出 \n:count &lt;&lt; &quot;what are you\n&quot;; 引号扩起的字符串通常用\n,其他情况用endl 1234567891011121314int main()&#123; int carrots; carrots = 25; cout &lt;&lt; "I have "; cout &lt;&lt; carrots; cout &lt;&lt; " carrots." &lt;&lt; endl; carrots = carrots - 1; cout &lt;&lt; "Now i hava " &lt;&lt; carrots &lt;&lt; " carrots" &lt;&lt; endl; system("pause"); return 0;&#125; 在声明变量的时候将为变量分配内存空间赋值语句将值赋给存储单元 可以连续使用赋值运算符 cout在打印之前，必须将整数形式的数字转换为字符串形式，&lt;&lt;会根据后面的数据类型相应的调整形式 类类描述的是数据格式和用法，对象则是根据数据格式创建的实体类描述指定了可对类对象执行的所有操作，c++两种发送消息的方式：类方法和运算符重载 c++中，函数调用必须 包括括号，即使没有参数 用户定义的函数添加另一个用户定义的函数，在使用前必须提供原型，放到main()定义之前 没有返回值的函数 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;void simon(int);int main()&#123; simon(3); system("pause"); return 0;&#125;void simon(int n)&#123; using namespace std; cout &lt;&lt; "simon says touch your toes " &lt;&lt; n &lt;&lt; " times." &lt;&lt; endl;&#125; 定义simon()的源代码位于main()后面，不允许将函数定义嵌套在另一个函数定义中 有返回值的函数 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int stonetolb(int);int main()&#123; int pounds = stonetolb(2); cout &lt;&lt; pounds &lt;&lt; endl; system("pause"); return 0;&#125;int stonetolb(int sts)&#123; return 14 * sts;&#125; 处理数据内置的c++数据类型分为——基本类型：整数和浮点数复合类型：数组、字符串、指针和结构 c++命名规则其一：以两个下划线或下划线和大写字母大头的名称被保留给实现，以一个下划线开头的名称被保留给实现，用作全局标识符 基本类型 整型short\int\long\long long short至少16位 int至少和short一样长 long至少32位，且至少与int一样长 long long至少64位，且至少与long一样长 可以用sizeof运算符返回类型或者变量的长度，单位是字节 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int a = INT_MAX; long n_long = LONG_MAX; long long x_llong = LLONG_MAX; cout &lt;&lt; "short is " &lt;&lt; sizeof (short) &lt;&lt; " bytes." &lt;&lt; endl;//2 cout &lt;&lt; "int is " &lt;&lt; sizeof(int) &lt;&lt; " bytes." &lt;&lt; endl;//4 cout &lt;&lt; "long is " &lt;&lt; sizeof(long) &lt;&lt; " bytes." &lt;&lt; endl;//4 cout &lt;&lt; "long long is " &lt;&lt; sizeof(long long) &lt;&lt; " bytes." &lt;&lt; endl;//8 cout &lt;&lt; "int is " &lt;&lt; a &lt;&lt; " bytes." &lt;&lt; endl;// 2147483647 cout &lt;&lt; "n_long is " &lt;&lt; n_long &lt;&lt; " bytes." &lt;&lt; endl;// 2147483647 cout &lt;&lt; "x_llong is " &lt;&lt; x_llong &lt;&lt; " bytes." &lt;&lt; endl;// 9223372036854775807 system("pause"); return 0;&#125; 初始化的方式：12int emus&#123; 7 &#125;;int rheads = &#123; 12 &#125;; 无符号类型 1unsigned short change 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n_int = INT_MAX; unsigned int un_int = INT_MAX; cout &lt;&lt; n_int &lt;&lt; endl; cout &lt;&lt; un_int &lt;&lt; endl; cout &lt;&lt; n_int + 1 &lt;&lt; endl; cout &lt;&lt; un_int + 1 &lt;&lt; endl; system("pause"); return 0;&#125; 无符号整型可以增大变量能够存储的最大值上面的例子中n_int进行过加1操作会变成赋值，因为符号为产生进位 ###整形字面量 c++能够用三种不同的计数方式来书写整数：基数为10，8，16如果第一位是0，第二位是1-7，则基数是8；如果前两位是0x或0X，则基数是16. 在默认情况下，cout以十进制格式显示整数，在计算机中存储都以二进制形式进行存储 endl提供了控制符dec hex oct分别指示cout以十进制、十六进制和八进制格式显示整数在打印的下一行加入下面的代码 1cout &lt;&lt; hex; char类型char类型是另一种整型，能存储所有基本符号 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; system("pause"); return 0;&#125; 程序输入字母也被输出，但是内存中存储的内容为字母对应的字符编码实际上，程序调用了cout的put函数1234567891011121314151617实际上`ch`存储的是整数，可以执行整数的操作，如加法```cpp#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; ch + 1 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 最后一行将输出78如果输入数字5，ch中将存储5的字符编码53，所以第二行输出54 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; ch + 1 &lt;&lt; endl; cout.put(ch); system("pause"); return 0;&#125; 书写字符常量的最简单方法是用单引号括起12&apos;A&apos;&apos;5&apos; 如果char型存储的是数值类型，那么unsigned char和signed char差异很重要，signed char表示范围是-128–127 布尔类型 非零值为true，零为false，true 可以转换为1，false转换为0 const限定符const关键字修改变量声明和初始化1const int Months = 12; 将名称的首字母大写，提醒自己表示常量 浮点数 123floatdoublelong double 浮点数表示法：12312.32.52e+8//小数点向右移动8位8.33E-4//小数点向左移动4位 c++算数运算符12345+-*/% 除法分支，如果两个操作数都是整数，执行整数除法，小数部分被丢弃，有一个是浮点数，则结果为浮点数 类型转换将一个值赋值给取值范围更大的类型通常不会导致问题，但是将一个很大的值赋值给一个较小的值会降低精度。 1int(&apos;Q&apos;); c++11中的auto声明，让编译器能够根据初始值的类型推断变量的类型 复合类型数组 编译器不会检查使用的下标是否有效 数组初始化：int a[3] = {20,1,2}; 初始化时，提供的值可以少于数组的元素数目，如果只对数组一部分进行初始化，编译器将把其他元素设置成0。初始化全为0：long b[3] = {0}; short thing[] = {1,5,2,3};编译器会计算元素个数 拓展：vector 字符串用char数组类型存储字符串，需要以空字符结尾，空字符被写作\012char dog[3] = &#123;&apos;b&apos;,&apos;e&apos;,&apos;a&apos;&#125;;//not a stringchar cat[3] = &#123;&apos;b&apos;,&apos;e&apos;,&apos;\0&apos;&#125;;//a string 很多处理字符串的函数的处理规则都是以遇到空字符停止 下面的字符串初始化也是合理的，用引号括起的字符串隐式包括 结尾的空字符 12char bird[11] = &quot;Mr. cheeps&quot;;char fish[] = &quot;bubbles&quot;; 在确定存储字符串所需的最短数组时，记得将结尾的空字符计算在内 拓展：string 标准头文件cstring提供了很多与字符串相关的函数123456789101112131415#include&lt;iostream&gt;//#include&lt;cstring&gt;using namespace std;int main()&#123; const int Size = 15; char name1[Size]; cin &gt;&gt; name1; cout &lt;&lt; strlen(name1) &lt;&lt; endl; system("pause"); return 0;&#125; 但是尝试注释调cstring头文件也没有报错 strlen不会计算空字符，若数组存储内容中间含有空字符，即使后面还有字符，字符串也会在空字符处结束；cin使用空白（空格、制表符和换行符）来确定字符串的结束位置 解决各个单词空格分开的问题：每次读取一行字符串输入istream中的类提供了一些面向行的类成员函数：getline()和get()，读取一行输入，直到到达换行符，但是getline()会丢弃换行符，get()将换行符保留在输入序列中。 1getline() 调用方法：1234567891011cin.getline(数组名称，字符数)``` 若字符数为20，最多读取19个字符```cpp const int Size = 15; char name1[Size]; char name2[Size]; cin.getline(name1, Size); cin.getline(name2, Size); cout &lt;&lt; name1 &lt;&lt; endl; cout &lt;&lt; name2 &lt;&lt; endl; 输入12youare 输出：12youare 1get() 调用方法：1234567891011cin.get(数组名称，字符数)``` ```cpp const int Size = 15; char name1[Size]; char name2[Size]; cin.get(name1, Size); cin.get(name2, Size); cout &lt;&lt; name1 &lt;&lt; endl; cout &lt;&lt; name2 &lt;&lt; endl; 输入：1you[回车] 自动输出（回车仍然在队列中）：12you[空行] 下面的代码等同于上上面的代码，用cin.get()吸收回车12345678const int Size = 15;char name1[Size];char name2[Size];cin.get(name1, Size);cin.get();cin.get(name2, Size);cout &lt;&lt; name1 &lt;&lt; endl;cout &lt;&lt; name2 &lt;&lt; endl; 下面代码等同：12cin.get(name1, Size).get();cin.get(name2, Size); get() 方法相比于getline()方法有优势，假设用get()将一行读入数组，如何知道停止读取的原因是由于读取了整行，而不是由于数组填满？解决方法就是查看下一个输入字符，如果是换行符说明读了整行，否则说明还有其他输入 还会有空行和其他问题，如何解决？ c++常使用指针而不是数组来处理字符串 string类简介string类包含在头文件string中，string类位于名称空间std中。string类定义隐藏了字符串的数组性质 未被初始化的数组，第一个空字符的出现位置是随机的，string类型未被初始化的长度为0 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str1; string str2 = "pather"; cin &gt;&gt; str1; cout &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; str2 &lt;&lt; endl; cout &lt;&lt; str2[2] &lt;&lt; endl; system("pause"); return 0;&#125; 类设计能够让程序自动处理string的大小 初始化：1string a = &#123;&quot;you are my baby&quot;&#125;; 赋值、拼接、附加 不能将一个数组赋值给另一个数组，但是可以将一个string对象赋给另一个string对象 123string str1;string str2 = &quot;father&quot;;str1 = str2; 可以使用+将两个string对象合并起来，还可以用运算符+=将字符串附加到string对象末尾 123string str3;str3 = str1 + str2;str1 += str2; 其他操作 strcpy(charr1,charr2);//copy charr2 to charr1 strcat(charr1,charr2);//append contents of charr2 to charr1 str1.size() strlen(charr1) 下面代码的cin作为参数传入，意在说明到哪里去找str1，此时这里的getline方法不是一个类方法，友元函数了解一下123string str1;getline(cin, str1);cout &lt;&lt; str1 &lt;&lt; endl; 问题：什么是友元函数？ 结构简介12345struct inflatable[名称]&#123; char name[20]; float volume; double price;&#125;; 一个结构体例子1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct MyStruct&#123; char name[10]; int age; bool sex;&#125;;int main()&#123; MyStruct guest = &#123; "Arya", 18, true &#125;; cout &lt;&lt; guest.name &lt;&lt; guest.age &lt;&lt; guest.sex &lt;&lt; endl; system("pause"); return 0;&#125; 结构声明的位置很重要，放在main()外面是外部声明，可以被后面的任何函数使用，内部声明只能被该声明所属的函数通用。 1Mystruct person[100]; 12345MyStruct guests[2] =&#123; &#123;"name1",12,true&#125;, &#123;"name2",20,false&#125;&#125;; 共用体用于节省内存，细节再看吧 枚举c++的enum工具提供了另一种创建符号向量的方式，可以代替const1enum spectrum &#123;red,orange,yellow&#125;; 让spectrum成为新类型的名称 让red,orange,yellow作为符号常量，对应整数值0-2 可以使用枚举名声明这种类型的变量spectrum band枚举只定义了赋值运算符，没有定义运算 设置枚举量的值 可以使用赋值运算符显式设置枚举量的值 1enum bits&#123;one = 1,two = 2, four = 4,eigth = 8&#125;; 可以只显示定义其中的一些枚举量的值 1enum bits&#123;one,second = 1000, a&#125;; 枚举量具有取值范围 指针和自由存储空间指针是一个变量，存储的是值的地址，而不是值本身，如果要找到常规变量的地址，只需要对变量应用地址运算符&amp;，就可以获得12int a = 4;cout &lt;&lt; &amp;a &lt;&lt; endl; 显示地址时，显示十六进制表示法，常用于描述内存的表示法 指针用途存储值得地址，因此指针名表示得是地址，*运算符被成为间接值或解除引用运算符，应用于指针，可以得到该地址存储得值， 12345678910int a = 4;int * a_address;a_address = &amp;a;cout &lt;&lt; "a address: " &lt;&lt; &amp;a &lt;&lt; endl;cout &lt;&lt; "a_update address: " &lt;&lt; a_address &lt;&lt; endl;cout &lt;&lt; "a value: " &lt;&lt; *a_address &lt;&lt; endl;a += 1;cout &lt;&lt; "a_update address: " &lt;&lt; &amp;a &lt;&lt; endl;cout &lt;&lt; "a address: " &lt;&lt; a_address &lt;&lt; endl;cout &lt;&lt; "a_update value: " &lt;&lt; *a_address &lt;&lt; endl; 以上程序结果表明，指针变量初始化后便不会再更改，当a得值变化时，可以根据*a_address访问到该地址存储得数值 下面的声明创建一个指针和一个变量1int* p1,p2; 下面的声明是有效的：12double * tax_ptr;char * str; 可以在声明语句的时候初始化指针，在这种情况下，被初始化的是指针，而不是它指向的值，创建指针的时候，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存 使用new来分配内存 前面都将指针初始化为一个变量的地址，但是指针真正的用途是在运行阶段分配未命名的内存以存储值，这种情况下只能通过指针来访问内存，c语言可以用库函数malloc()分配内存，但c++更好的办法是new运算符 12int * pn = new int;cout &lt;&lt; &quot;new de address: &quot; &lt;&lt; pn &lt;&lt; endl; new int告诉程序，需要存储int的内存，找到这块内存把地址返回给pn。 为一个数据对象获得并指定分配内存的通用格式如下：1typeName * pointer_name = new typeName; 使用delete释放内存 使用delete时，后面要加上指向内存块的指针12int * ps = new int;delete ps; 释放ps指向的内存，但不会删除指针ps本身，一定要配对的使用new和delete，否则将发生内存泄漏，被分配的内存再也无法使用 不要用delete释放声明变量所获得的内存，下述代码将不被允许123int jugs = 5;int * pi = &amp;jugs;delete pi; 使用new创建动态数组 1int * psome = new int [10]; new运算符返回第一个元素的地址，赋值给psome，并使用完内存块后，应用下面的格式释放：1delete [] psome; []表示释放整个数组 问题：如果使用new []为一个实体分配内存，则应该使用delete来释放？ 利用指针访问数组中的元素：123456int * pn = new int [3];pn[0] = 1;pn[1] = 3;pn[2] = 5;cout &lt;&lt; "array" &lt;&lt; pn[0] &lt;&lt; pn[1] &lt;&lt; pn[2] &lt;&lt; endl;delete [] pn; 可以把指针名当成数组名 指针、数组和指针算术 指针变量加1后，增加的量等于它指向的类型的字节数 12345double w[3] = &#123; 10000.0,20000.0,30000.0 &#125;;double * pw = w;cout &lt;&lt; "pw = " &lt;&lt; pw &lt;&lt; ", *pw= " &lt;&lt; *pw &lt;&lt; endl;pw = pw + 1;cout &lt;&lt; "pw = " &lt;&lt; pw &lt;&lt; ", *pw= " &lt;&lt; *pw &lt;&lt; endl; 输出： 12pw = 006FF7C4, *pw= 10000pw = 006FF7CC, *pw= 20000 指针和字符串，没有仔细看，用到的时候再看 使用new创建动态结构1Mystruct * ps = new Mystruct; 创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只是知道他的地址，c++专门为这种情况提供了一个运算符-&gt;，用于指向结构的指针 如果结构标识符是结构名，则使用句点运算符，如果标识符是指向结构的指针，则使用箭头运算符 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;struct MyStruct&#123; char name[10]; float volume; double price;&#125;;int main()&#123; MyStruct * ps = new MyStruct; cin.getline(ps-&gt;name, 20); cin &gt;&gt; ps-&gt;price; cin &gt;&gt; (*ps).volume; cout &lt;&lt; ps-&gt;name &lt;&lt; ps-&gt;price &lt;&lt; ps-&gt;volume &lt;&lt; endl; system("pause"); return 0;&#125; 自动存储、静态存储和动态存储（线程存储）自动变量通常存储在栈中，执行代码块时，其中的变量依次加入到栈中，离开代码块时，将按照相反的顺序释放这些变量。静态存储是整个程序执行期间都存在的存储方式，使变量成为静态的方式有两种：一种在函数外面定义它，一种实在声明变量的时候使用关键字static 自动存储和静态存储的关键在于这些方法限制了变量的寿命，静态变量可能存在于程序的整个生命周期，自动变量只是在特定函数被执行时存在 动态存储管理了一个内存池，静态变量和自动变量的内存是分开的，数据的生命周期不完全受程序或者函数的生存时间控制。 数组的替代品vector和array1234567891011121314#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vi; int n; cin &gt;&gt; n; vector&lt;double&gt; vd(n); system("pause"); return 0;&#125; vector可以动态增删元素vector比数组强大，但是比数组效率低，如果是长度固定的数组，则数组更佳array对象的长度也是固定的，使用栈而不是自由存储区，因此效率与数组相同。array对象允许直接复制，而数组必须逐元素复制123456789101112#include&lt;iostream&gt;#include&lt;array&gt;using namespace std;int main()&#123; array&lt;int,5&gt; vi; array&lt;double, 4&gt; vd = &#123;1.2,2.2,1.2,3.4&#125;; system("pause"); return 0;&#125; 可能导致数组越界行为，可以使用成员函数at()可以在运行期间捕获非法索引，程序默认终端，或者利用begin()和end()确定边界 循环和关系表达式++xx++12while(guests++ &lt; 10) cout &lt;&lt; guests &lt;&lt; endl; 先判断guests是否小于10，然后将guests++，再执行循环体 1strcmp(&quot;word&quot;,&quot;word&quot;); 比较两个字符串是否相同 12345int n = 1;do&#123; n++;&#125; while (n &lt;= 7); 满足条件的时候执行循环体 123double prices[5] = &#123; 1.2,1.3,1.4,3.5,2.4 &#125;;for (double x : prices) cout &lt;&lt; x &lt;&lt; endl; 遍历数组中的元素 123456789101112double prices[5] = &#123; 1.2,1.3,1.4,3.5,2.4 &#125;;for (double x : prices)&#123; x = x + 1; cout &lt;&lt; x &lt;&lt; endl;&#125;cout &lt;&lt; prices[3] &lt;&lt; endl;for (double &amp;x : prices)&#123; x = x + 1;&#125;cout &lt;&lt; prices[3] &lt;&lt; endl; 第一种循环不改变数组中的值，第二种引用变量可以使数组中的值改变 分支语句和逻辑运算符字符函数库cctype, 貌似有问题，测试了几个案例都木有通过p194c++从c语言继承了一个与字符相关的，非常方便的函数软件包，可以简化诸如确定字符是否为大写字母、数字、标点符号等工作1#include&lt;cctype&gt; 函数名称 返回值 案例 备注 数字，0 if字母2|```isalnum(33)```|12345678910111213141516171819```isalpha(字母)``` |if 字母，true||iscntrl()|if控制字符，true||isdigit()|if数字，true||switch语句---```cpp int a = 1; switch (a) &#123; case 1: cout &lt;&lt; a &lt;&lt; endl; break; case 2: cout &lt;&lt;&quot;a: &quot; &lt;&lt; a + 1 &lt;&lt; endl; break; default: cout &lt;&lt; &quot;break\n&quot;; break; &#125; 从上到下匹配条件，直到条件合适，从匹配到的条件一下的case语句的执行语句也都执行，所以要每条都加break break和continue语句continue语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环；在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行 简单文件输入/输出 写入到文本文件中文件输出条件： 必须包含头文件iostream 头文件iostream定义了一个用于处理输出的ostream类 头文件iostream声明了一个cout的ostream变量 必须指明名称空间std 必须包含头文件fstream 头文件fstream定义了一个用于处理输出的ofstream类 需要将ofstream对象与文件关联起来，使用open方法 使用完文件后，使用close方法关闭 写入文件的例子12345678910111213141516#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ofstream outFile; outFile.open("fish.txt"); double wt = 12.2342; char name[10] = "dream."; outFile &lt;&lt; wt &lt;&lt; endl; outFile &lt;&lt; name; system("pause"); return 0;&#125; 每次写入文件会将原来的内容清空 读取文本文件中 必须包含头文件fstream 头文件fstream定义了一个用于处理输入的ifstream类 需要声明一个或者多个ifstream变量 指明名称空间std 需要将ifstream对象和文件关联起来，使用open方法 使用完文件后，使用close方法将其关闭 使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据 使用ifstream对象和get（getline）方法读取一个（一行）字符 ifstream和eof()\fail()等方法判断输入是否成功 ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，被转换为true 读取文本文件的例子 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ifstream inFile; inFile.open("fish.txt"); char wt[10]; char name[10]; inFile.get(name,10); inFile.get(); inFile.getline(wt, 10); //infile &gt;&gt; wt; //infile &gt;&gt; name; cout &lt;&lt; wt &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; endl; system("pause"); return 0;&#125; 增加inFile.get()语句是因为，读取完文件中第一行内容后，有一个回车，需要用这条语句吸收回车，再进入到第二行读取，否则，第二个数组读取到空格即停止读取 如果试图打开一个不存在的文件用于输入，将导致输入时失败，所以可以先判断文件是否被打开，is_open(),比如下面的例子 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ifstream inFile; inFile.open("exe.txt"); if (!inFile.is_open()) &#123; cout &lt;&lt; "no file\n"; //exit(EXIT_FAILURE); &#125; cout &lt;&lt; "fa\n"; system("pause"); return 0;&#125; 读取文件的时候不应该超过EOF，如果最后一次读取数据的时候遇到EOF，方法eof()将返回true，程序可能遇到类型不匹配的情况，方法fail()将返回true，出现意外的情况方法bad()返回true。更简单的方法是使用good()方法，没有任何错误的时候返回true 1234while(inFile.good())&#123; inFile &gt;&gt; value;&#125; 函数编写自己函数的规则： 提供函数定义 提供函数原型 调用函数 一个函数例子 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void Put(double d);//函数原型int main()&#123; double w = 1.2; Put(w);//函数调用 system("pause"); return 0;&#125;void Put(double s)//函数定义&#123; cout &lt;&lt; s &lt;&lt; endl;&#125; 为什么需要原型 原型描述了函数到编译器的接口，将函数的返回值类型和参数的类型和数量告诉编译器，函数完成计算候，把返回值放在指定的位置，编译器知道检索多少个字节，以及如何解释他们 原型的语法 复制函数定义的函数头加分号，函数原型不要求提供参数的变量名 原型的功能 编译器正确处理函数返回值 检查使用的参数数目是否正确 检查参数类型是否正确 函数和数组一个函数和数组的例子 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int ArSize = 8;int sum_arr(int arr[], int n);int main()&#123; double w = 1.2; int cookies[ArSize] = &#123; 1,4,2,5,6,6,7,3 &#125;; int sum = sum_arr(cookies, ArSize); cout &lt;&lt; sum &lt;&lt; endl; system("pause"); return 0;&#125;int sum_arr(int arr[], int n)&#123; int total = 0; for (int i = 0; i &lt; n; i++) &#123; total = total + arr[i]; &#125; return total;&#125; 方括号为空表明可以将任何长度的数组传递给该函数，cookies是一个指针，因此该函数传递的是数组第一个元素的地址，所以下面的函数头也是正确的1int sum_arr(int * arr,int n) int arr[]表明arr不仅指向int还指向int数组的第一个int，而在其他的上下文中，这二者的含义并不相同 实际上函数并没有将数组内容传递给函数，而是将数组的地址、元素种类和元素数目传递给函数，传递常规变量时，函数将使用变量的拷贝，但是传递数组时，函数将使用原来的数组思考：为什么不能直接使用sizeof arr确定数组长度？cookies和arr指向同一个地址，但是sizeof cookies的值是32，是整个数组的长度，而sizeof arr是4，是指针变量的长度所以不能用sizeof arr 好处：将数组的地址作为参数可以节省复制整个数组所需的时间和内存，而且使用原始数组增加了破坏数据的风险 一个函数和数组的例子，如何更改数组和保护数组： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;const int Max = 5;int fill_array(double arr[], int n);//数组可以改变void show_array(const double arr[], int n);//const 保护数组不被改变void revalue(double d, double arr[], int n);//可以改变int main()&#123; using namespace std; double properties[Max]; int size = fill_array(properties, Max); if (size &gt; 0) &#123; cout &lt;&lt; "enter revaluation factor: "; double factor; while (!(cin &gt;&gt; factor))//检测是否有不好的输入 &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "bad input"; &#125; revalue(factor, properties, size); show_array(properties, size); &#125; cout &lt;&lt; "done\n"; system("pause"); return 0;&#125;int fill_array(double arr[], int limit)&#123; using namespace std;//在需要cout和cin的函数中应用 double temp; int i; for (i = 0; i &lt; limit; i++) &#123; cout &lt;&lt; "enter value #" &lt;&lt; (i + 1) &lt;&lt; ": "; cin &gt;&gt; temp; if (!cin)//bad input &#123; cin.clear(); while (cin.get() != '\n') &#123; continue; &#125; cout &lt;&lt; "bad input:input process terminated\n"; break; &#125; else if(temp &lt; 0) &#123; break; &#125; else &#123; arr[i] = temp; &#125; &#125; return i;&#125;void show_array(const double arr[], int n)&#123; using namespace std; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; "property #" &lt;&lt; (i + 1) &lt;&lt; ":$"; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;void revalue(double r, double arr[], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; arr[i] *= r; &#125;&#125; 另一个函数与数组的例子，使用数组区间 123456789101112131415161718192021222324#include&lt;iostream&gt;const int Max = 5;int sum_arr(const int * begin, const int * end);//注意这里传递的是指针int main()&#123; using namespace std; int properties[Max] = &#123;1,2,1,6,4&#125;; int size = sum_arr(properties, properties + Max); cout &lt;&lt; size &lt;&lt; endl; system("pause"); return 0;&#125;int sum_arr(const int * begin, const int * end)//const说明不可以通过指针修改数组&#123; const int * pt; int total = 0; for (pt = begin; pt != end; pt++) total = total + *pt; return total;&#125; 指针和const：常规变量的地址可以赋给常规指针；常规变量的地址可以赋给指向const的指针；const变量的地址可以赋给指向const的指针；但是const的地址赋给常规指针不可行,即下面的代码不可行 12const int a = 1;int * a_add = &amp;a; 函数和二维数组，这个也是写函数的时候最棘手的问题一个二位数组作为参数的例子1234567891011121314151617181920212223242526#include&lt;iostream&gt;const int Max = 5;int sum_arr(int arr[][4], int size);int main()&#123; using namespace std; int properties[Max][4] = &#123;&#123;1,2,1,6&#125;,&#123;4,2,4,1&#125;&#125;; int size = sum_arr(properties, 2); cout &lt;&lt; size &lt;&lt; endl; system("pause"); return 0;&#125;int sum_arr(int arr[][4], int size)&#123; int total = 0; for(int r = 0;r &lt; size;r++) for (int c = 0; c &lt; 4; c++) &#123; total = total + arr[r][c]; &#125; return total;&#125; 函数头的写法：12int sum_arr(int arr[][4],int size)int sum_arr(int (*arr)[4],int size) 这两种都是可以的，指针的外围括号是必须的，size表示行数，4表示列数，所以可以想正常数组一样访问二维数组，声明一个4维指针数组，只不过限定了数组的列数 字符串和函数一个字符串函数的例子12345678910111213141516171819202122232425#include&lt;iostream&gt;unsigned int c_in_str(const char * str, char ch);int main()&#123; using namespace std; char a[15] = "emmm..."; char * wail = "unbantu"; unsigned int ms = c_in_str(a, 'm'); unsigned int us = c_in_str(wail, 'u'); cout &lt;&lt; ms &lt;&lt; us &lt;&lt; endl; system("pause"); return 0;&#125;unsigned int c_in_str(const char * str, char ch)&#123; unsigned int count = 0; while (*str) &#123; if (*str == ch) count++; str++; &#125; return count;&#125; 字符串第一个元素的地址作为参数传入，字符串的最后一个字符是 ‘\0’，可以判断结束表示，所以不用传入数组长度，while(*str) 如果要返回字符串函数，可以返回字符串的地址，这样的效率更高 123456789101112131415161718192021222324#include&lt;iostream&gt;char * buildstr(char c, int n);int main()&#123; using namespace std; char * wail = buildstr('c',10); cout &lt;&lt; sizeof(wail) &lt;&lt; endl;//4指向第一个元素的地址 cout &lt;&lt; wail &lt;&lt; endl; delete[] wail; system("pause"); return 0;&#125;char * buildstr(char c, int n)&#123; char * pstr = new char[n + 1];//new一个n个字符的数组，最后一位存储'\0' //pstr指向数组的第一个元素的地址 pstr[n] = '\0'; while (n-- &gt; 0)//先执行n&gt;0逻辑运算，然后再执行n--,再执行循环体 &#123; pstr[n] = c; &#125; return pstr;&#125; 变量pstr的作用于在函数内，所以函数结束时，pstr（而不是字符串）使用的内存将被释放 main中的当字符串不再需要的时候，用delete释放内存 问题：怎样区分一个指针指向整个数组地址还是数组首地址？问题：函数中的new的地址已经在函数结束的时候释放掉为什么在主函数中还需要delete，new和delete配对使用？ 让函数返回一个指针，该指针指向new分配的内存的缺点时，程序员必须记住使用delete,在12章，将知道c++类如何使用==构造函数和析构函数==处理这些细节 函数和结构函数使用原始结构的副本，函数也可以返回结构；与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;，c++还是使用这个运算符表示引用变量 传递和返回结构 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;const int Mins_per_hr = 60;struct travel_time&#123; int hours; int mins;&#125;;travel_time sum(travel_time t1, travel_time t2);//放在结构定义下面void show_time(travel_time t);int main()&#123; using namespace std; travel_time day1 = &#123; 5,45 &#125;; travel_time day2 = &#123; 4,55 &#125;; travel_time trip = sum(day1, day2); show_time(trip); system("pause"); return 0;&#125;travel_time sum(travel_time t1, travel_time t2)//返回结构&#123; travel_time total; total.mins = (t1.mins + t2.mins) % Mins_per_hr; total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr; return total;&#125;void show_time(travel_time t)//传递结构&#123; using namespace std; cout &lt;&lt; t.hours &lt;&lt; "hours, " &lt;&lt; t.mins &lt;&lt; " minutes\n";&#125; 传递结构的地址上面的例子修改如下：12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;const int Mins_per_hr = 60;struct travel_time&#123; int hours; int mins;&#125;;travel_time sum(const travel_time * t1, const travel_time * t2);void show_time(const travel_time * t);int main()&#123; using namespace std; travel_time day1 = &#123; 5,45 &#125;; travel_time day2 = &#123; 4,55 &#125;; travel_time trip = sum(&amp;day1, &amp;day2); show_time(&amp;trip); system("pause"); return 0;&#125;travel_time sum(const travel_time * t1, const travel_time * t2)&#123; travel_time total; total.mins = (t1-&gt;mins + t2-&gt;mins) % Mins_per_hr; total.hours = t1-&gt;hours + t2-&gt;hours + (t1-&gt;mins + t2-&gt;mins) / Mins_per_hr; return total;&#125;void show_time(const travel_time * t)&#123; using namespace std; cout &lt;&lt; t-&gt;hours &lt;&lt; "hours, " &lt;&lt; t-&gt;mins &lt;&lt; " minutes\n";&#125; 函数和string对象1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int Size = 5;void display(const string sa, int n);int main()&#123; string list = "you are very good."; display(list, Size); system("pause"); return 0;&#125;void display(const string sa, int n)&#123; cout &lt;&lt; sa &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int Size = 5;void display(const string sa[], int n);int main()&#123; string list[Size];//string类型的数组 for (int i = 0; i &lt; Size; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; ": "; getline(cin, list[i]); &#125; display(list, Size); system("pause"); return 0;&#125;void display(const string sa[], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; sa[i] &lt;&lt; endl; &#125;&#125; 函数和array对象123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;array&gt;#include&lt;string&gt;using namespace std;const int Seasons = 5;const array&lt;string, Seasons&gt; Snames = &#123; "spring","summer","fall","winter" &#125;;void show(array&lt;double, Seasons&gt; da);void fill(array&lt;double, Seasons&gt; * pa);int main()&#123; array&lt;double, Seasons&gt; expenses; fill(&amp;expenses); show(expenses); system("pause"); return 0;&#125;void fill(array&lt;double, Seasons&gt; * pa)//需要对pa进行修改，所以是引用&#123; for (int i = 0; i &lt; Seasons; i++) &#123;//Snames是全局变量，可以直接调用 cout &lt;&lt; "enter " &lt;&lt; Snames[i] &lt;&lt; "expenses: "; cin &gt;&gt; (*pa)[i]; &#125;&#125;void show(array&lt;double, Seasons&gt; da)&#123; double total = 0.0; cout &lt;&lt; "\nexpenses\n"; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; Snames[i] &lt;&lt; ":$" &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; &#125; cout &lt;&lt; "total expenses:$" &lt;&lt; total &lt;&lt; endl;&#125; 递归函数指针函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址，可以编写将另一个函数的地址作为参数的函数，这样第一个函数能够找到第二个函数并运行，它允许在不同的时间传递不同函数的地址 获取函数地址要将函数作为参数传递，必须传递函数名。区分函数地址和函数返回值 声明函数指针声明指定函数的返回类型以及函数的参数列表 12double pam(int);//函数原型double (*pf)(int);//声明函数指针 技巧：编写函数原型，然后用1234567891011121314151617181920212223242526273. 使用函数指针来调用函数一个函数指针的例子```cpp#include&lt;iostream&gt;using namespace std;double betsy(int lns);void estimate(int lines, double(*pf)(int));int main()&#123; int code = 7; estimate(code, betsy);//调用函数指针 system(&quot;pause&quot;); return 0;&#125;double betsy(int lns)&#123; return 0.05 * lns;&#125;void estimate(int lines, double(*pf)(int))&#123; cout &lt;&lt; lines &lt;&lt; &quot; lines will tak &quot;; cout &lt;&lt; (*pf)(lines) &lt;&lt; &quot; hours\n&quot;;//调用函数&#125; 简化声明的工具 1auto 1typedef 能够帮助创建类型别名double real;```1234567891011121314151617181920212223242526272829第8章 函数探幽===第9章内存模型和名称空间===第10章 对象和类===实际编程中已经实现了一些对象编程，有先验经验，不做过多的记录类规范组成：- 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口- 类方法定义：描述如何实现成员函数声明Stock类类型的变量，称为对象或实例使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数或者友元函数来访问对象的私有成员。所以公有成员函数是程序和对象的私有成员之间的桥梁。类涉及尽可能将公有接口和实现细节分开，将实现细节放在一起并将他们与抽象分开被称为封装。数据项通常放在私有部分，组成类接口的成员函数放在公有部分不必在类声明中使用关键字`private`，对类对象的默认访问控制- 实现类成员函数定义成员函数时，使用作用域解析运算符`::`来表示函数所属的类；类方法可以访问类的private组件 void Stock::update(double price)123456789101112131415161718192021222324252627282930313233意味着定义的函数是Stock成员Stock类的其他成员函数不必使用作用域解析运算符，就可以使用update()方法。内联方法：其定义位于类声明中的函数都将自动称为内联函数。也可以在类声明之外定义成员函数，并使其称为内联函数，只需在类实现部分中定义函数时使用inline限定符所创建的每个新对象都有自己的存储空间，存储内部变量和类成员，但是同一个类的所有对象共享同一组类方法，即每种方法只有一个副本一个实现面向对象编程的例子Stock.h```cpp#pragma once#include&lt;string&gt;class Stock&#123; std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: void acquire(const std::string &amp; co, long n, double pr); void buy(long num, double price); void sell(long num, double pricec); void update(double price); void show(); Stock();//构造函数 ~Stock();//析构函数&#125;; Stock.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include "Stock.h"void Stock::acquire(const std::string &amp; co, long n, double pr)&#123;//管理某个公司股票首次购买 company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; "number of shares cant be negative; " &lt;&lt; company &lt;&lt; "shares set to 0.\n"; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;void Stock::buy(long num, double price)&#123; if (num &lt; 0) &#123; std::cout &lt;&lt; "number of shares purchased cant be negative. " &lt;&lt; "transaction is aborted.\n"; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price)&#123; using std::cout; if (num &lt; 0) &#123; cout &lt;&lt; "number of shares sold cant be negative.\n"; &#125; else if (num &gt; shares) &#123;//用户试图卖出超过他持有的股票数量 cout &lt;&lt; "you cant sell more than you have!\n"; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price)&#123; share_val = price; set_tot();&#125;void Stock::show()&#123; std::cout &lt;&lt; "company: " &lt;&lt; company &lt;&lt; " shares: " &lt;&lt; shares &lt;&lt; "\n" &lt;&lt; "share price:$" &lt;&lt; share_val &lt;&lt; " total worth:$" &lt;&lt; total_val &lt;&lt; "\n";&#125;Stock::Stock()//类构造函数&#123; company = "no name"; shares = 0; share_val = 0.0; total_val = 0.0;&#125;//Stock::~Stock()//&#123;//&#125; Source.cpp12345678910111213141516171819#include&lt;iostream&gt;#include "Stock.h"int main()&#123; Stock fluffy_the_cat; fluffy_the_cat.acquire("NanoSmart", 20, 12.5); fluffy_the_cat.show(); fluffy_the_cat.buy(15, 19.2); fluffy_the_cat.show(); fluffy_the_cat.sell(400, 20.0); fluffy_the_cat.show(); fluffy_the_cat.buy(30000, 40.12); fluffy_the_cat.show(); fluffy_the_cat.sell(30000, 0.12); fluffy_the_cat.show(); system("pause"); return 0;&#125; 延伸：控制格式cout.setf() cout.precision(3) 类的构造函数和析构函数为类提供被称为构造函数和析构函数的标准函数c++的目标之一是让使用类对象就像使用标准类型一样，主要问题在于数据成员是私有的 解决方法是创造新对象时，自动对它初始化，c++提供了一个特殊的成员函数，类构造函数，专门用于构造新对象，将值赋给他的数据成员。Stock类一个可能的构造函数是名为Stock()的成员函数。构造函数没有声明类型 声明和定义构造函数 通常应提供所有类成员做隐式初始化的默认构造函数 初始化：123Stock first;Stock first = Stock();Stock * prelief = new Stock; 析构函数 用构造函数创建对象后，程序负责跟踪该对象，直到过期为止，对象过期时，程序将自动调用一个特殊的成员函数——析构函数，完成清理工作析构函数的名称在类名前加上~。 析构函数不承担任何重要工作，可以编写为不执行任何操作的函数 通常不应再代码中显式地调用析构函数，如果创建的是静态存储类对象，析构函数再程序结束时自动被调用，如果创建的时自动存储类对象，将再程序执行完代码块时自动被调用。如果对象是通过new创建的，将驻留再栈内存或者自由存储区，使用delete来释放内存时，析构函数将自动被调用 修改上面例子如下： 12345678910111213141516171819#pragma once#include&lt;string&gt;class Stock&#123; std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: void acquire(const std::string &amp; co, long n, double pr); void buy(long num, double price); void sell(long num, double pricec); void update(double price); void show(); Stock();//构造函数 Stock::Stock(const std::string &amp; co, long n, double pr);//另一个构造函数,函数重载 ~Stock();//析构函数&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include "Stock.h"void Stock::acquire(const std::string &amp; co, long n, double pr)&#123;//管理某个公司股票首次购买 company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; "number of shares cant be negative; " &lt;&lt; company &lt;&lt; "shares set to 0.\n"; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;void Stock::buy(long num, double price)&#123; if (num &lt; 0) &#123; std::cout &lt;&lt; "number of shares purchased cant be negative. " &lt;&lt; "transaction is aborted.\n"; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price)&#123; using std::cout; if (num &lt; 0) &#123; cout &lt;&lt; "number of shares sold cant be negative.\n"; &#125; else if (num &gt; shares) &#123;//用户试图卖出超过他持有的股票数量 cout &lt;&lt; "you cant sell more than you have!\n"; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price)&#123; share_val = price; set_tot();&#125;void Stock::show()&#123; std::cout &lt;&lt; "company: " &lt;&lt; company &lt;&lt; " shares: " &lt;&lt; shares &lt;&lt; "\n" &lt;&lt; "share price:$" &lt;&lt; share_val &lt;&lt; " total worth:$" &lt;&lt; total_val &lt;&lt; "\n";&#125;Stock::Stock()&#123; company = "no name"; shares = 0; share_val = 0.0; total_val = 0.0;&#125;Stock::Stock(const std::string &amp; co, long n, double pr)&#123; std::cout &lt;&lt; "constructor using " &lt;&lt; co &lt;&lt; " called\n"; company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; "number of shares cant be negative.\n"; shares = 0; &#125; else shares = n; share_val = pr; set_tot();&#125;Stock::~Stock()&#123; std::cout &lt;&lt; "bye, " &lt;&lt; company &lt;&lt; std::endl;&#125; 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;#include "Stock.h"int main()&#123; &#123; Stock stock1("NanoSmart", 12, 20.0); stock1.show(); Stock stock2 = Stock("Boffo", 2, 2.0); stock2.show(); stock1 = stock2; &#125; system("pause"); return 0;&#125; 在主函数中多了一个大括号，析构函数在程序退出其定义所属的代码块时消失，如果没有大括号，代码块将为整个main()，main()执行完毕后调用析构函数，就看不到输出了 注意程序初始化的方式：12Stock stock1(&quot;NanoSmart&quot;, 12, 20.0);Stock stock2 = Stock(&quot;Boffo&quot;, 2, 2.0); 如果构造函数使用了new，则必须提供使用delete的析构函数 this指针每个成员函数都有一个this指针，this指针指向调用对象，如果方法需要引用整个调用对象，则可以使用表达式*this，在函数的括号后面使用const限定符，则不能使用this来修改对象的值，this是指隐式对象的地址，对象本身为*this将下面这段代码加入到stock.cpp文件中 1234567const Stock &amp; Stock::topval(const Stock &amp; s) const&#123; if (s.total_val &gt; total_val) return s; else return *this;//返回隐式对象&#125; 对象数组12345678910111213void Stock::show() const&#123; using std::ios_base; using std::cout; ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);//fixed是枚举量 std::streamsize prec = cout.precision(3); std::cout &lt;&lt; "company: " &lt;&lt; company &lt;&lt; " shares: " &lt;&lt; shares &lt;&lt; "\n" &lt;&lt; "share price:$" &lt;&lt; share_val; cout.precision(2); cout&lt;&lt; " total worth:$" &lt;&lt; total_val &lt;&lt; "\n"; cout.setf(orig, ios_base::floatfield); cout.precision(prec);&#125; 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;#include "Stock.h"int main()&#123; const int size = 2; Stock stocks[size] = &#123; Stock("nano",12.5l,20), Stock("boffo", 20.2l, 1200) &#125;; const Stock * top = &amp;stocks[0];//这里还需要再明确 top = &amp;top-&gt;topval(stocks[1]); top-&gt;show(); system("pause"); return 0;&#125; 类作用域在类中定义的名称的作用域都为整个类，使用类成员名时，必须根据上下文使用直接成员运算符.,间接成员运算符-&gt;或作用域解析运算符::作用域为类的常量—— 使用枚举 1234567class Bakery&#123; private: enum &#123;Months = 12&#125;; double cots[Months]; ...&#125; 使用关键字static1234567class Bakery&#123;private: static const int Months = 12; double costs[Months]; ...&#125; 该变量与其他静态变量存储在一起，而不是存储在对象中，所有Bakery对象共享这一个变量 抽象数据类型emmm，看到这里好像看到了我原来面试的一道题 123456789101112131415#pragma oncetypedef unsigned long Item;//重新命名unsigned longclass Stack&#123; enum &#123;MAX = 10&#125;; Item items[MAX];//栈中存储的数据 int top;//栈顶index,指向栈顶为空的位置public: Stack(); bool isempty() const; bool isfull() const;//隐式对象不可变 bool push(const Item &amp; item);//隐式对象有变化 bool pop(Item &amp; item); ~Stack();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041#include "Stack.h"Stack::Stack()//创建空栈&#123; top = 0;&#125;bool Stack::isempty() const&#123; return top == 0;&#125;bool Stack::isfull() const&#123; return top == MAX;&#125;bool Stack::push(const Item &amp; item)&#123; if (top &lt; MAX) &#123; items[top++] = item;//先赋值，top++ return true; &#125; else return false;&#125;bool Stack::pop(Item &amp; item)&#123; if (top &gt; 0) &#123; item = items[--top];//top--,赋值 return true; &#125; else return false;&#125;Stack::~Stack()&#123;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;#include "Stock.h"#include "Stack.h"using namespace std;int main()&#123; Stack st; char ch; unsigned long po; cout &lt;&lt; "pls. enter A to add a purchase order,\n" &lt;&lt; "P to process a PO,or Q to quit,\n"; while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != 'Q') &#123; while (cin.get() != '\n') continue; if (!isalpha(ch)) &#123; cout &lt;&lt; '\a'; continue; &#125; switch (ch) &#123; case 'A': case 'a':cout &lt;&lt; "enter a po number to add: "; cin &gt;&gt; po; if (st.isfull()) cout &lt;&lt; "stack is full\n"; else st.push(po); break; case 'P': case 'p': if (st.isempty()) cout &lt;&lt; "stack is empty\n"; else &#123; st.pop(po); cout &lt;&lt; po &lt;&lt; " popped\n"; &#125; break; default: break; &#125; &#125; system("pause"); return 0;&#125; 第11章 使用类运算符重载，应用于类对象1operator op() operator +() operator *() 友元函数，允许访问私有数据重载&lt;&lt;运算符，用于输出状态成员rand生成随机值类的自动转换和强制类型转换类转换函数先看到这里，需要提升的时候再接着看]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring入门]]></title>
    <url>%2F2018%2F08%2F12%2FSpring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[从零开始构建spring工程小例子 简单的spring例子环境：idea新建工程步骤参考：https://blog.csdn.net/zzy1078689276/article/details/78732183/ 可以不选择步骤中的archetype我的工程名字是spring-start 工程初始化会下载一些依赖，需要一些时间 编辑pom.xml文件，填写工程所依赖的库的配置信息123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.alisa&lt;/groupId&gt; &lt;artifactId&gt;spring-start&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring3-Example&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--sprint3 deploy--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置项规定了工程的编码格式和依赖的包包括:junit和org.springframework.spring-context org.springframework.spring-core 创建目录结构我的目录结构如图所示： 如果右键新建没有class和package,请参考这篇博客：https://blog.csdn.net/qq_27093465/article/details/52912444我设置的java文件夹Sources，resources文件夹是Resources 编辑HelloWorld App SpringBeans文件HelloWorld1234567891011package com.alisa.demo.helloworld;public class HelloWorld &#123; private String name; public void setName(String n)&#123; this.name = n; &#125; public void printHello()&#123; System.out.println("hello:"+name); &#125;&#125; App文件通过getBean方法（参数是id）访问配置文件中的bean标签（可能我的说法不准确)1234567891011121314package com.alisa.demo.spring3_Example;import com.alisa.demo.helloworld.HelloWorld;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml");//声明从SpringBeans.xml获取配置文件 HelloWorld obj = (HelloWorld) context.getBean("helloBean"); obj.printHello(); &#125;&#125; SpringBeans文件中重要的是bean标签的编辑，在一个文件中bean标签的id唯一，class属性定义所连接的java class文件，&lt;property&gt;定义了与class相关的值，这里主要是name和value，我的理解是将class文件中的name变量的值设置为alisa.12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloBean&quot; class=&quot;com.alisa.demo.helloworld.HelloWorld&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;alisa&quot; &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行便可出现结果 实现松耦合在包com.alisa.demo下新建包loosely_coupled,并在此目录下新建Interface和class文件IOutputGenerator实现抽象类12345package com.alisa.demo.loosely_coupled;public interface IOutputGenerator &#123; public void generatorOutput();&#125; CsvOutputGenerator重写上面接口函数1234567package com.alisa.demo.loosely_coupled;public class CsvOutputGenerator implements IOutputGenerator&#123; public void generatorOutput() &#123; System.out.println("creating csv..."); &#125;&#125; JsonOutputGenerator重写继承的接口函数1234567package com.alisa.demo.loosely_coupled;public class JsonOutputGenerator implements IOutputGenerator&#123; public void generatorOutput() &#123; System.out.println("creating json..."); &#125;&#125; OutputHelper文件可以设定当前的OutputGenerator实例对象123456789101112package com.alisa.demo.loosely_coupled;public class OutputHelper &#123; IOutputGenerator outputGenerator; public void generatorOutput()&#123; this.outputGenerator.generatorOutput();//设定实例对象的输出函数 &#125; public void setOutputGenerator(IOutputGenerator outputGenerator) &#123; this.outputGenerator = outputGenerator;//设定实例对象 &#125;&#125; 在resources下新建Spring-Output.xml文件，id为OutputHelper的bean是App文件中所连接的bean，指定java class文件，设置class文件中的outputGenerator值为CsvOutputGenerator(这里从上面的value属性改为ref属性我不是很理解)，可能ref属性会寻找当前配置文件中id属性值为CsvOutputGenerator的bean标签，从而得到该CsvOutputGenerator类的内容12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name=&quot;outputGenerator&quot; ref=&quot;CsvOutputGenerator&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;CsvOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;JsonOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.JsonOutputGenerator&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 修改App文件，没有明确指出所定义的输出实例对象是哪一个，而是通过配置文件来设定12345678910111213141516package com.alisa.demo.spring3_Example;import com.alisa.demo.helloworld.HelloWorld;import com.alisa.demo.loosely_coupled.OutputHelper;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("Spring-Output.xml");//修改配置文件// HelloWorld obj = (HelloWorld) context.getBean("helloBean");// obj.printHello(); OutputHelper outputHelper = (OutputHelper)context.getBean("OutputHelper"); outputHelper.generatorOutput(); &#125;&#125; 实现了通过Spring-Output.xml控制代码输出 Spring Ioc容器Spring中给Bean属性注入value在包com.alisa下新建包spring.bean在该包下新建class文件FileNameGenerator和App123456789101112131415161718192021222324package com.alisa.spring.bean;public class FileNameGenerator &#123; private String name; private String type; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public void printFileName()&#123; System.out.println("filename &amp; filetype is:"+name+" &amp; "+type); &#125;&#125; App12345678910111213package com.alisa.spring.bean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml"); FileNameGenerator obj = (FileNameGenerator) context.getBean("FileNameGenerator"); obj.printFileName(); &#125;&#125; 编辑SpringBeans.xml文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloBean" class="com.alisa.demo.helloworld.HelloWorld"&gt; &lt;property name="name" value="alisa" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="FileNameGenerator" class="com.alisa.spring.bean.FileNameGenerator"&gt; &lt;property name="name"&gt; &lt;value&gt;alisa&lt;/value&gt; &lt;/property&gt; &lt;!--&lt;property name="name" value="alisa"&gt;&lt;/property&gt;--&gt; &lt;property name="type"&gt; &lt;value&gt;txt&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--&lt;bean id="FileNameGenerator" class="com.alisa.spring.bean.FileNameGenerator" p:name="alisa" p:type="txt"&gt;&lt;/bean&gt;--&gt;&lt;/beans&gt; 注意到value属性的三种定义方式： name12 &lt;value&gt;alisa&lt;/value&gt;&lt;/property&gt; name13. ```&lt;bean id=&quot;FileNameGenerator&quot; class=&quot;com.alisa.spring.bean.FileNameGenerator&quot; p:name=&quot;alisa&quot; p:type=&quot;txt&quot;&gt;&lt;/bean&gt; 第三种方式需要在开头加上xmlns:p=&quot;http://www.springframework.org/schema/p&quot; Spring Inner Bean–内部嵌套的Bean内置嵌套的Bean支持属性注入和构造函数注入 在实现【松耦合】一节中所提到的ref属性其实就是Bean内部嵌套，所以我之前的猜想是正确的重新回顾那一节的配置文件12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name=&quot;outputGenerator&quot; ref=&quot;CsvOutputGenerator&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;CsvOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;JsonOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.JsonOutputGenerator&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 利用ref属性引用了CsvOutputGenerator,但是一旦CsvOutputGenerator引用，就不会被别的Bean引用采用下面的方法可以避免这样的问题： 修改方式如下：123456789&lt;!--&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt;--&gt; &lt;!--&lt;property name=&quot;outputGenerator&quot; ref=&quot;CsvOutputGenerator&quot;&gt;&lt;/property&gt;--&gt;&lt;!--&lt;/bean&gt;--&gt;&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name=&quot;outputGenerator&quot;&gt; &lt;bean class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 在内部声明一个Bean，但是我并没有觉得方便，还有一种方式是：12345678910&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;constructor-arg&gt; &lt;bean class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt; &lt;/bean&gt; &lt;/constructor-arg&gt; &lt;!--&lt;property name=&quot;outputGenerator&quot;&gt;--&gt; &lt;!--&lt;bean class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;/property&gt;--&gt;&lt;/bean&gt; 但是这个例子在我这里显示是错的，还没有搞懂是为什么 Spring Bean Scopes–Bean的作用域Bean的作用域决定了从Spring容器中返回的Bean实例的类型。在Spring中，支持以下5种类型的作用域： singleton——单利模式，由IOC容器返回一个唯一的bean实例 prototype——原型模式，被请求时，每次返回一个新的bean实例 request——每个http request请求返回一个唯一的bean实例 session——每个http session返回一个唯一的bean实例 globalSession——http session全局bean实例 ###singleton 和prototype区别新建包com.alisa.spring.customer.services在该目录下新建class文件CustomerService和App123456789101112package com.alisa.spring.customer.services;public class CustomerService &#123; String message; public String getMessage()&#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; App12345678910111213141516package com.alisa.spring.customer.services;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml"); CustomerService customerService = (CustomerService)context.getBean("CustomerService"); customerService.setMessage("message by 1"); System.out.println("1:"+customerService.getMessage()); CustomerService customerService2 = (CustomerService)context.getBean("CustomerService"); System.out.println("2:"+customerService2.getMessage()); &#125;&#125; 在SpringBeans.xml文件中新增下面语句，分别将scope参数设置成prototype singleton看下结果 1&lt;bean id=&quot;CustomerService&quot; class=&quot;com.alisa.spring.customer.services.CustomerService&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 在prototype模式下每次调用getBean函数都生成一个新的实例 Spring collections–集合类型的Bean主要讲怎样将值注入集合类型： List Set Map Properties 在b包spring下面新建包collections,新建Customer Person App类编辑文件Person12345678910111213141516171819202122232425package com.alisa.spring.collections;public class Person &#123; private String name; private String address; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString()&#123; return "Person [address="+address+",name="+name+"]"; &#125;&#125; Customer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.alisa.spring.collections;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Customer &#123; private List&lt;Object&gt; lists; private Set&lt;Object&gt; sets; private Map&lt;Object,Object&gt; maps; private Properties pros; public List&lt;Object&gt; getLists()&#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Set&lt;Object&gt; getSets() &#123; return sets; &#125; public void setSets(Set&lt;Object&gt; sets) &#123; this.sets = sets; &#125; public Map&lt;Object, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;Object, Object&gt; maps) &#123; this.maps = maps; &#125; public Properties getPros() &#123; return pros; &#125; public void setPros(Properties pros) &#123; this.pros = pros; &#125; private Person person; public Customer(Person person)&#123; this.person = person; &#125; public Customer()&#123;&#125; public void setPerson(Person person) &#123; this.person = person; &#125; @Override public String toString() &#123; return "Customer [person="+person+"]"; &#125;&#125; App1234567891011121314151617181920package com.alisa.spring.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringCollections.xml"); Customer obj = (Customer) context.getBean("CustomerBean"); System.out.println(obj.getLists().toString()); System.out.println(obj.getMaps().toString()); System.out.println(obj.getPros().toString()); System.out.println(obj.getSets().toString());// [1, Person [address=beijing,name=alisa], 2, Person [address=jilin,name=ben]]// &#123;a=1, b=Person [address=beijing,name=alisa], c=Person [address=jilin,name=ben]&#125;// &#123;admin=admin, support=support&#125;//[1, Person [address=beijing,name=alisa], Person [address=jilin,name=ben]] &#125;&#125; 编辑配置文件SpringCollections.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.alisa.spring.collections.Customer&quot;&gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean=&quot;personBean&quot;&gt;&lt;/ref&gt; &lt;value&gt;2&lt;/value&gt; &lt;bean class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ben&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;jilin&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean=&quot;personBean&quot;&gt;&lt;/ref&gt; &lt;bean class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ben&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;jilin&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot; value=&quot;1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;b&quot; value-ref=&quot;personBean&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;c&quot;&gt; &lt;bean class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ben&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;jilin&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;pros&quot;&gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;personBean&quot; class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;alisa&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;beijing&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring注解的配置注解是为Spring容器提供Bean定义的信息，把XML定义的信息通过类注解描述出来。Spring他容器三大要素：Bean定义，Bean实现类和Spring框架。采用XML配置，Bean定义和Bean实现类本身分离，而采用注解配置，Bean定义在Bean实现类上注解就可以实现。 几种注解的方式： @Component @Autowired Configuration——表示核心配置文件 注解的例子见下一节 Spring自动扫描与自动装配在spring下新建包services dao common在dao下新建CustomerDAO.java, services下新建CustomerService.java common下新建App.java 编辑这几个文件CustomerDAO.java1234567891011package com.alisa.spring.dao;import org.springframework.stereotype.Component;@Componentpublic class CustomerDAO &#123; @Override public String toString()&#123; return "hello this is a dao"; &#125;&#125; CustomerService.java123456789101112131415161718192021222324package com.alisa.spring.services;import com.alisa.spring.dao.CustomerDAO;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CustomerService &#123; @Autowired CustomerDAO customerDAO;// public CustomerDAO getCustomerDAO() &#123;// return customerDAO;// &#125;//// public void setCustomerDAO(CustomerDAO customerDAO) &#123;// this.customerDAO = customerDAO;// &#125; @Override public String toString() &#123; return "CustomerService [customerDAO="+customerDAO+"]"; &#125;&#125; App.java12345678910111213package com.alisa.spring.common;import com.alisa.spring.services.CustomerService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("SpringCustomer.xml"); CustomerService customerService = (CustomerService) context.getBean("customerService"); System.out.println(customerService); &#125;&#125; 新建配置文件SpringCustomer.xmlbase-package表示组件的存放位置，扫描对应文件夹下的bean(用@Component注释过的)，将这些bean注册到容器中1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--&lt;bean id="customerService" class="com.alisa.spring.services.CustomerService"&gt;--&gt; &lt;!--&lt;property name="customerDAO" ref="customerDAO"&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id="customerDAO" class="com.alisa.spring.dao.CustomerDAO"&gt;&lt;/bean&gt;--&gt; &lt;context:component-scan base-package="com.alisa.spring"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; @Component表示这个class文件是一个自动扫描组件默认情况下，Spring将把组件class的第一个字母变成小写，来作为自动扫描组件的名称 也可以像下面这样，创建自定义的组件名称123@Service("AAA")public class CustomerService... 需要添加下面的代码1import org.springframework.stereotype.Service; 调用自己定义的组件1CustomerService customerService = (CustomerService) context.getBean("AAA"); 自动扫描组件的注释类型 @Component——自动扫描 @Repository——持久化层的DAO @Service——业务逻辑层的Service @Controller——表示层的Controller 后面三种只是加强代码可读性 可以将上面的例子改成1234567@Repositorypublic class CustomerDAO &#123; @Override public String toString()&#123; return "hello this is a dao"; &#125;&#125; 123456789101112131415161718@Servicepublic class CustomerService &#123; @Autowired CustomerDAO customerDAO;// public CustomerDAO getCustomerDAO() &#123;// return customerDAO;// &#125;//// public void setCustomerDAO(CustomerDAO customerDAO) &#123;// this.customerDAO = customerDAO;// &#125; @Override public String toString() &#123; return "CustomerService [customerDAO="+customerDAO+"]"; &#125;&#125; 自动扫面中过滤组件 include只需要匹配定义的“regex”命名规则，Class前就不用注释 只需要新建配置文件SpringFiltering.xml即可,只要包含Service和DAO的就会被注册到Spring容器12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.alisa.spring"&gt; &lt;context:include-filter type="regex" expression="com.alisa.spring.dao.*DAO.*"&gt;&lt;/context:include-filter&gt; &lt;context:include-filter type="regex" expression="com.alisa.spring.services.*Service.*"&gt;&lt;/context:include-filter&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; exclude规定组件避免被Spring发现并注册到容器中 自动装配Bean将一个Bean注入到其他的Bean的Property中。Spring支持5种自动装配模式 no——通过ref手动设定 byName——如果一个Bean的name和另一个Bean的property的name相同，自动装配 byType——如果一个bean的数据类型，兼容另一个bean种的property的数据类型，自动装配 constructor——根据构造函数参数的数据类型进行byType模式的自动装配 autodetect——如果发现默认的构造函数，用constructor模式，否则用byType Spring AOP-AdviceSpring AOP专门用于处理系统种分布于各个模块种交叉关注点的问题，拦截一些处理过程。支持4种类型的通知(Advice): 执行前通知 返回一个结果后通知 抛出异常后通知 环绕通知 首先新建几个文件在包spring下新建aop.advice包，在下面新建CustomerService.java和App.java新建配置文件SpringAOPAdvice.xml编辑12345678910111213141516171819202122232425package com.alisa.spring.aop.advice;public class CustomerService &#123; private String name; private String url; public void setName(String name)&#123; this.name = name; &#125; public void setUrl(String url)&#123; this.url = url; &#125; public void printName()&#123; System.out.println("customer name:"+this.name); &#125; public void printUrl()&#123; System.out.println("customer website:"+this.url); &#125; public void printThrowException()&#123; throw new IllegalArgumentException(); &#125;&#125; 12345678910111213141516171819package com.alisa.spring.aop.advice;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("SpringAOPAdvice.xml"); CustomerService customerService = (CustomerService) context.getBean("customerService"); customerService.printName(); customerService.printUrl(); try&#123; customerService.printThrowException(); &#125;catch (Exception e) &#123; &#125; &#125;&#125; 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="customerService" class="com.alisa.spring.aop.advice.CustomerService"&gt; &lt;property name="name" value="alisa"&gt;&lt;/property&gt; &lt;property name="url" value="http://"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 新建文件HijackBeforeMethod123456789101112package com.alisa.spring.aop.advice;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class HijackBeforeMethod implements MethodBeforeAdvice &#123; public void before(Method arg0, Object[] args, Object target) throws Throwable &#123; System.out.println("hijackBeforeMethod"); &#125;&#125; 在配置文件种加入新的bean配置HijackBeforeMethod，然后创建一个新的代理，命名为customerServiceProxytarget定义你想劫持哪个bean;interceptNames定义想用哪个class劫持target]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础语法]]></title>
    <url>%2F2018%2F08%2F11%2Fjava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java语法的积累java和scala的不同：Java继承与Java多态 利用文本编辑java程序新建HelloWorld.java文件输入一下内容12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 进入文件所在目录执行javac HelloWorld.java,文件夹下就会多一个HelloWorld.class文件，执行java HelloWorld输出代码结果 java语言基础常量表示12final double PI = 3.14final char A = 'a'; 常量可以首先声明，然后赋值，但是只能赋值一次 java运算符位运算符 &amp;按位与 |按位或 ^按位异或 ~按位补 &lt;&lt;按位左移 &gt;&gt;按位右移 &gt;&gt;&gt;按位右移补零 逻辑运算符 &amp;&amp; || ! ^异或，不同为1 java数组数组的定义和初始化声明数组123int ages[];char sys[];String [] name; 分配空间12int [] ages = &#123;12,14,35&#125;;char [] sym = new char[10]; 可以把一个数组赋值给另一个数组,实际上a1和a2指向了内存中同一个地址，修改其中一个数组，另一个也改变12int [] a1 = &#123;1,2,3&#125;;int [] a2 = a1; 12345int [] ages = &#123;1,23,4&#125;;for(int i = 0 ;i &lt; ages.length;i++)&#123; System.out.println("数组中第"+(i+1)+"个元素是"+ages[i]);&#125; 二维数组1String [][] name = &#123;&#123;"zhao","fdaf"&#125;,&#123;"va","fa"&#125;&#125;; java方法123访问修饰符 返回值类型 方法名(参数列表)&#123; 方法体&#125; 访问修饰符：代表方法允许被访问的权限范围，public protected private一个java方法的小例子12345678910public class PrintScore&#123; public static void main(String[] args)&#123; PrintScore a = new PrintScore(); int rSum; rSum = a.calcSum(2,3); &#125; public int calcSum(int a,int b)&#123; return a+b; &#125;&#125; 方法重载，在Java中通过类中写多个方法，这类方法的方法名相同，参数列表不同（参数个数和参数类型不同）来实现重载 Java类与对象一个类可以包含一下类型变量： 局部变量，在方法中定义的变量 成员变量，定义在类中，方法体之外的变量，在创建对象的时候实例化 类变量， 也叫静态变量，类声明也在类中，方法体之外，但必须声明为static类型 构造方法每个类都有构造方法。如果没有显式地为类构造方法，Java编译器会构建默认构造方法，可以又多个构造方法语法格式为：123public 构造方法名()&#123;&#125; 例子:12345678public class People&#123; double height; int age; public People(double h,int a)&#123; height = h; age = a; &#125;&#125; 123People tt = new People(13,134);tt.height = 12;tt.age = 34; java继承继承可以看作是类与类之间的衍生关系，父类更通用，子类更具体 1class 子类 extends 父类 继承的例子：先创建一个父类Animal123456public class Animal&#123; public int legNum; public void bark()&#123; System.out.println("animal"); &#125;&#125; 再创建一个子类(习惯手写继承)：123public class Dog extends Animal&#123;&#125; 创建一个Test类，作为程序入口1234567public class Test&#123; public static void main(String[] args)&#123; Dog s = new Dog(); a.legNum = 4; a.bark(); &#125;&#125; 继承的特点 子类拥有父类除了private以外的所有属性和方法 子类可以拥有自己的属性和方法 子类可以重写实现父类的方法 Java中的继承是单继承，一个类只有一个父类（这里和scala有所区别） Java实现多继承的一个办法是implements接口 子类方法重写接着上面的例子，修改Dog类,重新运行测试12345public class Dog extends Animal&#123; public void bark()&#123; System.out.println(&quot;bark...&quot;); &#125;&#125; 继承的初始化顺序系统先创建父类对象，再创建子类对象，先初始化属性，再调用构造函数 小知识final关键字可以修饰类、方法、属性和变量 final修饰类，则该类不允许被继承，为最终类 final修饰方法，则方法不允许被重写 final修饰属性，则该类的属性不会进行隐式的初始化或在构造方法中赋值 final修饰变量，则该变量的赋值只有一次 super关键字在子类内部使用，代表父类对象 访问父类的属性super.属性名 访问父类的方法super.bark() 子类构造方法需要调用父类的构造方法时，在子类的构造方法里最前面的位置：super() java多态多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定，是指在执行期间判断所引用对象的实际类型，根据实际类型调用相应的方法 向上转型下面这段代码接着上一节1Animal b = new Dog(); 由于Dog继承于Animal，所以Dog可以自动向上转型为Animal，所以b是可以指向Dog实例对象的 不能使用一个子类的引用去指向父类的对象Dog a = new Animal()是错的 如果定义了一个指向子类对象的父类引用类型，除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能（子类中重写的方法会覆盖父类的方法），但是对于只存在于子类的方法和属性就不能获取 多态的实现方式###多态的实现条件：继承、重写和向上转型 多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现 ###抽象方法声明语法1abstract void f(); 包含抽象方法的类叫做抽象类，抽象类在定义类时，会加上abstract关键字 使用抽象类的情况 某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法，父类只关注约束子类要实现的方法，而不关注方法如何实现 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，避免子类设计的随意性 抽象类可以没有抽象方法 抽象类的对象不能直接创建，通常是定义引用变量指向子类对象 一个实现抽象类的例子:1234public abstract class TelePhone&#123; public abstract void call(); public abstract void message();&#125; ###接口实现abstract关键字允许在类中创建一个或多个没有任何定义的方法，而interface使抽象的概念更向前迈进了一步，会产生一个完全抽象类，根本没有提供任何方法体 12345interface Animal&#123; int y = 5; public void eat(); public void travel();&#125; 接口不能用于实例化对象 接口中所有的方法是抽象方法 接口成员是static final类型 接口支持多继承 多继承的实现方式：123456修饰符 interface A extends 接口1，接口2&#123;&#125;修饰符 class A implements 接口1，接口2&#123;&#125; 一个实现多态的例子“1234public interface Animal&#123; public void bark(); public void travel();&#125; 123public interface Dog&#123; public void eat();&#125; 1234567891011public class Cat implements Animal,Dog&#123; public void bark()&#123; &#125;; public void travel()&#123; &#125;; public void eat()&#123; &#125;;&#125; Cat类必须对接口中的抽象方法重写]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令笔记]]></title>
    <url>%2F2018%2F08%2F11%2Flinux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日积月累linux命令 需要学会的快捷键 ctrl+d键盘输入结束或者退出终端 ctrl+s暂停当前程序后按下任意键恢复运行 ctrl+z当前程序放到后台运行，回复到前台是fg ctrl+a光标移至行头 ctrl+e光标移至行末 ctrl+k删除光标所在位置到行末 alt+backspace向前删除一个单词 通配符? *12touch asd.txt qaz.txtls *.txt 1touch love_&#123;1..10&#125;_file.txt Linux用户管理查看当前用户属性1who am i 创建用户利用sudo命令创建用户需要root权限，需要知道当前登录用户的密码，且当前用户必须在sudo用户组1sudo adduser lilei 创建用户的同时创建lilei文件夹,切换登录用户，输入密码1su -l lilei 用户注销exit 查看用户组输入下面命令可以看到用户属于的用户组1groups shiyanlou 查看etc/group文件1cat /etc/group | sort 可以使用命令过滤掉一些不想看到的结果1cat /etc/group | grep -E &quot;shiyanlou&quot; 将其他用户加入sudo用户组先切换到要加入sudo用户组的用户12su -l lileisudo ls 使用usermod命令可以为用户添加用户组1234su shiyanlougroups lileisudo usermod -G sudo lileigroups lilei 删除用户1sudo deluser lilei --remove-home Linux 文件基本属性1234[root@www /]# ls -ltotal 64dr-xr-xr-x 2 root root 4096 Dec 14 2012 bindr-xr-xr-x 4 root root 4096 Apr 19 2012 boot 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 Linux 文件与目录管理 ls: 列出目录 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) cd：切换目录 [root@www ~]# cd /root/runoob/ [root@www runoob]# cd ~回到家目录 [root@www runoob]# cd ..回到上一级目录 pwd：显示目前的目录 mkdir：创建一个新的目录 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～[root@www tmp]# mkdir -m 711 test2 -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！[root@www tmp]# mkdir -p test1/test2/test3/test4 rmdir：删除一个空的目录rmdir [-p] 目录名称 -p ：连同上一级『空的』目录也一起删除 [root@www tmp]# rmdir runoob/ cp: 复制文件或目录 rm: 移除文件或目录 tmp]# rm -i bashrc1rm: remove regular file `bashrc&apos;? y 变更文件所有者现在有两个用户shiyanlou 和lilei,当前用户为shiyanlou,切换到lilei用户创建文件,查看文件所属用户123su -l lilei touch iphone6ll iphone6 切换到shiyanlou用户，更改文件所有者，查看文件所有者123su shiyanlousudo chown shiyanlou iphone6ll iphone6 修改文件权限1chmod 600 iphone6 Linux文件基本操作Linux 文件内容查看 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 新建文件123touch testmkdir mydirmkdir father/son/grandson 复制文件复制test文件到后面目录复制文件夹需要加上-r参数，将子目录一同复制12cp test father/son/grandsoncp -r father family 删除文件 直接删除 1rm test 删除只读文件会有提示 1234touch testchmod 444 testll testrm test 若不想有提示1rm -f test 删除目录1rm -r family 移动文件与文件重命名123mkdir Doctouch filemv file doc 重命名1mv file1 myfile 编辑文件1vimtutor Linux 磁盘管理 df：列出文件系统的整体磁盘使用量 123456[root@www ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/hdc2 9.5G 3.7G 5.4G 41% //dev/hdc3 4.8G 139M 4.4G 4% /home/dev/hdc1 99M 11M 83M 12% /boottmpfs 363M 0 363M 0% /dev/shm du：检查磁盘空间使用量 fdisk：用于磁盘分区]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自从学了计算机，我得了一种“怪病”]]></title>
    <url>%2F2018%2F08%2F11%2F%E8%87%AA%E4%BB%8E%E5%AD%A6%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E6%88%91%E5%BE%97%E4%BA%86%E4%B8%80%E7%A7%8D%E2%80%9C%E6%80%AA%E7%97%85%E2%80%9D%2F</url>
    <content type="text"><![CDATA[标题党说的就是我，没跑了我只是在疗伤^&amp;^ 自从学了计算机，我慢慢发现我忘记了怎样享受闲暇的时光。每当放下所有的事，不去想还没有完成的代码、还没有学习的分布式、还没看懂的强化学习，除非让其他事情充实时间，否则我就会“生病”。反而在不断的学习中，体会进步的乐趣，享受高亮的代码所带给我的欢愉。 我的生活是由许多的已完成事项和待办事项组成，仿佛只有这样我才能正常运转，即使是我的课余爱好，都被安排进我的列表里，我渴望挣脱 在许多人的眼里，我是个学霸，勤勤奋奋，也拿着傲人的成绩，在自己的心中，有着不知多久才能填满的欲望鸿沟，这欲望不是拥有多少只mac、ysl，这欲望不是打卡多少次演唱会，这欲望不是去多少个城市几个大洲旅行而是能够凭借自己的努力过上温馨的小日子 小学五年级的时候神州五号飞船成功发射，那时候我的梦想是当一名宇航员，长大后我的梦想不见了 只剩下了愿望 我不知道我要多努力，要努力多久才能满足我的简单又不简单的小愿望 我是一个简单的存在，我知道自己喜欢什么，厌恶什么 我是一个独立的存在，不依靠任何人，内心强大又软弱 我是一个孤独的存在，不孤单 我喜欢窝在屋子里看书，没有人打扰，如果他可以陪着我一起看书，那再好不过，哪怕只有几十平米的出租屋 我喜欢骑车，我觉得那时的我是自由的，是和自然合二为一的，体会耳边的风声，还有不自觉的微笑，哪怕爬坡会累，屁股会痛，骑车会有风险 我喜欢跑步，尤其喜欢设定跑步的目标，我小妹说我活得规规矩矩，我不知道那是怎样的一种感觉，可能享受流汗的感觉 我喜欢画画，但是我很少画画，我的大部分时间都贡献给了增长知识和技能，小时候画画是一种乐趣，却不得要领，现在画画是一种奢望，时间是一种奢侈品，但我想，如果可以我可能是个不错的画师，毕竟我可以坐几个小时不动 我喜欢看科幻魔幻电影和情节发展明显的英剧和美剧，我没有对演员、导演、作者有特别的偏好，只单纯看作品，并喜欢它们所带给我的思考 我喜欢乒乓球，但是我很菜，嗯，基本上每次都会这样说，与乒乓球印象最深的三个场景，第一幕是高中带我乒乓球入门的几个哥们，我的坏底子估计有他们的原因，那可能是个可爱的春天，在老三中露天的操场上有几台孤零零的乒乓球台，我们几个在那里并不正儿八经的打球；第二幕是大一参加师生乒乓球赛，女双，接到了一个难度超大的球，以迷之弧度打到了对方的案边；第三幕是大三的最后一堂乒乓球课上，交叉比赛，最后一组和班上乒乓球打的最好的女生交手，比分不记得了反正我输了，结束后她对我说：你应该参加学校的乒乓球赛。我想可能是因为它们给了我鼓励和信心 我喜欢代码，准确的说是喜欢我能看得懂的代码，每次学习新的代码就会莫名的兴奋，就像我自己的博客，无脑搭建，但是仍然很兴奋，很容易带给我成就感，但是最近看强化学习看的非常难受，我喜欢按照自己的节奏去学习，不喜欢被push得太紧，实际上可能就是我的性子太急了 实际上，我的大部分时间都贡献给了看得懂的看不懂的代码，因为这是我以后赖以生存的基础 我想这也可能算作是物质的一种，为了满足起码的需求，每当我停下来就会有一种危机感，电脑和手机在我的生活中占据了越来越大的比重，每天都提醒自己，不要让它们占据我的睡眠，每天坚持10点到11点半之间睡觉，而且我的睡眠一直不错，这是一件让我感到幸福的事情，即使是假期早晨也会在七点半到八点半之间自然醒，可能在别人看来这是勤奋使然，我发现，自然醒的早起让我有种莫名的开心，可能这是我的身体给我的反馈，就像跑步一样 放假在家的这段时间，每天都很充实，学习、画画、看书、跑步，码代码、看电影，可以说是很幸福了，然而我却希望有一种技能，可以让我防空自我、停止思考、享受闲暇的静谧时光 每当生病的时候，要么有肩膀可以靠一靠，要么写一些无厘头的字 第二天我的病就痊愈了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-696-788]]></title>
    <url>%2F2018%2F08%2F11%2Fleetcode-string-easy-696-788%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是696,788 题目：696. Count Binary Substrings描述：Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.例子：1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 代码：12345678910111213141516171819202122232425262728int Solution696::countBinarySubstrings(string s)&#123; int num = 0; vector&lt;int&gt; group; int index = 0; for (int i = 1; i &lt; s.size(); ++i) &#123; if (s[i] != s[i - 1] &amp;&amp; i != s.size() - 1) &#123; group.push_back(i - index); index = i; &#125; else if (s[i] != s[i - 1] &amp;&amp; i == s.size() - 1)//i和index不在同一个片段 &#123; group.push_back(i - index);//先把i前面的片段长度加入 group.push_back(1);//再将i所在的片段加入 &#125; else if (i == s.size() - 1)//i和index在同一个片段 &#123; group.push_back(i - index + 1); &#125; &#125; for (int i = 1; i &lt; group.size(); ++i) &#123; num += min(group[i], group[i - 1]); &#125; return num;&#125; 解题边界条件： 最后一个元素与前一个元素相同 最后一个元素与前一个元素不同 题目：788. Rotated Digits描述：X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good?例子：12345Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool Solution788::isDiff(int x)&#123; int flag = 0; while (x &gt; 0) &#123; int v = x % 10; if(v == 0 || v == 1 || v == 8)&#123;&#125; else if (flag == 0 &amp;&amp; v == 2 || v == 5 || v == 6 || v == 9)flag = 1; else if(v == 3 || v == 4 || v == 7) return false; x = x / 10; &#125; return flag;&#125;int Solution788::rotatedDigits(int N)&#123; //int num = 0; //int flag; //int invalid;//0-valid 1--invalid //for (int i = 1; i &lt;= N; ++i) //&#123; // flag = 0; // invalid = 0; // string int_string = to_string(i); // for (int j = 0; j &lt; int_string.size(); ++j) // &#123; // if (flag == 0 &amp;&amp; int_string[j] == '2' || int_string[j] == '5' || int_string[j] == '6' || int_string[j] == '9') // &#123; // flag = 1; // &#125; // if (int_string[j] == '3' || int_string[j] == '4' || int_string[j] == '7') // &#123; // invalid = 1;//表示有3，4，7 // break; // &#125; // &#125; // if (!invalid &amp;&amp; flag)++num; //&#125; //return num; int num = 0; while (N &gt; 0) &#123; if (isDiff(N))++num; --N; &#125; return num;&#125; 数字比较比字符串比较速度快 将数字转换成字符串的内置函数to_string() 不要忘记invalid digit比较 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next主题博客网站优化]]></title>
    <url>%2F2018%2F08%2F11%2Fhexo-next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最开心的事情莫过于每天早晨起来看一眼我的博客网站了然而我等它等的不耐烦，尤其手机端，更加不能忍 hexo-next主题网站加载慢原因1：加载Google字体慢 解决方法：找到\themes\next\layout_partials\head\external-fonts.swig文件，将fonts.googleapis.com 改成 fonts.useso.com]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清平乐·清枫唱晚]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%B8%85%E5%B9%B3%E4%B9%90%C2%B7%E6%B8%85%E6%9E%AB%E5%94%B1%E6%99%9A%2F</url>
    <content type="text"><![CDATA[今晚读宋词，读着读着就忍不住了，不知道为啥，每次诗词意境的主体都是男性23333 清平乐— 清枫唱晚，小楼把酒酣。满城灯火无人唤，夜夜埙声散。 梦里佳人独倚，惊觉落叶凄凄。恁知平生情意，残阳夜盼归期。 分享下今晚让我手痒痒的词 清平乐(王安国)— 留春不住，费尽莺儿语。满地残红宫锦污，昨夜南园风雨。 小怜初上琵琶，晓来思绕天涯。不肯画堂朱户，春风自在杨花。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宋词分享]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AE%8B%E8%AF%8D%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[分享几首昨天看到的喜欢的宋词 苏幕遮(范仲淹)— 碧云天，黄叶地。秋色连波，波上寒烟翠。山映斜阳天接水，芳草无情，更在斜阳外。黯乡魂，追旅思。夜夜除非，好梦留人睡。明月高楼休独倚，酒入愁肠，化作相思泪。 清平乐(晏殊)— 红笺小字，说尽平生意，鸿雁在云鱼在水，惆怅此情难寄。斜阳独倚西楼，遥山恰对帘钩。人面不知何处，绿波依旧东流。 蝶恋花(欧阳修)— 庭院深深深几许？杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F10%2Fleetcode-string-easy-4-1%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是521,824,20,520附stack string容器用法总结 总结收获 stack用法：empty() pop() push() size() top() string用法：append() insert() substr() append连接 123456basic_string &amp;append( const basic_string &amp;str );//在字符串的末尾添加str,basic_string &amp;append( const char *str );basic_string &amp;append( const basic_string &amp;str, size_type index, size_type len );//在字符串的末尾添加str的子串,子串以index索引开始，长度为lenbasic_string &amp;append( const char *str, size_type num );//在字符串的末尾添加str中的num个字符basic_string &amp;append( size_type num, char ch );//在字符串的末尾添加num个字符chbasic_string &amp;append( input_iterator start, input_iterator end );//在字符串的末尾添加以迭代器start和end表示的字符序列 insert插入 12345678iterator insert( iterator i, const char &amp;ch );basic_string &amp;insert( size_type index, const basic_string &amp;str );basic_string &amp;insert( size_type index, const char *str );basic_string &amp;insert( size_type index1, const basic_string &amp;str, size_type index2, size_type num );basic_string &amp;insert( size_type index, const char *str, size_type num );basic_string &amp;insert( size_type index, size_type num, char ch );void insert( iterator i, size_type num, const char &amp;ch );void insert( iterator i, iterator start, iterator end ); substr 1basic_string substr( size_type index, size_type num = npos );//substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串。 assign赋值 12345basic_string &amp;assign( const basic_string &amp;str );basic_string &amp;assign( const char *str );basic_string &amp;assign( const char *str, size_type num );basic_string &amp;assign( const basic_string &amp;str, size_type index, size_type len );basic_string &amp;assign( size_type num, char ch ); compare小于零 this &lt; str 1234567int compare( const basic_string &amp;str );//比较自己和strint compare( const char *str );int compare( size_type index, size_type length, const basic_string &amp;str );//比较自己的子串和str,子串以index索引开始，长度为lengthint compare( size_type index, size_type length, const basic_string &amp;str, size_type index2,size_type length2 );//比较自己的子串和str的子串，其中index2和length2引用str，index和length引用自己int compare( size_type index, size_type length, const char *str, size_type length2 );//比较自己的子串和str的子串，其中str的子串以索引0开始，长度为length2，自己的子串以index开始，长度为length copy 1size_type copy( char *str, size_type num, size_type index );//拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数 erase 123iterator erase( iterator pos );iterator erase( iterator start, iterator end );basic_string &amp;erase( size_type index = 0, size_type num = npos ); find 1234size_type find( const basic_string &amp;str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找）size_type find( const char *str, size_type index );size_type find( const char *str, size_type index, size_type length );size_type find( char ch, size_type index ); at begin end empty用法同vector容器 题目：521. Longest Uncommon Subsequence I描述：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.例子：12345Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. 代码：1234567int Solution521::findLUSlength(string a, string b)&#123; if (a == b)return -1; else if (a.size() == b.size())return a.size(); else return max(a.size(), b.size());&#125; 思路： 如果两个字符串相等不可能有不相同子序列 如果两个字符串不相等，但是长度相同，则最长的不同子序列就是二者任意一个 上述条件都不符合，则最长的字符串就是最长的不同子序列 题目：824. Goat Latin描述：A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. 例子：12Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot; 代码： 12345678910111213141516171819202122232425262728string Solution824::toGoatLatin(string S)&#123; int j = 0;//当前词开始下标 int k = 1;//记录第k个word unordered_set&lt;char&gt; vowel = &#123; 'a','e','i','o','u','A','E','I','O','U' &#125;; string t; for (int i = 0; i &lt; S.size(); ++i) &#123; if (S[i + 1] == ' ') &#123; if (vowel.find(S[j]) != vowel.end())//是元音 &#123; t.append(S.substr(j, i - j + 1)); &#125; else &#123; t.append(S.substr(j + 1, i - j)); t.append(S.substr(j, 1)); &#125; t.append("ma"); for (int a = 0; a &lt; k; a++)t.append("a"); t.append(" "); j = i + 2; ++k; &#125; &#125; return t;&#125; 收获： string::append() string::substr 题目：20. Valid Parentheses描述：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid.例子：1234Input: &quot;()&quot;Output: trueInput: &quot;([)]&quot;Output: false 代码： 123456789101112131415bool Solution20::isValid(string s)&#123; stack&lt;char&gt; t; for (char c : s) &#123; if (c == '(' || c == '[' || c == '&#123;') t.push(c); else &#123; if (t.empty() || (c == ')' &amp;&amp; t.top() != '(') || (c == ']' &amp;&amp; t.top() != '[') || (c == '&#125;' &amp;&amp; t.top() != '&#123;'))return false; else t.pop(); &#125; &#125; return t.empty();&#125; 收获： stack::push() stack::pop() stack::top() 多重判断条件时将特殊边界条件放在首位，比如t.empty() 题目：520. Detect Capital描述：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way.例子：12Input: &quot;FlaG&quot;Output: False 代码：1234567891011121314151617181920212223242526272829bool Solution520::detectCapitalUse(string word)&#123; //way 1 //int k = 0;//0--首字母大写 1--首字母小写 //int flag = 0;//0--首字母之外都是小写，1--首字母之外都是大写 //int len = word.size(); //for (int i = 0; i &lt; len; ++i) //&#123; // if (word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a' &amp;&amp; i == 0)k = 1; // else if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A' &amp;&amp; k == 1)return false;//首字母小写，中间出现了大写字母 // if (i == 1 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')flag = 1; // if (k == 0 &amp;&amp; i &gt; 1)//首字母大写 // &#123; // if ((flag == 1 &amp;&amp; word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a') || (flag == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A'))return false; // &#125; //&#125; //return true; //way 2 bool firstCapital = false;//首字母小写 int capital = 0;//大写字母个数 for (int i = 0; i &lt; word.size(); ++i) &#123; if (i == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')firstCapital = true; if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')++capital; if (capital &lt; i + 1 &amp;&amp; capital &gt;= 2)return false;//大写字母数目大于等于两个，却小于当前遍历过的字母 &#125; return (capital == 0 || (firstCapital &amp;&amp; capital == 1) || capital == word.size());&#125; 第二种方法的runtime优于第一种方法 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我还不会的markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%88%91%E8%BF%98%E4%B8%8D%E4%BC%9A%E7%9A%84markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[做个总结，少百度 文字加粗1**Cmd Markdown**是我们给出的答案 Cmd Markdown是我们给出的答案 引用12&gt; * 整理知识，学习笔记&gt; * 发布日记，杂文，所见所想 整理知识，学习笔记 发布日记，杂文，所见所想 图片1![图片](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533796313368&amp;di=60846b8d67a743b9d0ee45963a64f2db&amp;imgtype=0&amp;src=http%3A%2F%2Fc.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2Ff9198618367adab4b025268587d4b31c8601e47b.jpg) 链接1[AlisaBen](https://alisaben.github.io) AlisaBen 段落内嵌入代码1`print()` print() 分割线1------ 待办事项1234- [ ] 强化学习- [ ] 读书- [x] 完善博客网站- [x] 画画 强化学习 读书 完善博客网站 画画 代码高亮1var a:Int = 1 删除线1~~删除~~ 删除 表格12345| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \$1600 | 5 || 手机 | \$12 | 12 || 管线 | \$1 | 234 | 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F09%2Fleetcode-string-easy-4%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是344，557，657，804 总结收获 unordered_map,unordered_set,map和set的区别：unordered_map存储机制是哈希表，即unordered_map内部元素是无序的。map是红黑树，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。unordered_set基于哈希表，是无序的。set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。 在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。（外部引用者更为合适） set容器的insert操作不需要提前判定元素存在，如下图： vector和string容器实现了swap方法，内置swap进行了优化，优于自己写的简单交换 暂时不明白string s = &quot;&quot;;和string s;的区别，希望大佬可以指点 题目：344. Reverse String描述：Write a function that takes a string as input and returns the string reversed.例子：12Input: &quot;hello&quot;Output: &quot;olleh&quot; 代码：12345678910string Solution344::reverseString(string s)&#123; int len = s.size(); if (len &lt; 2)return s; for (int i = 0; i &lt; len / 2; i++) &#123; swap(s[i], s[len - i - 1]); &#125; return s;&#125; swap优于自己写的交换 题目:557. Reverse Words in a String III描述：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.例子：12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 代码：1234567891011121314151617181920string Solution557::reverseWords(string s)&#123; int len = s.size(); int j = 0; for (int i = 0; i &lt; len; i++) &#123; if (i + 1 == len || s[i + 1] == ' ') &#123; int n = i - j + 1; int x = j; while (j &lt;= x + n /2 - 1) &#123; swap(s[j], s[i +x - j]); ++j; &#125; j = i + 2; &#125; &#125; return s;&#125; 在这道题中踩过的坑： 边界条件:i指向最后一个元素的情况 while循环中j不断变化，循环边界需要不变边界 swap交换时元素的下标计算 题目：657. Judge Route Circle描述：Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.例子：1234Input: &quot;UD&quot;Output: trueInput: &quot;LL&quot;Output: false 代码：12345678910111213141516bool Solution657::judgeCircle(string moves)&#123; vector&lt;int&gt; m(4);//L,R,U,D for (auto &amp;c : moves) &#123; if (c == 'L')m[0]++; else if (c == 'R')m[1]++; else if (c == 'U')m[2]++; else m[3]++; &#125; return (m[0] == m[1] &amp;&amp; m[2] == m[3]); //unordered_map&lt;char, int&gt;com; //for (auto &amp;c : moves)com[c]++; //return com['L'] == com['R'] &amp;&amp; com['U'] == com['D'];&#125; 尝试了一下注释掉的方法二runtime很差劲，可能是因为查找比较费时间 题目：804. Unique Morse Code Words描述：International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.For convenience, the full table for the 26 letters of the English alphabet is given below:1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 例子：1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 代码：12345678910111213141516171819202122232425262728293031int Solution804::uniqueMorseRepresentations(vector&lt;string&gt;&amp; words)&#123; //int len = words.size(); //if (len &lt; 2)return len; //vector&lt;string&gt; map = &#123; ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.." &#125;; //set&lt;string&gt; compare; //for (string s : words) //&#123; // string temp = ""; // for (char c : s) // &#123; // temp += map[c - 'a']; // &#125; // //if (compare.find(temp) == compare.end()) // compare.insert(temp); //&#125; //return compare.size(); unordered_set&lt;string&gt; compare; for (string &amp;s : words) &#123; string temp; for (char &amp;c : s) &#123; temp += map[c - 'a']; &#125; //if (compare.find(temp) == compare.end()) compare.insert(temp); &#125; return compare.size();&#125; 注释掉的代码是我自己写的，下面的代码是看了runtime比较好的答案，经过对比多次提交比较得到一下几个猜想，有待验证： unordered_set优于set public定义compare优于函数内定义 compare前加上const关键字优于不加 for循环加上&amp;优于不加 set执行insert不需要提前判断集合中是否有该元素 temp不初始化不会报错，且优于初始化 结束更多内容请浏览我的csdn：小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩铅画2-向日葵]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%BD%A9%E9%93%85%E7%94%BB2-%E5%90%91%E6%97%A5%E8%91%B5%2F</url>
    <content type="text"><![CDATA[半年过去了，前段时间翻到了年初的朋友圈看下今年的flag：“2018no flag,多读书多看报，多点佛系情怀，多点珍惜，多点爱，还有就是培养一个新爱好”。这么简单的计划差点都被我搞砸，还有还有半年为期，那就爱好捡起来吧。 上次画画是几个月前看了几集《永恒的紫罗兰花园》，就画了里面邮递员的一个剪影；再上次是高考结束学习了半个月的素描，就是练习排线、投影、静物，画些苹果鸭梨啥的；再上次应该就是初中的时候，凭借一副人像拿了学校画展的二等奖，平时看课外书的时候画些书中的人物剪影。 从小我对色彩的掌握就比较弱，但是很有耐性，选择彩铅也没有什么特别的考究，只是彩铅的画法和素描很像，然后彩铅毁画不太容易，所以就开始了我的新爱好培养。 首先是先用自动铅笔构图，起始在构图的时候自己很小心，尽量不让比例失调，但是因为最初选定的落笔的地方选择了近景叶子而不是向日葵的根部，导致最后向日葵的底部比例有点失调，就把叶子全擦掉重新画的，所以定型原点很重要！还有一点就是在构图的时候有些高光明显的地方也画了边界，可以避免上色的时候不小心画错。 花瓣上色， 第一次尝试这种色调比较少的画，而且我的彩铅只有36色，担心自己的水平画不出来效果，所以一个花瓣一个花瓣开始画，没有采用大范围铺色调的方式，这也可能是我画得慢得原因吧。先用404打底，再铺一层407，留出高光得位置，再阴影得地方加深409，觉得色彩不够可以反复排线，开始排线得时候尽量轻，不然后面不好上色，在阴影比较重得地方适当加入487和478，有些黄得发红得地方加入414和416。 叶子上色，画花瓣得时候很累，画完花瓣差不多已经5个小时左右了，画叶子得时候才知道色彩对我得限制有多大，我的绿色色系只有5只，很难画出向日葵那种深绿得感觉，所以加了很多得480和499，先用463打底，浅涂，然后459加深，可以根据排线来自动调节每种颜色每个位置得深浅，这样能够显出立体得感觉，在阴影较重得地方用459和499、480反复图，绿里透着黑，黑里透着绿。 这是最后的图，不太满意的地方是花芯和近景的叶子，因为是对着图片临摹，没有近距离观察向日葵花芯的小花瓣的形状，不太会画这里，而且画到这里的时候我差不多已经坐着画了10个小时左右，有点累了画的比较随意，还有就是近景叶子我没有太看明白图片中的叶子是怎样分布的，根据阳光照射的向日葵的花瓣的高光分布没有推测出近景叶子是怎样达到花瓣的效果，所以感觉近景叶子的高光阴影有很大的问题，更多的内容请不吝指教~ 还有比较细节的地方是，在勾勒一些颜色交叉边缘阴影时根据阴影映射的颜色来压会比较自然，最后，这幅图用到的颜色：有些是画画中随性加的颜色，没有具体描述。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第18章 高级类型]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC18%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[18.1 单例类型 在下面的例子中book不能调用addChapter方法，因为setTitle方法返回的是this，Scala自动推断类型为Document。1234567891011121314151617class Document&#123; def setTitle(title:String) = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle(&quot;whatever&quot;).setAuthor(&quot;cay&quot;)class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle(&quot;scala&quot;) 修改方法如下：显式声明setTitle方法的返回类型是this.type 1234567891011121314151617class Document&#123; def setTitle(title:String):this.type = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle(&quot;whatever&quot;).setAuthor(&quot;cay&quot;)class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle(&quot;scala&quot;).addChapter(&quot;&quot;) 1234567object Title//单例对象class Document&#123; private var useNextArgAas:Any = null def set(obj:Title.type ):this.type = &#123;useNextArgAas = obj;this&#125; def to(arg:String) = if(useNextArgAas == Title) println(arg)&#125;book.set(Title).to(&quot;scala&quot;) 18.2 类型投影注意下一段代码中的NetWork#Member操作，说明在NetWork中共享Member类 12345678910111213141516class NetWork&#123; class Member(val name:String)&#123; val contacts = new ArrayBuffer[NetWork#Member] &#125; private val members = new ArrayBuffer[Member]() def join(name:String) = &#123; val m = new Member(name) members += m m &#125;&#125;val chatter:NetWork = new NetWorkval myFace:NetWork = new NetWorkval fred :chatter.Member= chatter.join(&quot;fred&quot;)val barney :myFace.Member= myFace.join(&quot;barney&quot;)fred.contacts += barney 18.4 类型别名类型别名必须出现在类或者对象中，不能出现在Scala文件的顶层123type Index = mutable.HashMap[String,(Int,Int)]val a :Index = new Index()a.put(&quot;a&quot;,(1,2)) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第17章-类型参数]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC17%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[17.1 泛型类 12345class Pair[T,S](val first:T,val second:S)&#123; def printf() = println(first,second)&#125;val p = new Pair(42,&quot;string&quot;)p.printf() 17.2 泛型函数12def getMiddle[T](a:Array[T]) = a.length / 2println(getMiddle(Array(4,&quot;56&quot;))) 17.3 类型变量界定12345class Pair[T &lt;: Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair(&quot;23&quot;,&quot;4&quot;)).smaller) 如果不在泛型中加入&lt;: Comparable[T]，则就不知道first是否有compareTo方法，所以添加一个上界T 《： Comparable[T] 但是在类型为Int的时候出现报错，在17.4节中介绍 12345class Pair[T](val first:T,val second:T)&#123; def printf() = println(first,second) def replaceFirst[R &gt;: T](newFirst:R) = new Pair[R](newFirst,second)&#125;(new Pair(&quot;23&quot;,&quot;4&quot;)).replaceFirst(0).printf() 17.4 视图界定在上一节中Int类型出现报错是因为Int不是Comparable[Int]的子类。不过RichInt实现了Comparable[Int],同时还有一个从Int到RichInt的隐式转换。解决方法是视图界定12345class Pair[T &lt;% Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair[Int](3,4)).smaller) &lt;%关系将T被隐式转换成Comparable[T] 用Ordered特质会更好，因为在Comparable的基础上提供了关系操作符1234class Pair[T &lt;% Ordered[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first &lt; second) first else second&#125; 17.5 上下文界定视图界定T &lt;% V要求必须存在一个从T到V的隐式转换。上下文界定的形式是T:M。要求必须存在一个类型为M[T]的隐式值，如1class Pair[T:Ordering] 要求必须存在一个类型为Ordering[T]的隐式值。当声明一个使用隐式值的方法时，需要添加一个隐式参数,比如ord 123class Pair[T:Ordering](val first:T,val second:T)&#123; def smaller(implicit ord:Ordering[T]) = if(ord.compare(first,second) &lt; 0) first else second&#125; 17.11 对象不能泛型不能给对象添加类型参数，比如可变列表 更多内容请见我的csdn:小可爱的博客]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-sort-easy-over]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-sort-easy-over%2F</url>
    <content type="text"><![CDATA[题目列表： 349 350 242 题目349：Intersection of Two Arrays描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order. 代码： 1234567891011121314vector&lt;int&gt; Solution349::intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; set&lt;int&gt;nums1_plus, nums2_plus; nums1_plus.insert(nums1.begin(), nums1.end());//因为集合是不区分元素位置的 nums2_plus.insert(nums2.begin(), nums2.end()); vector&lt;int&gt; res; int len1 = nums1_plus.size(); for (int x : nums1_plus) &#123; if (nums2_plus.find(x) != nums2_plus.end())res.push_back(x); &#125; return res;&#125; 题目350：Intersection of Two Arrays II描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.代码：123456789101112vector&lt;int&gt; Solution350::intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; unordered_map&lt;int, int&gt;nums1_plus, nums2_plus; for (int x : nums1)nums1_plus[x]++; for (int x : nums2)nums2_plus[x]++; vector&lt;int&gt; res; for (auto x : nums1_plus) &#123; if (nums2_plus.find(x.first) != nums2_plus.end())res.insert(res.end(), min(x.second, nums2_plus[x.first]), x.first); &#125; return res;&#125; 题目242： Valid Anagram描述：Given two strings s and t , write a function to determine if t is an anagram of s.例子： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false Note:You may assume the string contains only lowercase alphabets.代码：1234567891011121314151617181920212223242526272829bool Solution242::isAnagram(string s, string t)&#123; //way 1 //if (s.size() != t.size())return false; //unordered_map&lt;char, int&gt; s_plus, t_plus; //for (char x : s)s_plus[x]++; //for (char x : t)t_plus[x]++; //for (auto x : s_plus) //&#123; // if (t_plus.find(x.first) != t_plus.end()) // &#123; // if (x.second != t_plus[x.first]) return false; // &#125; // else // return false; //&#125; //return true; //way 2 if (s.size() != t.size()) return false; vector&lt;int&gt; flag(26);//将26个小写字母映射到对应数组下标，元素为每个字母出现的次数，初始值为0 for (char x : s) flag[x - &apos;a&apos;]++;//计算s字符串中每个字母出现的次数 for (char x : t) &#123; flag[x - &apos;a&apos;]--; if (flag[x - &apos;a&apos;] &lt; 0)return false;//如果两个字符串等长，且不是变换顺序的话，t中一定存在某个字母数大于s &#125; return true;&#125; 在题目242中，第二种方法的runtime优于第一种方法，在非变换顺序的字符串中可以在遍历结束之前结束。 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骗子]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%AA%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我是一个骗子戴着虚伪的面具月亮与我高歌清风为我吹嘘谈笑风生心底住着秘密黑夜降临我来到另一个世界忧伤浸染自说着寂寞的秋的清愁]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第16章 XML处理]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC16%E7%AB%A0-XML%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这是一篇《快学scala》的读书笔记，需要具备Scala语言的基础，欢迎读者与我一起探讨，或者教我新知识呀~ 16.1 XML字面量Scala对xml有内建支持，直接用xml代码就行1234import scala.xml.Elemimport scala.xml.NodeBufferval doc:Elem = &lt;html&gt;&lt;head&gt;&lt;title&gt;Fred&apos;s&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;val item:NodeBuffer = &lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;wilma&lt;/li&gt; 16.2 XML节点Node类是所有XML节点类型的祖先，两个最重要的子类是Text和Elem。用child方法遍历父节点下面的每一个子节点 123val ls:Elem = &lt;a herf=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child) println(x) 输出结果： 1234the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language 代码：123val ls:Elem = &lt;a herf=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child if !x.child.isEmpty) println(x.child) 输出结果：12ArrayBuffer(&lt;li&gt;hello&lt;/li&gt;, scala)ArrayBuffer(yoyo) 通过变成的方式构建节点序列，可以使用NodeBuffer,是ArrayBuffer[Node]的子类，可以被隐式转换为NodeSeq，转换之后就不能再继续修改它，因为xml节点序列是不可变的 12345import scala.xml.&#123;Node, NodeSeq&#125;val items = new NodeBufferitems += &lt;li&gt;Fred&lt;/li&gt;items += &lt;li&gt;Wilma&lt;/li&gt;val nodes:NodeSeq = items 16.3 元素属性要处理某个元素的属性键和值，可以使用attributes属性,返回Option类型的节点序列1234val ls:Elem = &lt;a href=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;val url: scala.Seq[Node] = ls.attributes(&quot;href&quot;)val url1:String= ls.attributes(&quot;href&quot;).textprintln(url1) 输出结果：www.baidu.com通过调用 text方法返回String类型结果,也可以通过下面的方法避免没有这个属性返回null的结果，如果没有返回空12val url2 = ls.attributes.get(&quot;alt&quot;).getOrElse(Text(&quot;&quot;)) println(url2) 遍历节点的所有属性：12345val elem1 = &lt;p class=&quot;nihao&quot; type=&quot;wawa&quot;&gt;&lt;/p&gt;for(attr &lt;- elem1.attributes) println(attr.key,attr.value.text)val map:Map[String,String] = elem1.attributes.asAttrMapprintln(map) 两种方式都可以遍历节点的所有属性，第一种方式的attr类型是MetaData，第二种方式返回的是键值对的map 16.4 内嵌表达式可以在xml字面量中包含Scala的代码块 123val items = List(2,3,5)val elem = &lt;ul&gt;&#123;for(i &lt;- items)yield &lt;li&gt;&#123;i&#125;&lt;/li&gt;&#125;&lt;/ul&gt;println(elem) 16.5 在属性中使用表达式可以用Scala表达式来计算属性值 123456val e = &lt;a id=&#123;new Atom[Int](1)&#125;&gt;&lt;/a&gt;println(e.attributes(&quot;id&quot;).text)val description = &quot;TOD&quot;val q = &lt;img alt=&#123;if(description == &quot;TODO&quot;) null else description&#125;&gt;yolo&lt;/img&gt;println(q.attributes.get(&quot;alt&quot;).getOrElse(Text(&quot;&quot;))) 16.8 模式匹配可以在模式匹配表达式中使用xml字面量 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println(&quot;img&quot;) case &lt;li&gt;&#123;v&#125;&lt;/li&gt; =&gt; println(v) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println(&quot;lala&quot;) case _ =&gt; println(&quot;&quot;)&#125;) 可以用下面的方式匹配文本12&lt;li&gt;&#123;Text(v)&#125;&lt;/li&gt; =&gt; v&lt;li&gt;v&lt;/li&gt; =&gt; v.text XML模式不能有属性，如果要匹配属性，需要用守卫 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li class=&quot;name&quot;&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println(&quot;img&quot;) case n @ &lt;li&gt;&#123;_&#125;&lt;/li&gt; if (n.attributes(&quot;class&quot;).text == &quot;name&quot;)=&gt; println(n) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println(&quot;lala&quot;) case _ =&gt; println(&quot;&quot;)&#125;) 16.9 修改元素和属性xml节点和节点序列是不可变的，如果要编辑一个节点，需要创建一个拷贝123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = &quot;ol&quot;)println(list2) 结果输出：FredWilma 新旧两个列表的后代是共享的，要添加一个后代，可以像下面这样调用copy123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = &quot;ol&quot;,child = list.child ++ &lt;li&gt;another&lt;/li&gt;)println(list2) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第15章 注解]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC15%E7%AB%A0-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[15.1 什么是注解 注解：插入到代码中以便有工具可以对他们进行处理的标签，工具可以在代码级别运作，也可以被编译器加入了注解信息的类文件 15.2 什么可以被注解可以为类、方法、字段、局部变量和参数添加注解12345@Entity class Credentials@Test def testSomeFeature()&#123;&#125;@BeanProperty var username = _def doSomething(@NotNull message:String)&#123;&#125;@BeanProperty @Id var username = _ 在给主构造器添加注解时，需要将注解放置在构造器之前，并加上一对圆括号 1class Credentials @Inject()&#123;var username:String,var password:String&#125; 可以为表达式添加注解，需要在表达式后加上冒号1(myMap.get(key):@unchecked) match &#123;...&#125; 还可以为类型参数添加注解：1class MyContainer[@specialized T] 针对实际类型的注解应放在类型名称之后1String @cps[Unit] 15.3 注解参数Java注解可以有带名参数，如果参数名是value，名称可以直接略去，如果注解不带参数，圆括号可以略去注解的参数类型只能是： 数值型的字面量 字符串 类字面量 Java枚举 其他注解 上述类型的数组 15.4 注解实现本节主要看下注解类是怎样实现的 注解必须扩展Annotation特质。 1class unchecked extends annotation.Annotation 注解的作用是描述那些被注解的表达式、变量、字段、方法或类型1def check(@NotNull password:String) = &#123;&#125; 好了，注解看到这里我放弃了，并看不懂……]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因吹斯听thing:我的博客网站]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9B%A0%E5%90%B9%E6%96%AF%E5%90%ACthing-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[之前就想过自己搭建一个博客网站，因为自己有记东西的习惯，简书+csdn+有道云，挺麻烦的，今天偶然知道了hexo，感觉这个东西很好，就尝试5分钟搭建，但是实际上不止5分钟呀，中间也遇到了问题，现把我的搭建过程做个记录。 原文链接：5分钟搭建免费个人博客 安装Hexo此步安装命令用的是下面的： 1npm install -g hexo-cli 安装成功之后,会提示hexo的安装目录。我在D盘下新建了Hexo文件夹，执行 1hexo init D:\Hexo 进入到该路径下，初始化网站存储的文件1hexo init username.github.io 根据链接的配置要求进行更改，进入到该文件夹下面1cd username.github.io 执行1hexo s 测试启动可以运行 注意事项： hexo的安装命令有很多，我第一遍安装失败了，遇到了hexo不是内部或外部命令 hexo的文档命名和内容格式 有一定的要求，按照下面的语法新建文档，再编辑新内容1hexo new &quot;doc name&quot; 总结今天学习到的命令 123hexo shexo new &quot;doc name&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 要好好学习markdown的语法喽~]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学scala》学习笔记--第14章 模式匹配和样例类]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC14%E7%AB%A0%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[此篇文章针对有一定Scala基础的读者 14.1 更好的switch 123456val ch: Char = '*'ch match &#123; case '+' =&gt; println("加法") case '*' =&gt; println("乘法") case _ =&gt; println("木有")&#125; match是一个表达式，而不是语句，会有返回值 1234567val ch: Char = &apos;*&apos;val x:Int = ch match &#123; case &apos;+&apos; =&gt; 0 case &apos;*&apos; =&gt; 1 case _ =&gt; 2&#125;println(x) 14.2 守卫守卫可以是任何布尔条件，在下面的例子中，只有在守卫模式不能匹配的情况下才执行所有模式匹配 123456789val ch:Char = 3var sign:Int = 0ch match &#123; case &apos;+&apos; =&gt; println(&quot;++++&quot;) case &apos;*&apos; =&gt; println(&quot;====&quot;) case _ if ch &gt;= 0 &amp;&amp; ch &lt;= 9 =&gt; sign = ch case _ =&gt; println(&quot;---&quot;)&#125;println(sign) 14.3 模式中的变量case _ 是这种特性的特殊情况，变量名是 _ 12345678910val c: Char = &apos;+&apos;val ch:Char = 9var sign:Int = 0ch match &#123; case &apos;+&apos; =&gt; println(&quot;++++&quot;) case &apos;*&apos; =&gt; println(&quot;====&quot;) case c if c &gt;= 0 &amp;&amp; c &lt;= 9 =&gt; sign = c case _ =&gt; println(&quot;---&quot;)&#125;println(sign) 变量必须以小写字母开头 如果有一个小写字母开头的常量，则需要将它包在反引号中。 14.4 类型模式匹配列表中的每一个元素的类型，将每一个元素映射成 =&gt; 后面的 string 类型 1234567val ls = List(1,3,4,&quot;one&quot;,&quot;two&quot;,4.5)val l = ls.map(_ match &#123; case x:Int =&gt; &quot;int x:&quot; + x case s:String =&gt; &quot;string s:&quot; + s case _ =&gt; &quot;other&quot;&#125;)l.foreach(println) 14.5 匹配组、列表和元组要匹配数组的内容，可以在模式中使用Array表达式, 1234567val arr1 = Array(Array(0),Array(3,4),Array(0,4,6),Array(&quot;fad&quot;,&quot;fff&quot;))arr1.map(_ match &#123; case Array(0) =&gt; println(0) case Array(x,y) =&gt; println(x,y) case Array(0,_*) =&gt; println(&quot;...&quot;)//_*符号匹配数组中余下的内容 case _ =&gt; println(&quot;something&quot;)&#125;) 匹配列表中的元素 12345678val ls = List(List(0),List(3,4),List(0,4,5),List(&quot;fa&quot;,&quot;aaa&quot;,&quot;tttt&quot;))ls.map(_ match &#123; case 0::Nil =&gt; println(0) case x :: y :: Nil =&gt; println(x,y) case 0 :: tail =&gt; println(tail.foreach(println)) case x :: tail =&gt; println(&quot;====&quot;) case _ =&gt; println(&quot;something&quot;)&#125;) 匹配元组 123456val ls = List((0,4),(&quot;fa&quot;,0),(3,4))ls.map(_ match &#123; case (0,_) =&gt; println(0) case (x,y) =&gt; println(x,y) case _ =&gt; println(&quot;something&quot;)&#125;) 14.6 提取器前一节中匹配数组、列表和元素的功能是依靠提取器实现的 ==提取器机制==：带有从对象中提取值得unapply和unapplySeq方法得对象。unapply提取固定数量得对象，而unapplySeq提取得是一个序列 1Array.unapplySeq(arr) 产出一个序列的值。 14.8 for表达式中的模式123val ls = List((1,2),(3,4),(4,5))for ((k,v) &lt;- ls if k % 2 == 1) println(k,v) 14.9 样例类可以用模式匹配来匹配样例类，并将属性值绑定到变量 12345678910case class Dollar(value:Double)case class Currency(value:Double,unit:String)case object Yuanval ls = List(Dollar(2.3),Currency(4.5,&quot;10&quot;),Yuan)ls.map(_ match &#123; case Dollar(v) =&gt; println(s&quot;Dollar:$v&quot;) case Currency(_,u) =&gt; println(s&quot;got $u&quot;) case Yuan =&gt; println(&quot;lalala&quot;) case _ =&gt; println(&quot;----&quot;)&#125;) 样例类实例使用(),样例对象不适用圆括号 ==声明样例类的时候有如下几件事自动发生：== 构造器中的每一个参数都成为val，除非被显式地声明为var 在伴生对象中提供apply方法，可以不用new关键字就能构造出相应的对象，比如Dollar(2.3) 提供unapply方法让模式匹配可以工作 将生成toString,equals,copy方法，除非显式给出定义 14.10 copy方法和带名参数copy方法创建一个与现有对象值相同的新对象，可以用带名参数修改某些属性 1234val amt = Currency(34.2,&quot;RUR&quot;)val price = amt.copy()val price1 = amt.copy(value = 13)val price2 = amt.copy(unit = &quot;CHF&quot;) 14.11 case语句中的中置表示法如果unapply方法产出一个对偶，可以在case语句中使用中置表示法，19章将会看到将解析结果组合在一起的~样例类: 1result match &#123;case p ~ q =&gt; ...&#125; //等同于case ~(p,q) 如果操作符以冒号结尾，则他是从右向左结合的 中置表示法可以用于任何返回对偶的unapply方法： 1234567case object +: &#123; def unapply[T](input: List[T]):Option[(T,List[T])] = if(input.isEmpty) None else Some((input.head,input.tail))&#125;1+:7+:2+:Nil match &#123; case first +: second +: rest =&gt; println(first + second + rest.length)&#125; 14.12 匹配嵌套结构三个样例类继承Item抽象类，Bundle和Boolean类嵌套Article和Bundle样例类，可以用@表示法将嵌套的值绑定到变量 12345678910111213abstract class Itemcase class Article(desc:String,price:Double) extends Item//继承同一个抽象类case class Bundle(desc:String,discount:Double,item:Item) extends Itemval peak = Bundle(&quot;Father&apos;s Day is special&quot;,20.0,Article(&quot;scala is nice&quot;,45.5))case class Boolean(desc:String,dis:Double,item:Item*)//Item抽象类列表val amt = Boolean(&quot;great&quot;,23.3,Bundle(&quot;nice&quot;,45.4,Article(&quot;wonderful&quot;,45.4)),Article(&quot;scala is nice&quot;,45.5))val ls = List(peak,amt)ls.map(_ match &#123; case Bundle(_,_,Article(desc,price)) =&gt; println(s&quot;bundle $&#123;desc&#125;:$&#123;price&#125;&quot;) case Boolean(_,_,art @ Bundle(_,_,_),rest @ _*) =&gt; println(s&quot;boolean $&#123;art.desc&#125;:$&#123;art.discount&#125;,$&#123;rest.head&#125;&quot;) case Boolean(_,_,art @ Bundle(_,_,_),rest) =&gt; println(s&quot;boolean $&#123;art.desc&#125;&quot;)//匹配继承Item抽象类的元素只有两个 case _ =&gt; println(&quot;None&quot;)&#125;) 14.14 密封类当用样例类来做模式匹配的时候，想让编译器帮助确保已经列出了所有可能的选择，要达到这个目的，需要将样例类的通用超类声明为sealed 密封类的所有子类都必须在与该密封类相同的文件中定义。 如果某个类是密封的，那么在编译期所有子类就是可知的，因此==编译器可以检查模式语句的完整性==，让同一组样例类都扩展自某个密封的类或者特质是一个好的做法 12345678910sealed abstract class Amountcase class Red(bottom:Double) extends Amountcase object Green extends Amountcase object Gray extends Amountval color:Amount = Red(3.4)//需要显式声明color的类型，不然就会变成Redcolor match &#123; case Red(_) =&gt; println(&quot;red&quot;) case Green =&gt;println(&quot;green&quot;) case Gray =&gt; println(&quot;fad&quot;)&#125; 14.16 Option类型标准类库的Option类型用样例类来表示那种可能存在，也可能不存在的值。这比空字符串更加清晰，比null做法更加安全。 map类的get方法返回一个Option。如果对于给定的键没有对应的值，则get返回None，如果有值，该值包在Some中返回 请以不要直接使用get方法，返回None的情况可能会使程序死掉，尽量用getOrElse Option[+A]密封抽象类，Some和None继承Option类 14.17 偏函数被包括在花括号内的一组case语句是一个偏函数——==并非对所有输入值都有定义的函数==。它是PartialFunction[A,B]类的一个实例，该类有两个方法：apply方法从匹配到的模式计算函数值，而isDefinedAt方法在输入至少匹配其中一个模式时返回true 1234567val f:PartialFunction[Char,Int] = &#123; case &apos;+&apos; =&gt; 1 case &apos;-&apos; =&gt; -1&#125;println(f(&apos;+&apos;))//1//println(f(&apos;0&apos;))//errorprintln(f.isDefinedAt(&apos;0&apos;))//false]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远方]]></title>
    <url>%2F2018%2F07%2F25%2F%E8%BF%9C%E6%96%B9%2F</url>
    <content type="text"><![CDATA[期盼着远方思念着家乡我有一个姑娘我有一个姑娘舍不得家乡牵挂着远方]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我邮人缚苍龙]]></title>
    <url>%2F2014%2F12%2F01%2F%E7%9C%8B%E6%88%91%E9%82%AE%E4%BA%BA%E7%BC%9A%E8%8B%8D%E9%BE%99%2F</url>
    <content type="text"><![CDATA[芳草垂柳梧桐秀心唤帝都今重又汗洒昌平夜如昼群峰含笑送清秋戎装飒爽为北邮天地苍茫出浩宇看我邮人缚苍龙]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训1]]></title>
    <url>%2F2014%2F12%2F01%2F%E5%86%9B%E8%AE%AD1%2F</url>
    <content type="text"><![CDATA[黄沙不见烈日炎，碧云天，晓风怨。飒爽英姿，真是个超然。勿让云雨匆匆散，月夜下，欢歌连。闲适风景时时盼，舞翩翩，望不断。舟叶水源，回首泪涟涟。待到君心换我心，垂柳下，戎装前。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>诗词</tag>
      </tags>
  </entry>
</search>
