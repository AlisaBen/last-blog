<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-string-easy-13-606]]></title>
    <url>%2F2018%2F08%2F13%2Fleetcode-string-easy-13-606%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是13,606 题目：13. Roman to Integer描述：Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.例子：123456789101112Input: "III"Output: 3Input: "IV"Output: 4Input: "IX"Output: 9Input: "LVIII"Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Input: "MCMXCIV"Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 代码：12345678910111213141516171819202122232425int Solution13::order(char c)&#123; if (c == 'I')return 1; else if (c == 'V') return 5; else if (c == 'X')return 10; else if (c == 'L') return 50; else if (c == 'C')return 100; else if (c == 'D')return 500; else if (c == 'M')return 1000; return -1;&#125;int Solution13::romanToInt(string s)&#123; int sum = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (i &lt; s.size() &amp;&amp; order(s[i]) &lt; order(s[i + 1])) &#123; sum += order(s[i + 1]) - order(s[i]); ++i; &#125; else sum += order(s[i]); &#125; return sum;&#125; 题目：606. Construct String from Binary Tree描述：You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. 例子：123456789101112131415161718192021222324Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: "1(2(4))(3)"Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)".Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: "1(2()(4))(3)"Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 代码：12345678910111213141516171819202122 struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;string Solution606::tree2str(TreeNode* t)&#123; if (t == NULL)return ""; string s; s += to_string(t-&gt;val); if (t-&gt;left != NULL) s += "(" + tree2str(t-&gt;left) + ")"; if (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) s += "()"; if (t-&gt;right != NULL) s += "(" + tree2str(t-&gt;right) + ")"; return s;&#125; 请好心人告诉我，应该怎样测试606QAQ]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring入门]]></title>
    <url>%2F2018%2F08%2F12%2FSpring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[从零开始构建spring工程小例子 简单的spring例子环境：idea新建工程步骤参考：https://blog.csdn.net/zzy1078689276/article/details/78732183/ 可以不选择步骤中的archetype我的工程名字是spring-start 工程初始化会下载一些依赖，需要一些时间 编辑pom.xml文件，填写工程所依赖的库的配置信息123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.alisa&lt;/groupId&gt; &lt;artifactId&gt;spring-start&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring3-Example&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--sprint3 deploy--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置项规定了工程的编码格式和依赖的包包括:junit和org.springframework.spring-context org.springframework.spring-core 创建目录结构我的目录结构如图所示： 如果右键新建没有class和package,请参考这篇博客：https://blog.csdn.net/qq_27093465/article/details/52912444我设置的java文件夹Sources，resources文件夹是Resources 编辑HelloWorld App SpringBeans文件HelloWorld1234567891011package com.alisa.demo.helloworld;public class HelloWorld &#123; private String name; public void setName(String n)&#123; this.name = n; &#125; public void printHello()&#123; System.out.println("hello:"+name); &#125;&#125; App文件通过getBean方法（参数是id）访问配置文件中的bean标签（可能我的说法不准确)1234567891011121314package com.alisa.demo.spring3_Example;import com.alisa.demo.helloworld.HelloWorld;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml");//声明从SpringBeans.xml获取配置文件 HelloWorld obj = (HelloWorld) context.getBean("helloBean"); obj.printHello(); &#125;&#125; SpringBeans文件中重要的是bean标签的编辑，在一个文件中bean标签的id唯一，class属性定义所连接的java class文件，&lt;property&gt;定义了与class相关的值，这里主要是name和value，我的理解是将class文件中的name变量的值设置为alisa.12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloBean" class="com.alisa.demo.helloworld.HelloWorld"&gt; &lt;property name="name" value="alisa" &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行便可出现结果 实现松耦合在包com.alisa.demo下新建包loosely_coupled,并在此目录下新建Interface和class文件IOutputGenerator实现抽象类12345package com.alisa.demo.loosely_coupled;public interface IOutputGenerator &#123; public void generatorOutput();&#125; CsvOutputGenerator重写上面接口函数1234567package com.alisa.demo.loosely_coupled;public class CsvOutputGenerator implements IOutputGenerator&#123; public void generatorOutput() &#123; System.out.println("creating csv..."); &#125;&#125; JsonOutputGenerator重写继承的接口函数1234567package com.alisa.demo.loosely_coupled;public class JsonOutputGenerator implements IOutputGenerator&#123; public void generatorOutput() &#123; System.out.println("creating json..."); &#125;&#125; OutputHelper文件可以设定当前的OutputGenerator实例对象123456789101112package com.alisa.demo.loosely_coupled;public class OutputHelper &#123; IOutputGenerator outputGenerator; public void generatorOutput()&#123; this.outputGenerator.generatorOutput();//设定实例对象的输出函数 &#125; public void setOutputGenerator(IOutputGenerator outputGenerator) &#123; this.outputGenerator = outputGenerator;//设定实例对象 &#125;&#125; 在resources下新建Spring-Output.xml文件，id为OutputHelper的bean是App文件中所连接的bean，指定java class文件，设置class文件中的outputGenerator值为CsvOutputGenerator(这里从上面的value属性改为ref属性我不是很理解)，可能ref属性会寻找当前配置文件中id属性值为CsvOutputGenerator的bean标签，从而得到该CsvOutputGenerator类的内容12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="OutputHelper" class="com.alisa.demo.loosely_coupled.OutputHelper"&gt; &lt;property name="outputGenerator" ref="CsvOutputGenerator"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="CsvOutputGenerator" class="com.alisa.demo.loosely_coupled.CsvOutputGenerator"&gt;&lt;/bean&gt; &lt;bean id="JsonOutputGenerator" class="com.alisa.demo.loosely_coupled.JsonOutputGenerator"&gt;&lt;/bean&gt;&lt;/beans&gt; 修改App文件，没有明确指出所定义的输出实例对象是哪一个，而是通过配置文件来设定12345678910111213141516package com.alisa.demo.spring3_Example;import com.alisa.demo.helloworld.HelloWorld;import com.alisa.demo.loosely_coupled.OutputHelper;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("Spring-Output.xml");//修改配置文件// HelloWorld obj = (HelloWorld) context.getBean("helloBean");// obj.printHello(); OutputHelper outputHelper = (OutputHelper)context.getBean("OutputHelper"); outputHelper.generatorOutput(); &#125;&#125; 实现了通过Spring-Output.xml控制代码输出 Spring Ioc容器Spring中给Bean属性注入value在包com.alisa下新建包spring.bean在该包下新建class文件FileNameGenerator和App123456789101112131415161718192021222324package com.alisa.spring.bean;public class FileNameGenerator &#123; private String name; private String type; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public void printFileName()&#123; System.out.println("filename &amp; filetype is:"+name+" &amp; "+type); &#125;&#125; App12345678910111213package com.alisa.spring.bean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml"); FileNameGenerator obj = (FileNameGenerator) context.getBean("FileNameGenerator"); obj.printFileName(); &#125;&#125; 编辑SpringBeans.xml文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloBean" class="com.alisa.demo.helloworld.HelloWorld"&gt; &lt;property name="name" value="alisa" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="FileNameGenerator" class="com.alisa.spring.bean.FileNameGenerator"&gt; &lt;property name="name"&gt; &lt;value&gt;alisa&lt;/value&gt; &lt;/property&gt; &lt;!--&lt;property name="name" value="alisa"&gt;&lt;/property&gt;--&gt; &lt;property name="type"&gt; &lt;value&gt;txt&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--&lt;bean id="FileNameGenerator" class="com.alisa.spring.bean.FileNameGenerator" p:name="alisa" p:type="txt"&gt;&lt;/bean&gt;--&gt;&lt;/beans&gt; 注意到value属性的三种定义方式： name12 &lt;value&gt;alisa&lt;/value&gt;&lt;/property&gt; name13. ```&lt;bean id=&quot;FileNameGenerator&quot; class=&quot;com.alisa.spring.bean.FileNameGenerator&quot; p:name=&quot;alisa&quot; p:type=&quot;txt&quot;&gt;&lt;/bean&gt; 第三种方式需要在开头加上xmlns:p=&quot;http://www.springframework.org/schema/p&quot; Spring Inner Bean–内部嵌套的Bean内置嵌套的Bean支持属性注入和构造函数注入 在实现【松耦合】一节中所提到的ref属性其实就是Bean内部嵌套，所以我之前的猜想是正确的重新回顾那一节的配置文件12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="OutputHelper" class="com.alisa.demo.loosely_coupled.OutputHelper"&gt; &lt;property name="outputGenerator" ref="CsvOutputGenerator"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="CsvOutputGenerator" class="com.alisa.demo.loosely_coupled.CsvOutputGenerator"&gt;&lt;/bean&gt; &lt;bean id="JsonOutputGenerator" class="com.alisa.demo.loosely_coupled.JsonOutputGenerator"&gt;&lt;/bean&gt;&lt;/beans&gt; 利用ref属性引用了CsvOutputGenerator,但是一旦CsvOutputGenerator引用，就不会被别的Bean引用采用下面的方法可以避免这样的问题： 修改方式如下：123456789&lt;!--&lt;bean id="OutputHelper" class="com.alisa.demo.loosely_coupled.OutputHelper"&gt;--&gt; &lt;!--&lt;property name="outputGenerator" ref="CsvOutputGenerator"&gt;&lt;/property&gt;--&gt;&lt;!--&lt;/bean&gt;--&gt;&lt;bean id="OutputHelper" class="com.alisa.demo.loosely_coupled.OutputHelper"&gt; &lt;property name="outputGenerator"&gt; &lt;bean class="com.alisa.demo.loosely_coupled.CsvOutputGenerator"&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 在内部声明一个Bean，但是我并没有觉得方便，还有一种方式是：12345678910&lt;bean id="OutputHelper" class="com.alisa.demo.loosely_coupled.OutputHelper"&gt; &lt;constructor-arg&gt; &lt;bean class="com.alisa.demo.loosely_coupled.CsvOutputGenerator"&gt; &lt;/bean&gt; &lt;/constructor-arg&gt; &lt;!--&lt;property name="outputGenerator"&gt;--&gt; &lt;!--&lt;bean class="com.alisa.demo.loosely_coupled.CsvOutputGenerator"&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;/property&gt;--&gt;&lt;/bean&gt; 但是这个例子在我这里显示是错的，还没有搞懂是为什么 Spring Bean Scopes–Bean的作用域Bean的作用域决定了从Spring容器中返回的Bean实例的类型。在Spring中，支持以下5种类型的作用域： singleton——单利模式，由IOC容器返回一个唯一的bean实例 prototype——原型模式，被请求时，每次返回一个新的bean实例 request——每个http request请求返回一个唯一的bean实例 session——每个http session返回一个唯一的bean实例 globalSession——http session全局bean实例 ###singleton 和prototype区别新建包com.alisa.spring.customer.services在该目录下新建class文件CustomerService和App123456789101112package com.alisa.spring.customer.services;public class CustomerService &#123; String message; public String getMessage()&#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; App12345678910111213141516package com.alisa.spring.customer.services;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml"); CustomerService customerService = (CustomerService)context.getBean("CustomerService"); customerService.setMessage("message by 1"); System.out.println("1:"+customerService.getMessage()); CustomerService customerService2 = (CustomerService)context.getBean("CustomerService"); System.out.println("2:"+customerService2.getMessage()); &#125;&#125; 在SpringBeans.xml文件中新增下面语句，分别将scope参数设置成prototype singleton看下结果 1&lt;bean id="CustomerService" class="com.alisa.spring.customer.services.CustomerService" scope="prototype"&gt;&lt;/bean&gt; 在prototype模式下每次调用getBean函数都生成一个新的实例 Spring collections–集合类型的Bean主要讲怎样将值注入集合类型： List Set Map Properties 在b包spring下面新建包collections,新建Customer Person App类编辑文件Person12345678910111213141516171819202122232425package com.alisa.spring.collections;public class Person &#123; private String name; private String address; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString()&#123; return "Person [address="+address+",name="+name+"]"; &#125;&#125; Customer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.alisa.spring.collections;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Customer &#123; private List&lt;Object&gt; lists; private Set&lt;Object&gt; sets; private Map&lt;Object,Object&gt; maps; private Properties pros; public List&lt;Object&gt; getLists()&#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Set&lt;Object&gt; getSets() &#123; return sets; &#125; public void setSets(Set&lt;Object&gt; sets) &#123; this.sets = sets; &#125; public Map&lt;Object, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;Object, Object&gt; maps) &#123; this.maps = maps; &#125; public Properties getPros() &#123; return pros; &#125; public void setPros(Properties pros) &#123; this.pros = pros; &#125; private Person person; public Customer(Person person)&#123; this.person = person; &#125; public Customer()&#123;&#125; public void setPerson(Person person) &#123; this.person = person; &#125; @Override public String toString() &#123; return "Customer [person="+person+"]"; &#125;&#125; App1234567891011121314151617181920package com.alisa.spring.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringCollections.xml"); Customer obj = (Customer) context.getBean("CustomerBean"); System.out.println(obj.getLists().toString()); System.out.println(obj.getMaps().toString()); System.out.println(obj.getPros().toString()); System.out.println(obj.getSets().toString());// [1, Person [address=beijing,name=alisa], 2, Person [address=jilin,name=ben]]// &#123;a=1, b=Person [address=beijing,name=alisa], c=Person [address=jilin,name=ben]&#125;// &#123;admin=admin, support=support&#125;//[1, Person [address=beijing,name=alisa], Person [address=jilin,name=ben]] &#125;&#125; 编辑配置文件SpringCollections.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="CustomerBean" class="com.alisa.spring.collections.Customer"&gt; &lt;property name="lists"&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean="personBean"&gt;&lt;/ref&gt; &lt;value&gt;2&lt;/value&gt; &lt;bean class="com.alisa.spring.collections.Person"&gt; &lt;property name="name" value="ben"&gt;&lt;/property&gt; &lt;property name="address" value="jilin"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name="sets"&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean="personBean"&gt;&lt;/ref&gt; &lt;bean class="com.alisa.spring.collections.Person"&gt; &lt;property name="name" value="ben"&gt;&lt;/property&gt; &lt;property name="address" value="jilin"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name="maps"&gt; &lt;map&gt; &lt;entry key="a" value="1"&gt;&lt;/entry&gt; &lt;entry key="b" value-ref="personBean"&gt;&lt;/entry&gt; &lt;entry key="c"&gt; &lt;bean class="com.alisa.spring.collections.Person"&gt; &lt;property name="name" value="ben"&gt;&lt;/property&gt; &lt;property name="address" value="jilin"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name="pros"&gt; &lt;props&gt; &lt;prop key="admin"&gt;admin&lt;/prop&gt; &lt;prop key="support"&gt;support&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id="personBean" class="com.alisa.spring.collections.Person"&gt; &lt;property name="name" value="alisa"&gt;&lt;/property&gt; &lt;property name="address" value="beijing"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring注解的配置注解是为Spring容器提供Bean定义的信息，把XML定义的信息通过类注解描述出来。Spring他容器三大要素：Bean定义，Bean实现类和Spring框架。采用XML配置，Bean定义和Bean实现类本身分离，而采用注解配置，Bean定义在Bean实现类上注解就可以实现。 几种注解的方式： @Component @Autowired Configuration——表示核心配置文件 注解的例子见下一节 Spring自动扫描与自动装配在spring下新建包services dao common在dao下新建CustomerDAO.java, services下新建CustomerService.java common下新建App.java 编辑这几个文件CustomerDAO.java1234567891011package com.alisa.spring.dao;import org.springframework.stereotype.Component;@Componentpublic class CustomerDAO &#123; @Override public String toString()&#123; return "hello this is a dao"; &#125;&#125; CustomerService.java123456789101112131415161718192021222324package com.alisa.spring.services;import com.alisa.spring.dao.CustomerDAO;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CustomerService &#123; @Autowired CustomerDAO customerDAO;// public CustomerDAO getCustomerDAO() &#123;// return customerDAO;// &#125;//// public void setCustomerDAO(CustomerDAO customerDAO) &#123;// this.customerDAO = customerDAO;// &#125; @Override public String toString() &#123; return "CustomerService [customerDAO="+customerDAO+"]"; &#125;&#125; App.java12345678910111213package com.alisa.spring.common;import com.alisa.spring.services.CustomerService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("SpringCustomer.xml"); CustomerService customerService = (CustomerService) context.getBean("customerService"); System.out.println(customerService); &#125;&#125; 新建配置文件SpringCustomer.xmlbase-package表示组件的存放位置，扫描对应文件夹下的bean(用@Component注释过的)，将这些bean注册到容器中1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--&lt;bean id="customerService" class="com.alisa.spring.services.CustomerService"&gt;--&gt; &lt;!--&lt;property name="customerDAO" ref="customerDAO"&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id="customerDAO" class="com.alisa.spring.dao.CustomerDAO"&gt;&lt;/bean&gt;--&gt; &lt;context:component-scan base-package="com.alisa.spring"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; @Component表示这个class文件是一个自动扫描组件默认情况下，Spring将把组件class的第一个字母变成小写，来作为自动扫描组件的名称 也可以像下面这样，创建自定义的组件名称123@Service("AAA")public class CustomerService... 需要添加下面的代码1import org.springframework.stereotype.Service; 调用自己定义的组件1CustomerService customerService = (CustomerService) context.getBean("AAA");]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Spring</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础语法]]></title>
    <url>%2F2018%2F08%2F11%2Fjava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java语法的积累java和scala的不同：Java继承与Java多态 利用文本编辑java程序新建HelloWorld.java文件输入一下内容12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println("hello world"); &#125;&#125; 进入文件所在目录执行javac HelloWorld.java,文件夹下就会多一个HelloWorld.class文件，执行java HelloWorld输出代码结果 java语言基础常量表示12final double PI = 3.14final char A = 'a'; 常量可以首先声明，然后赋值，但是只能赋值一次 java运算符位运算符 &amp;按位与 |按位或 ^按位异或 ~按位补 &lt;&lt;按位左移 &gt;&gt;按位右移 &gt;&gt;&gt;按位右移补零 逻辑运算符 &amp;&amp; || ! ^异或，不同为1 java数组数组的定义和初始化声明数组123int ages[];char sys[];String [] name; 分配空间12int [] ages = &#123;12,14,35&#125;;char [] sym = new char[10]; 可以把一个数组赋值给另一个数组,实际上a1和a2指向了内存中同一个地址，修改其中一个数组，另一个也改变12int [] a1 = &#123;1,2,3&#125;;int [] a2 = a1; 12345int [] ages = &#123;1,23,4&#125;;for(int i = 0 ;i &lt; ages.length;i++)&#123; System.out.println("数组中第"+(i+1)+"个元素是"+ages[i]);&#125; 二维数组1String [][] name = &#123;&#123;"zhao","fdaf"&#125;,&#123;"va","fa"&#125;&#125;; java方法123访问修饰符 返回值类型 方法名(参数列表)&#123; 方法体&#125; 访问修饰符：代表方法允许被访问的权限范围，public protected private一个java方法的小例子12345678910public class PrintScore&#123; public static void main(String[] args)&#123; PrintScore a = new PrintScore(); int rSum; rSum = a.calcSum(2,3); &#125; public int calcSum(int a,int b)&#123; return a+b; &#125;&#125; 方法重载，在Java中通过类中写多个方法，这类方法的方法名相同，参数列表不同（参数个数和参数类型不同）来实现重载 Java类与对象一个类可以包含一下类型变量： 局部变量，在方法中定义的变量 成员变量，定义在类中，方法体之外的变量，在创建对象的时候实例化 类变量， 也叫静态变量，类声明也在类中，方法体之外，但必须声明为static类型 构造方法每个类都有构造方法。如果没有显式地为类构造方法，Java编译器会构建默认构造方法，可以又多个构造方法语法格式为：123public 构造方法名()&#123;&#125; 例子:12345678public class People&#123; double height; int age; public People(double h,int a)&#123; height = h; age = a; &#125;&#125; 123People tt = new People(13,134);tt.height = 12;tt.age = 34; java继承继承可以看作是类与类之间的衍生关系，父类更通用，子类更具体 1class 子类 extends 父类 继承的例子：先创建一个父类Animal123456public class Animal&#123; public int legNum; public void bark()&#123; System.out.println("animal"); &#125;&#125; 再创建一个子类(习惯手写继承)：123public class Dog extends Animal&#123;&#125; 创建一个Test类，作为程序入口1234567public class Test&#123; public static void main(String[] args)&#123; Dog s = new Dog(); a.legNum = 4; a.bark(); &#125;&#125; 继承的特点 子类拥有父类除了private以外的所有属性和方法 子类可以拥有自己的属性和方法 子类可以重写实现父类的方法 Java中的继承是单继承，一个类只有一个父类（这里和scala有所区别） Java实现多继承的一个办法是implements接口 子类方法重写接着上面的例子，修改Dog类,重新运行测试12345public class Dog extends Animal&#123; public void bark()&#123; System.out.println("bark..."); &#125;&#125; 继承的初始化顺序系统先创建父类对象，再创建子类对象，先初始化属性，再调用构造函数 小知识final关键字可以修饰类、方法、属性和变量 final修饰类，则该类不允许被继承，为最终类 final修饰方法，则方法不允许被重写 final修饰属性，则该类的属性不会进行隐式的初始化或在构造方法中赋值 final修饰变量，则该变量的赋值只有一次 super关键字在子类内部使用，代表父类对象 访问父类的属性super.属性名 访问父类的方法super.bark() 子类构造方法需要调用父类的构造方法时，在子类的构造方法里最前面的位置：super() java多态多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定，是指在执行期间判断所引用对象的实际类型，根据实际类型调用相应的方法 向上转型下面这段代码接着上一节1Animal b = new Dog(); 由于Dog继承于Animal，所以Dog可以自动向上转型为Animal，所以b是可以指向Dog实例对象的 不能使用一个子类的引用去指向父类的对象Dog a = new Animal()是错的 如果定义了一个指向子类对象的父类引用类型，除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能（子类中重写的方法会覆盖父类的方法），但是对于只存在于子类的方法和属性就不能获取 多态的实现方式###多态的实现条件：继承、重写和向上转型 多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现 ###抽象方法声明语法1abstract void f(); 包含抽象方法的类叫做抽象类，抽象类在定义类时，会加上abstract关键字 使用抽象类的情况 某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法，父类只关注约束子类要实现的方法，而不关注方法如何实现 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，避免子类设计的随意性 抽象类可以没有抽象方法 抽象类的对象不能直接创建，通常是定义引用变量指向子类对象 一个实现抽象类的例子:1234public abstract class TelePhone&#123; public abstract void call(); public abstract void message();&#125; ###接口实现abstract关键字允许在类中创建一个或多个没有任何定义的方法，而interface使抽象的概念更向前迈进了一步，会产生一个完全抽象类，根本没有提供任何方法体 12345interface Animal&#123; int y = 5; public void eat(); public void travel();&#125; 接口不能用于实例化对象 接口中所有的方法是抽象方法 接口成员是static final类型 接口支持多继承 多继承的实现方式：123456修饰符 interface A extends 接口1，接口2&#123;&#125;修饰符 class A implements 接口1，接口2&#123;&#125; 一个实现多态的例子“1234public interface Animal&#123; public void bark(); public void travel();&#125; 123public interface Dog&#123; public void eat();&#125; 1234567891011public class Cat implements Animal,Dog&#123; public void bark()&#123; &#125;; public void travel()&#123; &#125;; public void eat()&#123; &#125;;&#125; Cat类必须对接口中的抽象方法重写]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令笔记]]></title>
    <url>%2F2018%2F08%2F11%2Flinux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日积月累linux命令 需要学会的快捷键 ctrl+d键盘输入结束或者退出终端 ctrl+s暂停当前程序后按下任意键恢复运行 ctrl+z当前程序放到后台运行，回复到前台是fg ctrl+a光标移至行头 ctrl+e光标移至行末 ctrl+k删除光标所在位置到行末 alt+backspace向前删除一个单词 通配符? *12touch asd.txt qaz.txtls *.txt 1touch love_&#123;1..10&#125;_file.txt Linux用户管理查看当前用户属性1who am i 创建用户利用sudo命令创建用户需要root权限，需要知道当前登录用户的密码，且当前用户必须在sudo用户组1sudo adduser lilei 创建用户的同时创建lilei文件夹,切换登录用户，输入密码1su -l lilei 用户注销exit 查看用户组输入下面命令可以看到用户属于的用户组1groups shiyanlou 查看etc/group文件1cat /etc/group | sort 可以使用命令过滤掉一些不想看到的结果1cat /etc/group | grep -E "shiyanlou" 将其他用户加入sudo用户组先切换到要加入sudo用户组的用户12su -l lileisudo ls 使用usermod命令可以为用户添加用户组1234su shiyanlougroups lileisudo usermod -G sudo lileigroups lilei 删除用户1sudo deluser lilei --remove-home Linux 文件基本属性1234[root@www /]# ls -ltotal 64dr-xr-xr-x 2 root root 4096 Dec 14 2012 bindr-xr-xr-x 4 root root 4096 Apr 19 2012 boot 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 Linux 文件与目录管理 ls: 列出目录 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) cd：切换目录 [root@www ~]# cd /root/runoob/ [root@www runoob]# cd ~回到家目录 [root@www runoob]# cd ..回到上一级目录 pwd：显示目前的目录 mkdir：创建一个新的目录 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～[root@www tmp]# mkdir -m 711 test2 -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！[root@www tmp]# mkdir -p test1/test2/test3/test4 rmdir：删除一个空的目录rmdir [-p] 目录名称 -p ：连同上一级『空的』目录也一起删除 [root@www tmp]# rmdir runoob/ cp: 复制文件或目录 rm: 移除文件或目录 tmp]# rm -i bashrc1rm: remove regular file `bashrc&apos;? y 变更文件所有者现在有两个用户shiyanlou 和lilei,当前用户为shiyanlou,切换到lilei用户创建文件,查看文件所属用户123su -l lilei touch iphone6ll iphone6 切换到shiyanlou用户，更改文件所有者，查看文件所有者123su shiyanlousudo chown shiyanlou iphone6ll iphone6 修改文件权限1chmod 600 iphone6 Linux文件基本操作Linux 文件内容查看 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 新建文件123touch testmkdir mydirmkdir father/son/grandson 复制文件复制test文件到后面目录复制文件夹需要加上-r参数，将子目录一同复制12cp test father/son/grandsoncp -r father family 删除文件 直接删除 1rm test 删除只读文件会有提示 1234touch testchmod 444 testll testrm test 若不想有提示1rm -f test 删除目录1rm -r family 移动文件与文件重命名123mkdir Doctouch filemv file doc 重命名1mv file1 myfile 编辑文件1vimtutor Linux 磁盘管理 df：列出文件系统的整体磁盘使用量 123456[root@www ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/hdc2 9.5G 3.7G 5.4G 41% //dev/hdc3 4.8G 139M 4.4G 4% /home/dev/hdc1 99M 11M 83M 12% /boottmpfs 363M 0 363M 0% /dev/shm du：检查磁盘空间使用量 fdisk：用于磁盘分区]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自从学了计算机，我得了一种“怪病”]]></title>
    <url>%2F2018%2F08%2F11%2F%E8%87%AA%E4%BB%8E%E5%AD%A6%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E6%88%91%E5%BE%97%E4%BA%86%E4%B8%80%E7%A7%8D%E2%80%9C%E6%80%AA%E7%97%85%E2%80%9D%2F</url>
    <content type="text"><![CDATA[标题党说的就是我，没跑了我只是在疗伤^&amp;^ 自从学了计算机，我慢慢发现我忘记了怎样享受闲暇的时光。每当放下所有的事，不去想还没有完成的代码、还没有学习的分布式、还没看懂的强化学习，除非让其他事情充实时间，否则我就会“生病”。反而在不断的学习中，体会进步的乐趣，享受高亮的代码所带给我的欢愉。 我的生活是由许多的已完成事项和待办事项组成，仿佛只有这样我才能正常运转，即使是我的课余爱好，都被安排进我的列表里，我渴望挣脱 在许多人的眼里，我是个学霸，勤勤奋奋，也拿着傲人的成绩，在自己的心中，有着不知多久才能填满的欲望鸿沟，这欲望不是拥有多少只mac、ysl，这欲望不是打卡多少次演唱会，这欲望不是去多少个城市几个大洲旅行而是能够凭借自己的努力过上温馨的小日子 小学五年级的时候神州五号飞船成功发射，那时候我的梦想是当一名宇航员，长大后我的梦想不见了 只剩下了愿望 我不知道我要多努力，要努力多久才能满足我的简单又不简单的小愿望 我是一个简单的存在，我知道自己喜欢什么，厌恶什么 我是一个独立的存在，不依靠任何人，内心强大又软弱 我是一个孤独的存在，不孤单 我喜欢窝在屋子里看书，没有人打扰，如果他可以陪着我一起看书，那再好不过，哪怕只有几十平米的出租屋 我喜欢骑车，我觉得那时的我是自由的，是和自然合二为一的，体会耳边的风声，还有不自觉的微笑，哪怕爬坡会累，屁股会痛，骑车会有风险 我喜欢跑步，尤其喜欢设定跑步的目标，我小妹说我活得规规矩矩，我不知道那是怎样的一种感觉，可能享受流汗的感觉 我喜欢画画，但是我很少画画，我的大部分时间都贡献给了增长知识和技能，小时候画画是一种乐趣，却不得要领，现在画画是一种奢望，时间是一种奢侈品，但我想，如果可以我可能是个不错的画师，毕竟我可以坐几个小时不动 我喜欢看科幻魔幻电影和情节发展明显的英剧和美剧，我没有对演员、导演、作者有特别的偏好，只单纯看作品，并喜欢它们所带给我的思考 我喜欢乒乓球，但是我很菜，嗯，基本上每次都会这样说，与乒乓球印象最深的三个场景，第一幕是高中带我乒乓球入门的几个哥们，我的坏底子估计有他们的原因，那可能是个可爱的春天，在老三中露天的操场上有几台孤零零的乒乓球台，我们几个在那里并不正儿八经的打球；第二幕是大一参加师生乒乓球赛，女双，接到了一个难度超大的球，以迷之弧度打到了对方的案边；第三幕是大三的最后一堂乒乓球课上，交叉比赛，最后一组和班上乒乓球打的最好的女生交手，比分不记得了反正我输了，结束后她对我说：你应该参加学校的乒乓球赛。我想可能是因为它们给了我鼓励和信心 我喜欢代码，准确的说是喜欢我能看得懂的代码，每次学习新的代码就会莫名的兴奋，就像我自己的博客，无脑搭建，但是仍然很兴奋，很容易带给我成就感，但是最近看强化学习看的非常难受，我喜欢按照自己的节奏去学习，不喜欢被push得太紧，实际上可能就是我的性子太急了 实际上，我的大部分时间都贡献给了看得懂的看不懂的代码，因为这是我以后赖以生存的基础 我想这也可能算作是物质的一种，为了满足起码的需求，每当我停下来就会有一种危机感，电脑和手机在我的生活中占据了越来越大的比重，每天都提醒自己，不要让它们占据我的睡眠，每天坚持10点到11点半之间睡觉，而且我的睡眠一直不错，这是一件让我感到幸福的事情，即使是假期早晨也会在七点半到八点半之间自然醒，可能在别人看来这是勤奋使然，我发现，自然醒的早起让我有种莫名的开心，可能这是我的身体给我的反馈，就像跑步一样 放假在家的这段时间，每天都很充实，学习、画画、看书、跑步，码代码、看电影，可以说是很幸福了，然而我却希望有一种技能，可以让我防空自我、停止思考、享受闲暇的静谧时光 每当生病的时候，要么有肩膀可以靠一靠，要么写一些无厘头的字 第二天我的病就痊愈了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-696-788]]></title>
    <url>%2F2018%2F08%2F11%2Fleetcode-string-easy-696-788%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是696,788 题目：696. Count Binary Substrings描述：Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.例子：1234567Input: "00110011"Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".Notice that some of these substrings repeat and are counted the number of times they occur.Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together. 代码：12345678910111213141516171819202122232425262728int Solution696::countBinarySubstrings(string s)&#123; int num = 0; vector&lt;int&gt; group; int index = 0; for (int i = 1; i &lt; s.size(); ++i) &#123; if (s[i] != s[i - 1] &amp;&amp; i != s.size() - 1) &#123; group.push_back(i - index); index = i; &#125; else if (s[i] != s[i - 1] &amp;&amp; i == s.size() - 1)//i和index不在同一个片段 &#123; group.push_back(i - index);//先把i前面的片段长度加入 group.push_back(1);//再将i所在的片段加入 &#125; else if (i == s.size() - 1)//i和index在同一个片段 &#123; group.push_back(i - index + 1); &#125; &#125; for (int i = 1; i &lt; group.size(); ++i) &#123; num += min(group[i], group[i - 1]); &#125; return num;&#125; 解题边界条件： 最后一个元素与前一个元素相同 最后一个元素与前一个元素不同 题目：788. Rotated Digits描述：X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good?例子：12345Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool Solution788::isDiff(int x)&#123; int flag = 0; while (x &gt; 0) &#123; int v = x % 10; if(v == 0 || v == 1 || v == 8)&#123;&#125; else if (flag == 0 &amp;&amp; v == 2 || v == 5 || v == 6 || v == 9)flag = 1; else if(v == 3 || v == 4 || v == 7) return false; x = x / 10; &#125; return flag;&#125;int Solution788::rotatedDigits(int N)&#123; //int num = 0; //int flag; //int invalid;//0-valid 1--invalid //for (int i = 1; i &lt;= N; ++i) //&#123; // flag = 0; // invalid = 0; // string int_string = to_string(i); // for (int j = 0; j &lt; int_string.size(); ++j) // &#123; // if (flag == 0 &amp;&amp; int_string[j] == '2' || int_string[j] == '5' || int_string[j] == '6' || int_string[j] == '9') // &#123; // flag = 1; // &#125; // if (int_string[j] == '3' || int_string[j] == '4' || int_string[j] == '7') // &#123; // invalid = 1;//表示有3，4，7 // break; // &#125; // &#125; // if (!invalid &amp;&amp; flag)++num; //&#125; //return num; int num = 0; while (N &gt; 0) &#123; if (isDiff(N))++num; --N; &#125; return num;&#125; 数字比较比字符串比较速度快 将数字转换成字符串的内置函数to_string() 不要忘记invalid digit比较 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next主题博客网站优化]]></title>
    <url>%2F2018%2F08%2F11%2Fhexo-next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最开心的事情莫过于每天早晨起来看一眼我的博客网站了然而我等它等的不耐烦，尤其手机端，更加不能忍 hexo-next主题网站加载慢原因1：加载Google字体慢 解决方法：找到\themes\next\layout_partials\head\external-fonts.swig文件，将fonts.googleapis.com 改成 fonts.useso.com]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清平乐·清枫唱晚]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%B8%85%E5%B9%B3%E4%B9%90%C2%B7%E6%B8%85%E6%9E%AB%E5%94%B1%E6%99%9A%2F</url>
    <content type="text"><![CDATA[今晚读宋词，读着读着就忍不住了，不知道为啥，每次诗词意境的主体都是男性23333 清平乐— 清枫唱晚，小楼把酒酣。满城灯火无人唤，夜夜埙声散。 梦里佳人独倚，惊觉落叶凄凄。恁知平生情意，残阳夜盼归期。 分享下今晚让我手痒痒的词 清平乐(王安国)— 留春不住，费尽莺儿语。满地残红宫锦污，昨夜南园风雨。 小怜初上琵琶，晓来思绕天涯。不肯画堂朱户，春风自在杨花。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宋词分享]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AE%8B%E8%AF%8D%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[分享几首昨天看到的喜欢的宋词 苏幕遮(范仲淹)— 碧云天，黄叶地。秋色连波，波上寒烟翠。山映斜阳天接水，芳草无情，更在斜阳外。黯乡魂，追旅思。夜夜除非，好梦留人睡。明月高楼休独倚，酒入愁肠，化作相思泪。 清平乐(晏殊)— 红笺小字，说尽平生意，鸿雁在云鱼在水，惆怅此情难寄。斜阳独倚西楼，遥山恰对帘钩。人面不知何处，绿波依旧东流。 蝶恋花(欧阳修)— 庭院深深深几许？杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F10%2Fleetcode-string-easy-4-1%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是521,824,20,520附stack string容器用法总结 总结收获 stack用法：empty() pop() push() size() top() string用法：append() insert() substr() append连接 123456basic_string &amp;append( const basic_string &amp;str );//在字符串的末尾添加str,basic_string &amp;append( const char *str );basic_string &amp;append( const basic_string &amp;str, size_type index, size_type len );//在字符串的末尾添加str的子串,子串以index索引开始，长度为lenbasic_string &amp;append( const char *str, size_type num );//在字符串的末尾添加str中的num个字符basic_string &amp;append( size_type num, char ch );//在字符串的末尾添加num个字符chbasic_string &amp;append( input_iterator start, input_iterator end );//在字符串的末尾添加以迭代器start和end表示的字符序列 insert插入 12345678iterator insert( iterator i, const char &amp;ch );basic_string &amp;insert( size_type index, const basic_string &amp;str );basic_string &amp;insert( size_type index, const char *str );basic_string &amp;insert( size_type index1, const basic_string &amp;str, size_type index2, size_type num );basic_string &amp;insert( size_type index, const char *str, size_type num );basic_string &amp;insert( size_type index, size_type num, char ch );void insert( iterator i, size_type num, const char &amp;ch );void insert( iterator i, iterator start, iterator end ); substr 1basic_string substr( size_type index, size_type num = npos );//substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串。 assign赋值 12345basic_string &amp;assign( const basic_string &amp;str );basic_string &amp;assign( const char *str );basic_string &amp;assign( const char *str, size_type num );basic_string &amp;assign( const basic_string &amp;str, size_type index, size_type len );basic_string &amp;assign( size_type num, char ch ); compare小于零 this &lt; str 1234567int compare( const basic_string &amp;str );//比较自己和strint compare( const char *str );int compare( size_type index, size_type length, const basic_string &amp;str );//比较自己的子串和str,子串以index索引开始，长度为lengthint compare( size_type index, size_type length, const basic_string &amp;str, size_type index2,size_type length2 );//比较自己的子串和str的子串，其中index2和length2引用str，index和length引用自己int compare( size_type index, size_type length, const char *str, size_type length2 );//比较自己的子串和str的子串，其中str的子串以索引0开始，长度为length2，自己的子串以index开始，长度为length copy 1size_type copy( char *str, size_type num, size_type index );//拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数 erase 123iterator erase( iterator pos );iterator erase( iterator start, iterator end );basic_string &amp;erase( size_type index = 0, size_type num = npos ); find 1234size_type find( const basic_string &amp;str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找）size_type find( const char *str, size_type index );size_type find( const char *str, size_type index, size_type length );size_type find( char ch, size_type index ); at begin end empty用法同vector容器 题目：521. Longest Uncommon Subsequence I描述：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.例子：12345Input: "aba", "cdc"Output: 3Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings. 代码：1234567int Solution521::findLUSlength(string a, string b)&#123; if (a == b)return -1; else if (a.size() == b.size())return a.size(); else return max(a.size(), b.size());&#125; 思路： 如果两个字符串相等不可能有不相同子序列 如果两个字符串不相等，但是长度相同，则最长的不同子序列就是二者任意一个 上述条件都不符合，则最长的字符串就是最长的不同子序列 题目：824. Goat Latin描述：A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. 例子：12Input: "I speak Goat Latin"Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa" 代码： 12345678910111213141516171819202122232425262728string Solution824::toGoatLatin(string S)&#123; int j = 0;//当前词开始下标 int k = 1;//记录第k个word unordered_set&lt;char&gt; vowel = &#123; 'a','e','i','o','u','A','E','I','O','U' &#125;; string t; for (int i = 0; i &lt; S.size(); ++i) &#123; if (S[i + 1] == ' ') &#123; if (vowel.find(S[j]) != vowel.end())//是元音 &#123; t.append(S.substr(j, i - j + 1)); &#125; else &#123; t.append(S.substr(j + 1, i - j)); t.append(S.substr(j, 1)); &#125; t.append("ma"); for (int a = 0; a &lt; k; a++)t.append("a"); t.append(" "); j = i + 2; ++k; &#125; &#125; return t;&#125; 收获： string::append() string::substr 题目：20. Valid Parentheses描述：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid.例子：1234Input: "()"Output: trueInput: "([)]"Output: false 代码： 123456789101112131415bool Solution20::isValid(string s)&#123; stack&lt;char&gt; t; for (char c : s) &#123; if (c == '(' || c == '[' || c == '&#123;') t.push(c); else &#123; if (t.empty() || (c == ')' &amp;&amp; t.top() != '(') || (c == ']' &amp;&amp; t.top() != '[') || (c == '&#125;' &amp;&amp; t.top() != '&#123;'))return false; else t.pop(); &#125; &#125; return t.empty();&#125; 收获： stack::push() stack::pop() stack::top() 多重判断条件时将特殊边界条件放在首位，比如t.empty() 题目：520. Detect Capital描述：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way.例子：12Input: "FlaG"Output: False 代码：1234567891011121314151617181920212223242526272829bool Solution520::detectCapitalUse(string word)&#123; //way 1 //int k = 0;//0--首字母大写 1--首字母小写 //int flag = 0;//0--首字母之外都是小写，1--首字母之外都是大写 //int len = word.size(); //for (int i = 0; i &lt; len; ++i) //&#123; // if (word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a' &amp;&amp; i == 0)k = 1; // else if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A' &amp;&amp; k == 1)return false;//首字母小写，中间出现了大写字母 // if (i == 1 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')flag = 1; // if (k == 0 &amp;&amp; i &gt; 1)//首字母大写 // &#123; // if ((flag == 1 &amp;&amp; word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a') || (flag == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A'))return false; // &#125; //&#125; //return true; //way 2 bool firstCapital = false;//首字母小写 int capital = 0;//大写字母个数 for (int i = 0; i &lt; word.size(); ++i) &#123; if (i == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')firstCapital = true; if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')++capital; if (capital &lt; i + 1 &amp;&amp; capital &gt;= 2)return false;//大写字母数目大于等于两个，却小于当前遍历过的字母 &#125; return (capital == 0 || (firstCapital &amp;&amp; capital == 1) || capital == word.size());&#125; 第二种方法的runtime优于第一种方法 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我还不会的markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%88%91%E8%BF%98%E4%B8%8D%E4%BC%9A%E7%9A%84markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[做个总结，少百度 文字加粗1**Cmd Markdown**是我们给出的答案 Cmd Markdown是我们给出的答案 引用12&gt; * 整理知识，学习笔记&gt; * 发布日记，杂文，所见所想 整理知识，学习笔记 发布日记，杂文，所见所想 图片1![图片](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533796313368&amp;di=60846b8d67a743b9d0ee45963a64f2db&amp;imgtype=0&amp;src=http%3A%2F%2Fc.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2Ff9198618367adab4b025268587d4b31c8601e47b.jpg) 链接1[AlisaBen](https://alisaben.github.io) AlisaBen 段落内嵌入代码1`print()` print() 分割线1------ 待办事项1234- [ ] 强化学习- [ ] 读书- [x] 完善博客网站- [x] 画画 强化学习 读书 完善博客网站 画画 代码高亮1var a:Int = 1 删除线1~~删除~~ 删除 表格12345| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \$1600 | 5 || 手机 | \$12 | 12 || 管线 | \$1 | 234 | 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F09%2Fleetcode-string-easy-4%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是344，557，657，804 总结收获 unordered_map,unordered_set,map和set的区别：unordered_map存储机制是哈希表，即unordered_map内部元素是无序的。map是红黑树，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。unordered_set基于哈希表，是无序的。set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。 在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。（外部引用者更为合适） set容器的insert操作不需要提前判定元素存在，如下图： vector和string容器实现了swap方法，内置swap进行了优化，优于自己写的简单交换 暂时不明白string s = &quot;&quot;;和string s;的区别，希望大佬可以指点 题目：344. Reverse String描述：Write a function that takes a string as input and returns the string reversed.例子：12Input: "hello"Output: "olleh" 代码：12345678910string Solution344::reverseString(string s)&#123; int len = s.size(); if (len &lt; 2)return s; for (int i = 0; i &lt; len / 2; i++) &#123; swap(s[i], s[len - i - 1]); &#125; return s;&#125; swap优于自己写的交换 题目:557. Reverse Words in a String III描述：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.例子：12Input: "Let's take LeetCode contest"Output: "s'teL ekat edoCteeL tsetnoc" 代码：1234567891011121314151617181920string Solution557::reverseWords(string s)&#123; int len = s.size(); int j = 0; for (int i = 0; i &lt; len; i++) &#123; if (i + 1 == len || s[i + 1] == ' ') &#123; int n = i - j + 1; int x = j; while (j &lt;= x + n /2 - 1) &#123; swap(s[j], s[i +x - j]); ++j; &#125; j = i + 2; &#125; &#125; return s;&#125; 在这道题中踩过的坑： 边界条件:i指向最后一个元素的情况 while循环中j不断变化，循环边界需要不变边界 swap交换时元素的下标计算 题目：657. Judge Route Circle描述：Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.例子：1234Input: "UD"Output: trueInput: "LL"Output: false 代码：12345678910111213141516bool Solution657::judgeCircle(string moves)&#123; vector&lt;int&gt; m(4);//L,R,U,D for (auto &amp;c : moves) &#123; if (c == 'L')m[0]++; else if (c == 'R')m[1]++; else if (c == 'U')m[2]++; else m[3]++; &#125; return (m[0] == m[1] &amp;&amp; m[2] == m[3]); //unordered_map&lt;char, int&gt;com; //for (auto &amp;c : moves)com[c]++; //return com['L'] == com['R'] &amp;&amp; com['U'] == com['D'];&#125; 尝试了一下注释掉的方法二runtime很差劲，可能是因为查找比较费时间 题目：804. Unique Morse Code Words描述：International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.For convenience, the full table for the 26 letters of the English alphabet is given below:1[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 例子：1234567891011Example:Input: words = ["gin", "zen", "gig", "msg"]Output: 2Explanation: The transformation of each word is:"gin" -&gt; "--...-.""zen" -&gt; "--...-.""gig" -&gt; "--...--.""msg" -&gt; "--...--."There are 2 different transformations, "--...-." and "--...--.". Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 代码：12345678910111213141516171819202122232425262728293031int Solution804::uniqueMorseRepresentations(vector&lt;string&gt;&amp; words)&#123; //int len = words.size(); //if (len &lt; 2)return len; //vector&lt;string&gt; map = &#123; ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.." &#125;; //set&lt;string&gt; compare; //for (string s : words) //&#123; // string temp = ""; // for (char c : s) // &#123; // temp += map[c - 'a']; // &#125; // //if (compare.find(temp) == compare.end()) // compare.insert(temp); //&#125; //return compare.size(); unordered_set&lt;string&gt; compare; for (string &amp;s : words) &#123; string temp; for (char &amp;c : s) &#123; temp += map[c - 'a']; &#125; //if (compare.find(temp) == compare.end()) compare.insert(temp); &#125; return compare.size();&#125; 注释掉的代码是我自己写的，下面的代码是看了runtime比较好的答案，经过对比多次提交比较得到一下几个猜想，有待验证： unordered_set优于set public定义compare优于函数内定义 compare前加上const关键字优于不加 for循环加上&amp;优于不加 set执行insert不需要提前判断集合中是否有该元素 temp不初始化不会报错，且优于初始化 结束更多内容请浏览我的csdn：小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩铅画2-向日葵]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%BD%A9%E9%93%85%E7%94%BB2-%E5%90%91%E6%97%A5%E8%91%B5%2F</url>
    <content type="text"><![CDATA[半年过去了，前段时间翻到了年初的朋友圈看下今年的flag：“2018no flag,多读书多看报，多点佛系情怀，多点珍惜，多点爱，还有就是培养一个新爱好”。这么简单的计划差点都被我搞砸，还有还有半年为期，那就爱好捡起来吧。 上次画画是几个月前看了几集《永恒的紫罗兰花园》，就画了里面邮递员的一个剪影；再上次是高考结束学习了半个月的素描，就是练习排线、投影、静物，画些苹果鸭梨啥的；再上次应该就是初中的时候，凭借一副人像拿了学校画展的二等奖，平时看课外书的时候画些书中的人物剪影。 从小我对色彩的掌握就比较弱，但是很有耐性，选择彩铅也没有什么特别的考究，只是彩铅的画法和素描很像，然后彩铅毁画不太容易，所以就开始了我的新爱好培养。 首先是先用自动铅笔构图，起始在构图的时候自己很小心，尽量不让比例失调，但是因为最初选定的落笔的地方选择了近景叶子而不是向日葵的根部，导致最后向日葵的底部比例有点失调，就把叶子全擦掉重新画的，所以定型原点很重要！还有一点就是在构图的时候有些高光明显的地方也画了边界，可以避免上色的时候不小心画错。 花瓣上色， 第一次尝试这种色调比较少的画，而且我的彩铅只有36色，担心自己的水平画不出来效果，所以一个花瓣一个花瓣开始画，没有采用大范围铺色调的方式，这也可能是我画得慢得原因吧。先用404打底，再铺一层407，留出高光得位置，再阴影得地方加深409，觉得色彩不够可以反复排线，开始排线得时候尽量轻，不然后面不好上色，在阴影比较重得地方适当加入487和478，有些黄得发红得地方加入414和416。 叶子上色，画花瓣得时候很累，画完花瓣差不多已经5个小时左右了，画叶子得时候才知道色彩对我得限制有多大，我的绿色色系只有5只，很难画出向日葵那种深绿得感觉，所以加了很多得480和499，先用463打底，浅涂，然后459加深，可以根据排线来自动调节每种颜色每个位置得深浅，这样能够显出立体得感觉，在阴影较重得地方用459和499、480反复图，绿里透着黑，黑里透着绿。 这是最后的图，不太满意的地方是花芯和近景的叶子，因为是对着图片临摹，没有近距离观察向日葵花芯的小花瓣的形状，不太会画这里，而且画到这里的时候我差不多已经坐着画了10个小时左右，有点累了画的比较随意，还有就是近景叶子我没有太看明白图片中的叶子是怎样分布的，根据阳光照射的向日葵的花瓣的高光分布没有推测出近景叶子是怎样达到花瓣的效果，所以感觉近景叶子的高光阴影有很大的问题，更多的内容请不吝指教~ 还有比较细节的地方是，在勾勒一些颜色交叉边缘阴影时根据阴影映射的颜色来压会比较自然，最后，这幅图用到的颜色：有些是画画中随性加的颜色，没有具体描述。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第18章 高级类型]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC18%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[18.1 单例类型 在下面的例子中book不能调用addChapter方法，因为setTitle方法返回的是this，Scala自动推断类型为Document。1234567891011121314151617class Document&#123; def setTitle(title:String) = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle("whatever").setAuthor("cay")class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle("scala") 修改方法如下：显式声明setTitle方法的返回类型是this.type 1234567891011121314151617class Document&#123; def setTitle(title:String):this.type = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle("whatever").setAuthor("cay")class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle("scala").addChapter("") 1234567object Title//单例对象class Document&#123; private var useNextArgAas:Any = null def set(obj:Title.type ):this.type = &#123;useNextArgAas = obj;this&#125; def to(arg:String) = if(useNextArgAas == Title) println(arg)&#125;book.set(Title).to("scala") 18.2 类型投影注意下一段代码中的NetWork#Member操作，说明在NetWork中共享Member类 12345678910111213141516class NetWork&#123; class Member(val name:String)&#123; val contacts = new ArrayBuffer[NetWork#Member] &#125; private val members = new ArrayBuffer[Member]() def join(name:String) = &#123; val m = new Member(name) members += m m &#125;&#125;val chatter:NetWork = new NetWorkval myFace:NetWork = new NetWorkval fred :chatter.Member= chatter.join("fred")val barney :myFace.Member= myFace.join("barney")fred.contacts += barney 18.4 类型别名类型别名必须出现在类或者对象中，不能出现在Scala文件的顶层123type Index = mutable.HashMap[String,(Int,Int)]val a :Index = new Index()a.put("a",(1,2)) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第17章-类型参数]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC17%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[17.1 泛型类 12345class Pair[T,S](val first:T,val second:S)&#123; def printf() = println(first,second)&#125;val p = new Pair(42,"string")p.printf() 17.2 泛型函数12def getMiddle[T](a:Array[T]) = a.length / 2println(getMiddle(Array(4,"56"))) 17.3 类型变量界定12345class Pair[T &lt;: Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair("23","4")).smaller) 如果不在泛型中加入&lt;: Comparable[T]，则就不知道first是否有compareTo方法，所以添加一个上界T 《： Comparable[T] 但是在类型为Int的时候出现报错，在17.4节中介绍 12345class Pair[T](val first:T,val second:T)&#123; def printf() = println(first,second) def replaceFirst[R &gt;: T](newFirst:R) = new Pair[R](newFirst,second)&#125;(new Pair("23","4")).replaceFirst(0).printf() 17.4 视图界定在上一节中Int类型出现报错是因为Int不是Comparable[Int]的子类。不过RichInt实现了Comparable[Int],同时还有一个从Int到RichInt的隐式转换。解决方法是视图界定12345class Pair[T &lt;% Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair[Int](3,4)).smaller) &lt;%关系将T被隐式转换成Comparable[T] 用Ordered特质会更好，因为在Comparable的基础上提供了关系操作符1234class Pair[T &lt;% Ordered[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first &lt; second) first else second&#125; 17.5 上下文界定视图界定T &lt;% V要求必须存在一个从T到V的隐式转换。上下文界定的形式是T:M。要求必须存在一个类型为M[T]的隐式值，如1class Pair[T:Ordering] 要求必须存在一个类型为Ordering[T]的隐式值。当声明一个使用隐式值的方法时，需要添加一个隐式参数,比如ord 123class Pair[T:Ordering](val first:T,val second:T)&#123; def smaller(implicit ord:Ordering[T]) = if(ord.compare(first,second) &lt; 0) first else second&#125; 17.11 对象不能泛型不能给对象添加类型参数，比如可变列表 更多内容请见我的csdn:小可爱的博客]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-sort-easy-over]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-sort-easy-over%2F</url>
    <content type="text"><![CDATA[题目列表： 349 350 242 题目349：Intersection of Two Arrays描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order. 代码： 1234567891011121314vector&lt;int&gt; Solution349::intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; set&lt;int&gt;nums1_plus, nums2_plus; nums1_plus.insert(nums1.begin(), nums1.end());//因为集合是不区分元素位置的 nums2_plus.insert(nums2.begin(), nums2.end()); vector&lt;int&gt; res; int len1 = nums1_plus.size(); for (int x : nums1_plus) &#123; if (nums2_plus.find(x) != nums2_plus.end())res.push_back(x); &#125; return res;&#125; 题目350：Intersection of Two Arrays II描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.代码：123456789101112vector&lt;int&gt; Solution350::intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; unordered_map&lt;int, int&gt;nums1_plus, nums2_plus; for (int x : nums1)nums1_plus[x]++; for (int x : nums2)nums2_plus[x]++; vector&lt;int&gt; res; for (auto x : nums1_plus) &#123; if (nums2_plus.find(x.first) != nums2_plus.end())res.insert(res.end(), min(x.second, nums2_plus[x.first]), x.first); &#125; return res;&#125; 题目242： Valid Anagram描述：Given two strings s and t , write a function to determine if t is an anagram of s.例子： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false Note:You may assume the string contains only lowercase alphabets.代码：1234567891011121314151617181920212223242526272829bool Solution242::isAnagram(string s, string t)&#123; //way 1 //if (s.size() != t.size())return false; //unordered_map&lt;char, int&gt; s_plus, t_plus; //for (char x : s)s_plus[x]++; //for (char x : t)t_plus[x]++; //for (auto x : s_plus) //&#123; // if (t_plus.find(x.first) != t_plus.end()) // &#123; // if (x.second != t_plus[x.first]) return false; // &#125; // else // return false; //&#125; //return true; //way 2 if (s.size() != t.size()) return false; vector&lt;int&gt; flag(26);//将26个小写字母映射到对应数组下标，元素为每个字母出现的次数，初始值为0 for (char x : s) flag[x - 'a']++;//计算s字符串中每个字母出现的次数 for (char x : t) &#123; flag[x - 'a']--; if (flag[x - 'a'] &lt; 0)return false;//如果两个字符串等长，且不是变换顺序的话，t中一定存在某个字母数大于s &#125; return true;&#125; 在题目242中，第二种方法的runtime优于第一种方法，在非变换顺序的字符串中可以在遍历结束之前结束。 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骗子]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%AA%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我是一个骗子戴着虚伪的面具月亮与我高歌清风为我吹嘘谈笑风生心底住着秘密黑夜降临我来到另一个世界忧伤浸染自说着寂寞的秋的清愁]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第16章 XML处理]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC16%E7%AB%A0-XML%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这是一篇《快学scala》的读书笔记，需要具备Scala语言的基础，欢迎读者与我一起探讨，或者教我新知识呀~ 16.1 XML字面量Scala对xml有内建支持，直接用xml代码就行1234import scala.xml.Elemimport scala.xml.NodeBufferval doc:Elem = &lt;html&gt;&lt;head&gt;&lt;title&gt;Fred's&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;val item:NodeBuffer = &lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;wilma&lt;/li&gt; 16.2 XML节点Node类是所有XML节点类型的祖先，两个最重要的子类是Text和Elem。用child方法遍历父节点下面的每一个子节点 123val ls:Elem = &lt;a herf="www.baidu.com"&gt;the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child) println(x) 输出结果： 1234the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language 代码：123val ls:Elem = &lt;a herf="www.baidu.com"&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child if !x.child.isEmpty) println(x.child) 输出结果：12ArrayBuffer(&lt;li&gt;hello&lt;/li&gt;, scala)ArrayBuffer(yoyo) 通过变成的方式构建节点序列，可以使用NodeBuffer,是ArrayBuffer[Node]的子类，可以被隐式转换为NodeSeq，转换之后就不能再继续修改它，因为xml节点序列是不可变的 12345import scala.xml.&#123;Node, NodeSeq&#125;val items = new NodeBufferitems += &lt;li&gt;Fred&lt;/li&gt;items += &lt;li&gt;Wilma&lt;/li&gt;val nodes:NodeSeq = items 16.3 元素属性要处理某个元素的属性键和值，可以使用attributes属性,返回Option类型的节点序列1234val ls:Elem = &lt;a href="www.baidu.com"&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;val url: scala.Seq[Node] = ls.attributes("href")val url1:String= ls.attributes("href").textprintln(url1) 输出结果：www.baidu.com通过调用 text方法返回String类型结果,也可以通过下面的方法避免没有这个属性返回null的结果，如果没有返回空12val url2 = ls.attributes.get("alt").getOrElse(Text("")) println(url2) 遍历节点的所有属性：12345val elem1 = &lt;p class="nihao" type="wawa"&gt;&lt;/p&gt;for(attr &lt;- elem1.attributes) println(attr.key,attr.value.text)val map:Map[String,String] = elem1.attributes.asAttrMapprintln(map) 两种方式都可以遍历节点的所有属性，第一种方式的attr类型是MetaData，第二种方式返回的是键值对的map 16.4 内嵌表达式可以在xml字面量中包含Scala的代码块 123val items = List(2,3,5)val elem = &lt;ul&gt;&#123;for(i &lt;- items)yield &lt;li&gt;&#123;i&#125;&lt;/li&gt;&#125;&lt;/ul&gt;println(elem) 16.5 在属性中使用表达式可以用Scala表达式来计算属性值 123456val e = &lt;a id=&#123;new Atom[Int](1)&#125;&gt;&lt;/a&gt;println(e.attributes("id").text)val description = "TOD"val q = &lt;img alt=&#123;if(description == "TODO") null else description&#125;&gt;yolo&lt;/img&gt;println(q.attributes.get("alt").getOrElse(Text(""))) 16.8 模式匹配可以在模式匹配表达式中使用xml字面量 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println("img") case &lt;li&gt;&#123;v&#125;&lt;/li&gt; =&gt; println(v) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println("lala") case _ =&gt; println("")&#125;) 可以用下面的方式匹配文本12&lt;li&gt;&#123;Text(v)&#125;&lt;/li&gt; =&gt; v&lt;li&gt;v&lt;/li&gt; =&gt; v.text XML模式不能有属性，如果要匹配属性，需要用守卫 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li class="name"&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println("img") case n @ &lt;li&gt;&#123;_&#125;&lt;/li&gt; if (n.attributes("class").text == "name")=&gt; println(n) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println("lala") case _ =&gt; println("")&#125;) 16.9 修改元素和属性xml节点和节点序列是不可变的，如果要编辑一个节点，需要创建一个拷贝123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = "ol")println(list2) 结果输出：FredWilma 新旧两个列表的后代是共享的，要添加一个后代，可以像下面这样调用copy123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = "ol",child = list.child ++ &lt;li&gt;another&lt;/li&gt;)println(list2) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第15章 注解]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC15%E7%AB%A0-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[15.1 什么是注解 注解：插入到代码中以便有工具可以对他们进行处理的标签，工具可以在代码级别运作，也可以被编译器加入了注解信息的类文件 15.2 什么可以被注解可以为类、方法、字段、局部变量和参数添加注解12345@Entity class Credentials@Test def testSomeFeature()&#123;&#125;@BeanProperty var username = _def doSomething(@NotNull message:String)&#123;&#125;@BeanProperty @Id var username = _ 在给主构造器添加注解时，需要将注解放置在构造器之前，并加上一对圆括号 1class Credentials @Inject()&#123;var username:String,var password:String&#125; 可以为表达式添加注解，需要在表达式后加上冒号1(myMap.get(key):@unchecked) match &#123;...&#125; 还可以为类型参数添加注解：1class MyContainer[@specialized T] 针对实际类型的注解应放在类型名称之后1String @cps[Unit] 15.3 注解参数Java注解可以有带名参数，如果参数名是value，名称可以直接略去，如果注解不带参数，圆括号可以略去注解的参数类型只能是： 数值型的字面量 字符串 类字面量 Java枚举 其他注解 上述类型的数组 15.4 注解实现本节主要看下注解类是怎样实现的 注解必须扩展Annotation特质。 1class unchecked extends annotation.Annotation 注解的作用是描述那些被注解的表达式、变量、字段、方法或类型1def check(@NotNull password:String) = &#123;&#125; 好了，注解看到这里我放弃了，并看不懂……]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因吹斯听thing:我的博客网站]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9B%A0%E5%90%B9%E6%96%AF%E5%90%ACthing-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[之前就想过自己搭建一个博客网站，因为自己有记东西的习惯，简书+csdn+有道云，挺麻烦的，今天偶然知道了hexo，感觉这个东西很好，就尝试5分钟搭建，但是实际上不止5分钟呀，中间也遇到了问题，现把我的搭建过程做个记录。 原文链接：5分钟搭建免费个人博客 安装Hexo此步安装命令用的是下面的： 1npm install -g hexo-cli 安装成功之后,会提示hexo的安装目录。我在D盘下新建了Hexo文件夹，执行 1hexo init D:\Hexo 进入到该路径下，初始化网站存储的文件1hexo init username.github.io 根据链接的配置要求进行更改，进入到该文件夹下面1cd username.github.io 执行1hexo s 测试启动可以运行 注意事项： hexo的安装命令有很多，我第一遍安装失败了，遇到了hexo不是内部或外部命令 hexo的文档命名和内容格式 有一定的要求，按照下面的语法新建文档，再编辑新内容1hexo new "doc name" 总结今天学习到的命令 123hexo shexo new "doc name"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 要好好学习markdown的语法喽~]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学scala》学习笔记--第14章 模式匹配和样例类]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC14%E7%AB%A0%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[此篇文章针对有一定Scala基础的读者 14.1 更好的switch 123456val ch: Char = '*'ch match &#123; case '+' =&gt; println("加法") case '*' =&gt; println("乘法") case _ =&gt; println("木有")&#125; match是一个表达式，而不是语句，会有返回值 1234567val ch: Char = '*'val x:Int = ch match &#123; case '+' =&gt; 0 case '*' =&gt; 1 case _ =&gt; 2&#125;println(x) 14.2 守卫守卫可以是任何布尔条件，在下面的例子中，只有在守卫模式不能匹配的情况下才执行所有模式匹配 123456789val ch:Char = 3var sign:Int = 0ch match &#123; case '+' =&gt; println("++++") case '*' =&gt; println("====") case _ if ch &gt;= 0 &amp;&amp; ch &lt;= 9 =&gt; sign = ch case _ =&gt; println("---")&#125;println(sign) 14.3 模式中的变量case _ 是这种特性的特殊情况，变量名是 _ 12345678910val c: Char = '+'val ch:Char = 9var sign:Int = 0ch match &#123; case '+' =&gt; println("++++") case '*' =&gt; println("====") case c if c &gt;= 0 &amp;&amp; c &lt;= 9 =&gt; sign = c case _ =&gt; println("---")&#125;println(sign) 变量必须以小写字母开头 如果有一个小写字母开头的常量，则需要将它包在反引号中。 14.4 类型模式匹配列表中的每一个元素的类型，将每一个元素映射成 =&gt; 后面的 string 类型 1234567val ls = List(1,3,4,"one","two",4.5)val l = ls.map(_ match &#123; case x:Int =&gt; "int x:" + x case s:String =&gt; "string s:" + s case _ =&gt; "other"&#125;)l.foreach(println) 14.5 匹配组、列表和元组要匹配数组的内容，可以在模式中使用Array表达式, 1234567val arr1 = Array(Array(0),Array(3,4),Array(0,4,6),Array("fad","fff"))arr1.map(_ match &#123; case Array(0) =&gt; println(0) case Array(x,y) =&gt; println(x,y) case Array(0,_*) =&gt; println("...")//_*符号匹配数组中余下的内容 case _ =&gt; println("something")&#125;) 匹配列表中的元素 12345678val ls = List(List(0),List(3,4),List(0,4,5),List("fa","aaa","tttt"))ls.map(_ match &#123; case 0::Nil =&gt; println(0) case x :: y :: Nil =&gt; println(x,y) case 0 :: tail =&gt; println(tail.foreach(println)) case x :: tail =&gt; println("====") case _ =&gt; println("something")&#125;) 匹配元组 123456val ls = List((0,4),("fa",0),(3,4))ls.map(_ match &#123; case (0,_) =&gt; println(0) case (x,y) =&gt; println(x,y) case _ =&gt; println("something")&#125;) 14.6 提取器前一节中匹配数组、列表和元素的功能是依靠提取器实现的 ==提取器机制==：带有从对象中提取值得unapply和unapplySeq方法得对象。unapply提取固定数量得对象，而unapplySeq提取得是一个序列 1Array.unapplySeq(arr) 产出一个序列的值。 14.8 for表达式中的模式123val ls = List((1,2),(3,4),(4,5))for ((k,v) &lt;- ls if k % 2 == 1) println(k,v) 14.9 样例类可以用模式匹配来匹配样例类，并将属性值绑定到变量 12345678910case class Dollar(value:Double)case class Currency(value:Double,unit:String)case object Yuanval ls = List(Dollar(2.3),Currency(4.5,"10"),Yuan)ls.map(_ match &#123; case Dollar(v) =&gt; println(s"Dollar:$v") case Currency(_,u) =&gt; println(s"got $u") case Yuan =&gt; println("lalala") case _ =&gt; println("----")&#125;) 样例类实例使用(),样例对象不适用圆括号 ==声明样例类的时候有如下几件事自动发生：== 构造器中的每一个参数都成为val，除非被显式地声明为var 在伴生对象中提供apply方法，可以不用new关键字就能构造出相应的对象，比如Dollar(2.3) 提供unapply方法让模式匹配可以工作 将生成toString,equals,copy方法，除非显式给出定义 14.10 copy方法和带名参数copy方法创建一个与现有对象值相同的新对象，可以用带名参数修改某些属性 1234val amt = Currency(34.2,"RUR")val price = amt.copy()val price1 = amt.copy(value = 13)val price2 = amt.copy(unit = "CHF") 14.11 case语句中的中置表示法如果unapply方法产出一个对偶，可以在case语句中使用中置表示法，19章将会看到将解析结果组合在一起的~样例类: 1result match &#123;case p ~ q =&gt; ...&#125; //等同于case ~(p,q) 如果操作符以冒号结尾，则他是从右向左结合的 中置表示法可以用于任何返回对偶的unapply方法： 1234567case object +: &#123; def unapply[T](input: List[T]):Option[(T,List[T])] = if(input.isEmpty) None else Some((input.head,input.tail))&#125;1+:7+:2+:Nil match &#123; case first +: second +: rest =&gt; println(first + second + rest.length)&#125; 14.12 匹配嵌套结构三个样例类继承Item抽象类，Bundle和Boolean类嵌套Article和Bundle样例类，可以用@表示法将嵌套的值绑定到变量 12345678910111213abstract class Itemcase class Article(desc:String,price:Double) extends Item//继承同一个抽象类case class Bundle(desc:String,discount:Double,item:Item) extends Itemval peak = Bundle("Father's Day is special",20.0,Article("scala is nice",45.5))case class Boolean(desc:String,dis:Double,item:Item*)//Item抽象类列表val amt = Boolean("great",23.3,Bundle("nice",45.4,Article("wonderful",45.4)),Article("scala is nice",45.5))val ls = List(peak,amt)ls.map(_ match &#123; case Bundle(_,_,Article(desc,price)) =&gt; println(s"bundle $&#123;desc&#125;:$&#123;price&#125;") case Boolean(_,_,art @ Bundle(_,_,_),rest @ _*) =&gt; println(s"boolean $&#123;art.desc&#125;:$&#123;art.discount&#125;,$&#123;rest.head&#125;") case Boolean(_,_,art @ Bundle(_,_,_),rest) =&gt; println(s"boolean $&#123;art.desc&#125;")//匹配继承Item抽象类的元素只有两个 case _ =&gt; println("None")&#125;) 14.14 密封类当用样例类来做模式匹配的时候，想让编译器帮助确保已经列出了所有可能的选择，要达到这个目的，需要将样例类的通用超类声明为sealed 密封类的所有子类都必须在与该密封类相同的文件中定义。 如果某个类是密封的，那么在编译期所有子类就是可知的，因此==编译器可以检查模式语句的完整性==，让同一组样例类都扩展自某个密封的类或者特质是一个好的做法 12345678910sealed abstract class Amountcase class Red(bottom:Double) extends Amountcase object Green extends Amountcase object Gray extends Amountval color:Amount = Red(3.4)//需要显式声明color的类型，不然就会变成Redcolor match &#123; case Red(_) =&gt; println("red") case Green =&gt;println("green") case Gray =&gt; println("fad")&#125; 14.16 Option类型标准类库的Option类型用样例类来表示那种可能存在，也可能不存在的值。这比空字符串更加清晰，比null做法更加安全。 map类的get方法返回一个Option。如果对于给定的键没有对应的值，则get返回None，如果有值，该值包在Some中返回 请以不要直接使用get方法，返回None的情况可能会使程序死掉，尽量用getOrElse Option[+A]密封抽象类，Some和None继承Option类 14.17 偏函数被包括在花括号内的一组case语句是一个偏函数——==并非对所有输入值都有定义的函数==。它是PartialFunction[A,B]类的一个实例，该类有两个方法：apply方法从匹配到的模式计算函数值，而isDefinedAt方法在输入至少匹配其中一个模式时返回true 1234567val f:PartialFunction[Char,Int] = &#123; case '+' =&gt; 1 case '-' =&gt; -1&#125;println(f('+'))//1//println(f('0'))//errorprintln(f.isDefinedAt('0'))//false]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远方]]></title>
    <url>%2F2018%2F07%2F25%2F%E8%BF%9C%E6%96%B9%2F</url>
    <content type="text"><![CDATA[期盼着远方思念着家乡我有一个姑娘我有一个姑娘舍不得家乡牵挂着远方]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我邮人缚苍龙]]></title>
    <url>%2F2014%2F12%2F01%2F%E7%9C%8B%E6%88%91%E9%82%AE%E4%BA%BA%E7%BC%9A%E8%8B%8D%E9%BE%99%2F</url>
    <content type="text"><![CDATA[芳草垂柳梧桐秀心唤帝都今重又汗洒昌平夜如昼群峰含笑送清秋戎装飒爽为北邮天地苍茫出浩宇看我邮人缚苍龙]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训1]]></title>
    <url>%2F2014%2F12%2F01%2F%E5%86%9B%E8%AE%AD1%2F</url>
    <content type="text"><![CDATA[黄沙不见烈日炎，碧云天，晓风怨。飒爽英姿，真是个超然。勿让云雨匆匆散，月夜下，欢歌连。闲适风景时时盼，舞翩翩，望不断。舟叶水源，回首泪涟涟。待到君心换我心，垂柳下，戎装前。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
