<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[彩铅画2-向日葵]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%BD%A9%E9%93%85%E7%94%BB2-%E5%90%91%E6%97%A5%E8%91%B5%2F</url>
    <content type="text"><![CDATA[半年过去了，前段时间翻到了年初的朋友圈看下今年的flag：“2018no flag,多读书多看报，多点佛系情怀，多点珍惜，多点爱，还有就是培养一个新爱好”。这么简单的计划差点都被我搞砸，还有还有半年为期，那就爱好捡起来吧。 上次画画是几个月前看了几集《永恒的紫罗兰花园》，就画了里面邮递员的一个剪影；再上次是高考结束学习了半个月的素描，就是练习排线、投影、静物，画些苹果鸭梨啥的；再上次应该就是初中的时候，凭借一副人像拿了学校画展的二等奖，平时看课外书的时候画些书中的人物剪影。 从小我对色彩的掌握就比较弱，但是很有耐性，选择彩铅也没有什么特别的考究，只是彩铅的画法和素描很像，然后彩铅毁画不太容易，所以就开始了我的新爱好培养。 首先是先用自动铅笔构图，起始在构图的时候自己很小心，尽量不让比例失调，但是因为最初选定的落笔的地方选择了近景叶子而不是向日葵的根部，导致最后向日葵的底部比例有点失调，就把叶子全擦掉重新画的，所以定型原点很重要！还有一点就是在构图的时候有些高光明显的地方也画了边界，可以避免上色的时候不小心画错。 花瓣上色， 第一次尝试这种色调比较少的画，而且我的彩铅只有36色，担心自己的水平画不出来效果，所以一个花瓣一个花瓣开始画，没有采用大范围铺色调的方式，这也可能是我画得慢得原因吧。先用404打底，再铺一层407，留出高光得位置，再阴影得地方加深409，觉得色彩不够可以反复排线，开始排线得时候尽量轻，不然后面不好上色，在阴影比较重得地方适当加入487和478，有些黄得发红得地方加入414和416。 叶子上色，画花瓣得时候很累，画完花瓣差不多已经5个小时左右了，画叶子得时候才知道色彩对我得限制有多大，我的绿色色系只有5只，很难画出向日葵那种深绿得感觉，所以加了很多得480和499，先用463打底，浅涂，然后459加深，可以根据排线来自动调节每种颜色每个位置得深浅，这样能够显出立体得感觉，在阴影较重得地方用459和499、480反复图，绿里透着黑，黑里透着绿。 这是最后的图，不太满意的地方是花芯和近景的叶子，因为是对着图片临摹，没有近距离观察向日葵花芯的小花瓣的形状，不太会画这里，而且画到这里的时候我差不多已经坐着画了10个小时左右，有点累了画的比较随意，还有就是近景叶子我没有太看明白图片中的叶子是怎样分布的，根据阳光照射的向日葵的花瓣的高光分布没有推测出近景叶子是怎样达到花瓣的效果，所以感觉近景叶子的高光阴影有很大的问题，更多的内容请不吝指教~ 还有比较细节的地方是，在勾勒一些颜色交叉边缘阴影时根据阴影映射的颜色来压会比较自然，最后，这幅图用到的颜色：有些是画画中随性加的颜色，没有具体描述。]]></content>
      <categories>
        <category>绘画</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第18章 高级类型]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC18%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[18.1 单例类型 在下面的例子中book不能调用addChapter方法，因为setTitle方法返回的是this，Scala自动推断类型为Document。1234567891011121314151617class Document&#123; def setTitle(title:String) = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle(&quot;whatever&quot;).setAuthor(&quot;cay&quot;)class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle(&quot;scala&quot;) 修改方法如下：显式声明setTitle方法的返回类型是this.type 1234567891011121314151617class Document&#123; def setTitle(title:String):this.type = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle(&quot;whatever&quot;).setAuthor(&quot;cay&quot;)class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle(&quot;scala&quot;).addChapter(&quot;&quot;) 1234567object Title//单例对象class Document&#123; private var useNextArgAas:Any = null def set(obj:Title.type ):this.type = &#123;useNextArgAas = obj;this&#125; def to(arg:String) = if(useNextArgAas == Title) println(arg)&#125;book.set(Title).to(&quot;scala&quot;) 18.2 类型投影注意下一段代码中的NetWork#Member操作，说明在NetWork中共享Member类 12345678910111213141516class NetWork&#123; class Member(val name:String)&#123; val contacts = new ArrayBuffer[NetWork#Member] &#125; private val members = new ArrayBuffer[Member]() def join(name:String) = &#123; val m = new Member(name) members += m m &#125;&#125;val chatter:NetWork = new NetWorkval myFace:NetWork = new NetWorkval fred :chatter.Member= chatter.join(&quot;fred&quot;)val barney :myFace.Member= myFace.join(&quot;barney&quot;)fred.contacts += barney 18.4 类型别名类型别名必须出现在类或者对象中，不能出现在Scala文件的顶层123type Index = mutable.HashMap[String,(Int,Int)]val a :Index = new Index()a.put(&quot;a&quot;,(1,2)) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第17章-类型参数]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC17%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[17.1 泛型类 12345class Pair[T,S](val first:T,val second:S)&#123; def printf() = println(first,second)&#125;val p = new Pair(42,&quot;string&quot;)p.printf() 17.2 泛型函数12def getMiddle[T](a:Array[T]) = a.length / 2println(getMiddle(Array(4,&quot;56&quot;))) 17.3 类型变量界定12345class Pair[T &lt;: Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair(&quot;23&quot;,&quot;4&quot;)).smaller) 如果不在泛型中加入&lt;: Comparable[T]，则就不知道first是否有compareTo方法，所以添加一个上界T 《： Comparable[T] 但是在类型为Int的时候出现报错，在17.4节中介绍 12345class Pair[T](val first:T,val second:T)&#123; def printf() = println(first,second) def replaceFirst[R &gt;: T](newFirst:R) = new Pair[R](newFirst,second)&#125;(new Pair(&quot;23&quot;,&quot;4&quot;)).replaceFirst(0).printf() 17.4 视图界定在上一节中Int类型出现报错是因为Int不是Comparable[Int]的子类。不过RichInt实现了Comparable[Int],同时还有一个从Int到RichInt的隐式转换。解决方法是视图界定12345class Pair[T &lt;% Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair[Int](3,4)).smaller) &lt;%关系将T被隐式转换成Comparable[T] 用Ordered特质会更好，因为在Comparable的基础上提供了关系操作符1234class Pair[T &lt;% Ordered[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first &lt; second) first else second&#125; 17.5 上下文界定视图界定T &lt;% V要求必须存在一个从T到V的隐式转换。上下文界定的形式是T:M。要求必须存在一个类型为M[T]的隐式值，如1class Pair[T:Ordering] 要求必须存在一个类型为Ordering[T]的隐式值。当声明一个使用隐式值的方法时，需要添加一个隐式参数,比如ord 123class Pair[T:Ordering](val first:T,val second:T)&#123; def smaller(implicit ord:Ordering[T]) = if(ord.compare(first,second) &lt; 0) first else second&#125; 17.11 对象不能泛型不能给对象添加类型参数，比如可变列表 更多内容请见我的csdn:小可爱的博客]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-sort-easy-over]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-sort-easy-over%2F</url>
    <content type="text"><![CDATA[题目列表： 349 350 242 题目349：Intersection of Two Arrays描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order. 代码： 1234567891011121314vector&lt;int&gt; Solution349::intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; set&lt;int&gt;nums1_plus, nums2_plus; nums1_plus.insert(nums1.begin(), nums1.end());//因为集合是不区分元素位置的 nums2_plus.insert(nums2.begin(), nums2.end()); vector&lt;int&gt; res; int len1 = nums1_plus.size(); for (int x : nums1_plus) &#123; if (nums2_plus.find(x) != nums2_plus.end())res.push_back(x); &#125; return res;&#125; 题目350：Intersection of Two Arrays II描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.代码：123456789101112vector&lt;int&gt; Solution350::intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; unordered_map&lt;int, int&gt;nums1_plus, nums2_plus; for (int x : nums1)nums1_plus[x]++; for (int x : nums2)nums2_plus[x]++; vector&lt;int&gt; res; for (auto x : nums1_plus) &#123; if (nums2_plus.find(x.first) != nums2_plus.end())res.insert(res.end(), min(x.second, nums2_plus[x.first]), x.first); &#125; return res;&#125; 题目242： Valid Anagram描述：Given two strings s and t , write a function to determine if t is an anagram of s.例子： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false Note:You may assume the string contains only lowercase alphabets.代码：1234567891011121314151617181920212223242526272829bool Solution242::isAnagram(string s, string t)&#123; //way 1 //if (s.size() != t.size())return false; //unordered_map&lt;char, int&gt; s_plus, t_plus; //for (char x : s)s_plus[x]++; //for (char x : t)t_plus[x]++; //for (auto x : s_plus) //&#123; // if (t_plus.find(x.first) != t_plus.end()) // &#123; // if (x.second != t_plus[x.first]) return false; // &#125; // else // return false; //&#125; //return true; //way 2 if (s.size() != t.size()) return false; vector&lt;int&gt; flag(26);//将26个小写字母映射到对应数组下标，元素为每个字母出现的次数，初始值为0 for (char x : s) flag[x - &apos;a&apos;]++;//计算s字符串中每个字母出现的次数 for (char x : t) &#123; flag[x - &apos;a&apos;]--; if (flag[x - &apos;a&apos;] &lt; 0)return false;//如果两个字符串等长，且不是变换顺序的话，t中一定存在某个字母数大于s &#125; return true;&#125; 在题目242中，第二种方法的runtime优于第一种方法，在非变换顺序的字符串中可以在遍历结束之前结束。 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骗子]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%AA%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我是一个骗子戴着虚伪的面具月亮与我高歌清风为我吹嘘谈笑风生心底住着秘密黑夜降临我来到另一个世界忧伤浸染自说着寂寞的秋的清愁]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第16章 XML处理]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC16%E7%AB%A0-XML%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这是一篇《快学scala》的读书笔记，需要具备Scala语言的基础，欢迎读者与我一起探讨，或者教我新知识呀~ 16.1 XML字面量Scala对xml有内建支持，直接用xml代码就行1234import scala.xml.Elemimport scala.xml.NodeBufferval doc:Elem = &lt;html&gt;&lt;head&gt;&lt;title&gt;Fred&apos;s&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;val item:NodeBuffer = &lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;wilma&lt;/li&gt; 16.2 XML节点Node类是所有XML节点类型的祖先，两个最重要的子类是Text和Elem。用child方法遍历父节点下面的每一个子节点 123val ls:Elem = &lt;a herf=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child) println(x) 输出结果： 1234the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language 代码：123val ls:Elem = &lt;a herf=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child if !x.child.isEmpty) println(x.child) 输出结果：12ArrayBuffer(&lt;li&gt;hello&lt;/li&gt;, scala)ArrayBuffer(yoyo) 通过变成的方式构建节点序列，可以使用NodeBuffer,是ArrayBuffer[Node]的子类，可以被隐式转换为NodeSeq，转换之后就不能再继续修改它，因为xml节点序列是不可变的 12345import scala.xml.&#123;Node, NodeSeq&#125;val items = new NodeBufferitems += &lt;li&gt;Fred&lt;/li&gt;items += &lt;li&gt;Wilma&lt;/li&gt;val nodes:NodeSeq = items 16.3 元素属性要处理某个元素的属性键和值，可以使用attributes属性,返回Option类型的节点序列1234val ls:Elem = &lt;a href=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;val url: scala.Seq[Node] = ls.attributes(&quot;href&quot;)val url1:String= ls.attributes(&quot;href&quot;).textprintln(url1) 输出结果：www.baidu.com通过调用 text方法返回String类型结果,也可以通过下面的方法避免没有这个属性返回null的结果，如果没有返回空12val url2 = ls.attributes.get(&quot;alt&quot;).getOrElse(Text(&quot;&quot;)) println(url2) 遍历节点的所有属性：12345val elem1 = &lt;p class=&quot;nihao&quot; type=&quot;wawa&quot;&gt;&lt;/p&gt;for(attr &lt;- elem1.attributes) println(attr.key,attr.value.text)val map:Map[String,String] = elem1.attributes.asAttrMapprintln(map) 两种方式都可以遍历节点的所有属性，第一种方式的attr类型是MetaData，第二种方式返回的是键值对的map 16.4 内嵌表达式可以在xml字面量中包含Scala的代码块 123val items = List(2,3,5)val elem = &lt;ul&gt;&#123;for(i &lt;- items)yield &lt;li&gt;&#123;i&#125;&lt;/li&gt;&#125;&lt;/ul&gt;println(elem) 16.5 在属性中使用表达式可以用Scala表达式来计算属性值 123456val e = &lt;a id=&#123;new Atom[Int](1)&#125;&gt;&lt;/a&gt;println(e.attributes(&quot;id&quot;).text)val description = &quot;TOD&quot;val q = &lt;img alt=&#123;if(description == &quot;TODO&quot;) null else description&#125;&gt;yolo&lt;/img&gt;println(q.attributes.get(&quot;alt&quot;).getOrElse(Text(&quot;&quot;))) 16.8 模式匹配可以在模式匹配表达式中使用xml字面量 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println(&quot;img&quot;) case &lt;li&gt;&#123;v&#125;&lt;/li&gt; =&gt; println(v) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println(&quot;lala&quot;) case _ =&gt; println(&quot;&quot;)&#125;) 可以用下面的方式匹配文本12&lt;li&gt;&#123;Text(v)&#125;&lt;/li&gt; =&gt; v&lt;li&gt;v&lt;/li&gt; =&gt; v.text XML模式不能有属性，如果要匹配属性，需要用守卫 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li class=&quot;name&quot;&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println(&quot;img&quot;) case n @ &lt;li&gt;&#123;_&#125;&lt;/li&gt; if (n.attributes(&quot;class&quot;).text == &quot;name&quot;)=&gt; println(n) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println(&quot;lala&quot;) case _ =&gt; println(&quot;&quot;)&#125;) 16.9 修改元素和属性xml节点和节点序列是不可变的，如果要编辑一个节点，需要创建一个拷贝123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = &quot;ol&quot;)println(list2) 结果输出：FredWilma 新旧两个列表的后代是共享的，要添加一个后代，可以像下面这样调用copy123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = &quot;ol&quot;,child = list.child ++ &lt;li&gt;another&lt;/li&gt;)println(list2) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第15章 注解]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC15%E7%AB%A0-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[15.1 什么是注解 注解：插入到代码中以便有工具可以对他们进行处理的标签，工具可以在代码级别运作，也可以被编译器加入了注解信息的类文件 15.2 什么可以被注解可以为类、方法、字段、局部变量和参数添加注解12345@Entity class Credentials@Test def testSomeFeature()&#123;&#125;@BeanProperty var username = _def doSomething(@NotNull message:String)&#123;&#125;@BeanProperty @Id var username = _ 在给主构造器添加注解时，需要将注解放置在构造器之前，并加上一对圆括号 1class Credentials @Inject()&#123;var username:String,var password:String&#125; 可以为表达式添加注解，需要在表达式后加上冒号1(myMap.get(key):@unchecked) match &#123;...&#125; 还可以为类型参数添加注解：1class MyContainer[@specialized T] 针对实际类型的注解应放在类型名称之后1String @cps[Unit] 15.3 注解参数Java注解可以有带名参数，如果参数名是value，名称可以直接略去，如果注解不带参数，圆括号可以略去注解的参数类型只能是： 数值型的字面量 字符串 类字面量 Java枚举 其他注解 上述类型的数组 15.4 注解实现本节主要看下注解类是怎样实现的 注解必须扩展Annotation特质。 1class unchecked extends annotation.Annotation 注解的作用是描述那些被注解的表达式、变量、字段、方法或类型1def check(@NotNull password:String) = &#123;&#125; 好了，注解看到这里我放弃了，并看不懂……]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因吹斯听thing:我的博客网站]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9B%A0%E5%90%B9%E6%96%AF%E5%90%ACthing-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[之前就想过自己搭建一个博客网站，因为自己有记东西的习惯，简书+csdn+有道云，挺麻烦的，今天偶然知道了hexo，感觉这个东西很好，就尝试5分钟搭建，但是实际上不止5分钟呀，中间也遇到了问题，现把我的搭建过程做个记录。 原文链接：5分钟搭建免费个人博客 安装Hexo此步安装命令用的是下面的： 1npm install -g hexo-cli 安装成功之后,会提示hexo的安装目录。我在D盘下新建了Hexo文件夹，执行 1hexo init D:\Hexo 进入到该路径下，初始化网站存储的文件1hexo init username.github.io 根据链接的配置要求进行更改，进入到该文件夹下面1cd username.github.io 执行1hexo s 测试启动可以运行 注意事项： hexo的安装命令有很多，我第一遍安装失败了，遇到了hexo不是内部或外部命令 hexo的文档命名和内容格式 有一定的要求，按照下面的语法新建文档，再编辑新内容1hexo new &quot;doc name&quot; 总结今天学习到的命令 123hexo shexo new &quot;doc name&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 要好好学习markdown的语法喽~]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学scala》学习笔记--第14章 模式匹配和样例类]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC14%E7%AB%A0%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[此篇文章针对有一定Scala基础的读者 14.1 更好的switch 123456val ch: Char = &apos;*&apos;ch match &#123; case &apos;+&apos; =&gt; println(&quot;加法&quot;) case &apos;*&apos; =&gt; println(&quot;乘法&quot;) case _ =&gt; println(&quot;木有&quot;)&#125; match是一个表达式，而不是语句，会有返回值 1234567val ch: Char = &apos;*&apos;val x:Int = ch match &#123; case &apos;+&apos; =&gt; 0 case &apos;*&apos; =&gt; 1 case _ =&gt; 2&#125;println(x) 14.2 守卫守卫可以是任何布尔条件，在下面的例子中，只有在守卫模式不能匹配的情况下才执行所有模式匹配 123456789val ch:Char = 3var sign:Int = 0ch match &#123; case &apos;+&apos; =&gt; println(&quot;++++&quot;) case &apos;*&apos; =&gt; println(&quot;====&quot;) case _ if ch &gt;= 0 &amp;&amp; ch &lt;= 9 =&gt; sign = ch case _ =&gt; println(&quot;---&quot;)&#125;println(sign) 14.3 模式中的变量case _ 是这种特性的特殊情况，变量名是 _ 12345678910val c: Char = &apos;+&apos;val ch:Char = 9var sign:Int = 0ch match &#123; case &apos;+&apos; =&gt; println(&quot;++++&quot;) case &apos;*&apos; =&gt; println(&quot;====&quot;) case c if c &gt;= 0 &amp;&amp; c &lt;= 9 =&gt; sign = c case _ =&gt; println(&quot;---&quot;)&#125;println(sign) 变量必须以小写字母开头 如果有一个小写字母开头的常量，则需要将它包在反引号中。 14.4 类型模式匹配列表中的每一个元素的类型，将每一个元素映射成 =&gt; 后面的 string 类型 1234567val ls = List(1,3,4,&quot;one&quot;,&quot;two&quot;,4.5)val l = ls.map(_ match &#123; case x:Int =&gt; &quot;int x:&quot; + x case s:String =&gt; &quot;string s:&quot; + s case _ =&gt; &quot;other&quot;&#125;)l.foreach(println) 14.5 匹配组、列表和元组要匹配数组的内容，可以在模式中使用Array表达式, 1234567val arr1 = Array(Array(0),Array(3,4),Array(0,4,6),Array(&quot;fad&quot;,&quot;fff&quot;))arr1.map(_ match &#123; case Array(0) =&gt; println(0) case Array(x,y) =&gt; println(x,y) case Array(0,_*) =&gt; println(&quot;...&quot;)//_*符号匹配数组中余下的内容 case _ =&gt; println(&quot;something&quot;)&#125;) 匹配列表中的元素 12345678val ls = List(List(0),List(3,4),List(0,4,5),List(&quot;fa&quot;,&quot;aaa&quot;,&quot;tttt&quot;))ls.map(_ match &#123; case 0::Nil =&gt; println(0) case x :: y :: Nil =&gt; println(x,y) case 0 :: tail =&gt; println(tail.foreach(println)) case x :: tail =&gt; println(&quot;====&quot;) case _ =&gt; println(&quot;something&quot;)&#125;) 匹配元组 123456val ls = List((0,4),(&quot;fa&quot;,0),(3,4))ls.map(_ match &#123; case (0,_) =&gt; println(0) case (x,y) =&gt; println(x,y) case _ =&gt; println(&quot;something&quot;)&#125;) 14.6 提取器前一节中匹配数组、列表和元素的功能是依靠提取器实现的 ==提取器机制==：带有从对象中提取值得unapply和unapplySeq方法得对象。unapply提取固定数量得对象，而unapplySeq提取得是一个序列 1Array.unapplySeq(arr) 产出一个序列的值。 14.8 for表达式中的模式123val ls = List((1,2),(3,4),(4,5))for ((k,v) &lt;- ls if k % 2 == 1) println(k,v) 14.9 样例类可以用模式匹配来匹配样例类，并将属性值绑定到变量 12345678910case class Dollar(value:Double)case class Currency(value:Double,unit:String)case object Yuanval ls = List(Dollar(2.3),Currency(4.5,&quot;10&quot;),Yuan)ls.map(_ match &#123; case Dollar(v) =&gt; println(s&quot;Dollar:$v&quot;) case Currency(_,u) =&gt; println(s&quot;got $u&quot;) case Yuan =&gt; println(&quot;lalala&quot;) case _ =&gt; println(&quot;----&quot;)&#125;) 样例类实例使用(),样例对象不适用圆括号 ==声明样例类的时候有如下几件事自动发生：== 构造器中的每一个参数都成为val，除非被显式地声明为var 在伴生对象中提供apply方法，可以不用new关键字就能构造出相应的对象，比如Dollar(2.3) 提供unapply方法让模式匹配可以工作 将生成toString,equals,copy方法，除非显式给出定义 14.10 copy方法和带名参数copy方法创建一个与现有对象值相同的新对象，可以用带名参数修改某些属性 1234val amt = Currency(34.2,&quot;RUR&quot;)val price = amt.copy()val price1 = amt.copy(value = 13)val price2 = amt.copy(unit = &quot;CHF&quot;) 14.11 case语句中的中置表示法如果unapply方法产出一个对偶，可以在case语句中使用中置表示法，19章将会看到将解析结果组合在一起的~样例类: 1result match &#123;case p ~ q =&gt; ...&#125; //等同于case ~(p,q) 如果操作符以冒号结尾，则他是从右向左结合的 中置表示法可以用于任何返回对偶的unapply方法： 1234567case object +: &#123; def unapply[T](input: List[T]):Option[(T,List[T])] = if(input.isEmpty) None else Some((input.head,input.tail))&#125;1+:7+:2+:Nil match &#123; case first +: second +: rest =&gt; println(first + second + rest.length)&#125; 14.12 匹配嵌套结构三个样例类继承Item抽象类，Bundle和Boolean类嵌套Article和Bundle样例类，可以用@表示法将嵌套的值绑定到变量 12345678910111213abstract class Itemcase class Article(desc:String,price:Double) extends Item//继承同一个抽象类case class Bundle(desc:String,discount:Double,item:Item) extends Itemval peak = Bundle(&quot;Father&apos;s Day is special&quot;,20.0,Article(&quot;scala is nice&quot;,45.5))case class Boolean(desc:String,dis:Double,item:Item*)//Item抽象类列表val amt = Boolean(&quot;great&quot;,23.3,Bundle(&quot;nice&quot;,45.4,Article(&quot;wonderful&quot;,45.4)),Article(&quot;scala is nice&quot;,45.5))val ls = List(peak,amt)ls.map(_ match &#123; case Bundle(_,_,Article(desc,price)) =&gt; println(s&quot;bundle $&#123;desc&#125;:$&#123;price&#125;&quot;) case Boolean(_,_,art @ Bundle(_,_,_),rest @ _*) =&gt; println(s&quot;boolean $&#123;art.desc&#125;:$&#123;art.discount&#125;,$&#123;rest.head&#125;&quot;) case Boolean(_,_,art @ Bundle(_,_,_),rest) =&gt; println(s&quot;boolean $&#123;art.desc&#125;&quot;)//匹配继承Item抽象类的元素只有两个 case _ =&gt; println(&quot;None&quot;)&#125;) 14.14 密封类当用样例类来做模式匹配的时候，想让编译器帮助确保已经列出了所有可能的选择，要达到这个目的，需要将样例类的通用超类声明为sealed 密封类的所有子类都必须在与该密封类相同的文件中定义。 如果某个类是密封的，那么在编译期所有子类就是可知的，因此==编译器可以检查模式语句的完整性==，让同一组样例类都扩展自某个密封的类或者特质是一个好的做法 12345678910sealed abstract class Amountcase class Red(bottom:Double) extends Amountcase object Green extends Amountcase object Gray extends Amountval color:Amount = Red(3.4)//需要显式声明color的类型，不然就会变成Redcolor match &#123; case Red(_) =&gt; println(&quot;red&quot;) case Green =&gt;println(&quot;green&quot;) case Gray =&gt; println(&quot;fad&quot;)&#125; 14.16 Option类型标准类库的Option类型用样例类来表示那种可能存在，也可能不存在的值。这比空字符串更加清晰，比null做法更加安全。 map类的get方法返回一个Option。如果对于给定的键没有对应的值，则get返回None，如果有值，该值包在Some中返回 请以不要直接使用get方法，返回None的情况可能会使程序死掉，尽量用getOrElse Option[+A]密封抽象类，Some和None继承Option类 14.17 偏函数被包括在花括号内的一组case语句是一个偏函数——==并非对所有输入值都有定义的函数==。它是PartialFunction[A,B]类的一个实例，该类有两个方法：apply方法从匹配到的模式计算函数值，而isDefinedAt方法在输入至少匹配其中一个模式时返回true 1234567val f:PartialFunction[Char,Int] = &#123; case &apos;+&apos; =&gt; 1 case &apos;-&apos; =&gt; -1&#125;println(f(&apos;+&apos;))//1//println(f(&apos;0&apos;))//errorprintln(f.isDefinedAt(&apos;0&apos;))//false]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远方]]></title>
    <url>%2F2018%2F07%2F25%2F%E8%BF%9C%E6%96%B9%2F</url>
    <content type="text"><![CDATA[期盼着远方思念着家乡我有一个姑娘我有一个姑娘舍不得家乡牵挂着远方]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我邮人缚苍龙]]></title>
    <url>%2F2014%2F12%2F01%2F%E7%9C%8B%E6%88%91%E9%82%AE%E4%BA%BA%E7%BC%9A%E8%8B%8D%E9%BE%99%2F</url>
    <content type="text"><![CDATA[芳草垂柳梧桐秀心唤帝都今重又汗洒昌平夜如昼群峰含笑送清秋戎装飒爽为北邮天地苍茫出浩宇看我邮人缚苍龙]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训1]]></title>
    <url>%2F2014%2F12%2F01%2F%E5%86%9B%E8%AE%AD1%2F</url>
    <content type="text"><![CDATA[黄沙不见烈日炎，碧云天，晓风怨。飒爽英姿，真是个超然。勿让云雨匆匆散，月夜下，欢歌连。闲适风景时时盼，舞翩翩，望不断。舟叶水源，回首泪涟涟。待到君心换我心，垂柳下，戎装前。]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
