<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[利用外星人入侵小游戏学习面向对象编程]]></title>
    <url>%2F2018%2F08%2F29%2F%E5%88%A9%E7%94%A8%E5%A4%96%E6%98%9F%E4%BA%BA%E5%85%A5%E4%BE%B5%E5%B0%8F%E6%B8%B8%E6%88%8F%E5%AD%A6%E4%B9%A0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言：python游戏实践，面向对象编程，框架pygame 简述GitHub源代码 效果图游戏简介：在游戏《外星人入侵》中，玩家控制着一艘最初出现在屏幕底部中央的飞船。玩家 可以使用箭头键左右移动飞船，还可使用空格键进行射击。游戏开始时，一群外星人出 现在天空中，他们在屏幕中向下移动。玩家的任务是射杀这些外星人。玩家将所有外星 人都消灭干净后，将出现一群新的外星人，他们移动的速度更快。只要有外星人撞到了 玩家的飞船或到达了屏幕底部，玩家就损失一艘飞船。玩家损失三艘飞船后，游戏结束。 游戏用例图（第一次画用例图，不是很准确……）分析该项目，飞船、子弹、外星人可以分别划分为具有共同属性的一类，类中定义各自的属性，包括图像、形状、位置、更新位置、绘制图像等；在主函数中将对象实例化，对对象中的成员变量和函数进行调用实现移动、击杀等操作；本节实现飞船和子弹类和基本功能 当前新建一下几个文件|文件名|功能|备注||—|—|—||alien-invasion.py|主函数|||ship.py|飞船类|||bullet.py|子弹类|||game_functions.py|许多函数|主函数文件访问||settings.py|配置文件|常量| 目录结构 代码alien-invasion.py123456789101112131415161718192021222324252627import pygamefrom settings import Settingsfrom ship import Shipimport game_functions as gffrom pygame.sprite import Groupdef run_game(): pygame.init() # 获取配置 game_settings = Settings() # 绘制屏幕 screen = pygame.display.set_mode((game_settings.screen_width,game_settings.screen_height)) backgound_color = (220,230,230) pygame.display.set_caption("Alien Invasion") # 飞船实例化 ship = Ship(game_settings,screen) # 子弹编组，管理屏幕中所有的子弹，保存继承Sprite类的Bullet实例 bullets = Group() while True: # 检测飞船事件：左移右移发射子弹 gf.check_events(ship,game_settings,screen,bullets) # 修改飞船移动标志 ship.update() # 根据飞船移动标志重新计算飞船中心位置 # 更新所有子弹位置 gf.update_bullets(bullets) # 绘制飞船子弹 gf.update_screen(game_settings,screen,ship,bullets) run_game() ship.py类 123456789101112131415161718192021222324252627282930313233343536373839import pygameclass Ship(object): """docstring for Ship""" def __init__(self, game_settings,screen): super(Ship, self).__init__() self.game_settings = game_settings self.screen = screen # screen游戏界面 self.image = pygame.image.load('images/外星飞船.png').convert_alpha() # 加载飞船图像 # 修改图像大小 self.width,self.height = self.image.get_size() self.image = pygame.transform.smoothscale(self.image,(self.width//2,self.height//2)) self.rect = self.image.get_rect() self.screen_rect = screen.get_rect() # 获取游戏界面的中心x坐标和底部位置便可确定飞船位置 self.rect.centerx = self.screen_rect.centerx self.rect.bottom = self.screen_rect.bottom - game_settings.screen_height / 5 self.center = float(self.rect.centerx) # centerx中只能表示整数 # 移动标志 self.moving_right = False self.moving_left = False def update(self): """ 根据移动标志调整飞船位置 更改为根据self.center更新位置 """ if self.moving_right and self.rect.right &lt; self.screen_rect.right: # self.rect.centerx += 1 self.center += self.game_settings.ship_speed_factor if self.moving_left and self.rect.left &gt; 0: # self.rect.centerx -= 1 self.center -= self.game_settings.ship_speed_factor # 更新centerx，因为绘制图形是根据self.rect() # self.rect()定位需要根据centerx，bottom self.rect.centerx = self.center def blitme(self): """在self.rect位置绘制图像""" self.screen.blit(self.image,self.rect) bullet.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import pygamefrom pygame.sprite import Sprite# 继承Sprite类，完善自己的代码class Bullet(Sprite): """docstring for Bullet""" def __init__(self, game_settings,screen,ship): super(Bullet, self).__init__() self.screen = screen # # 在0，0位置创建bullet，并设置宽高 # self.rect = pygame.Rect(0,0,game_settings.bullet_width,game_settings.bullet_height) # # 调整子弹位置到飞船所在位置，调整top相同，中心x坐标相同 # self.rect.centerx = ship.rect.centerx # self.rect.top = ship.rect.top # # 将y坐标存储为小数值，以便能够微调子弹的速度 # self.y = float(self.rect.y) # self.color = game_settings.bullet_color # self.speed_factor = game_settings.bullet_speed_factor # 把子弹换成一个好玩的图片,把图片转换成位图 self.image = pygame.image.load('images/生气.png').convert_alpha() # 修改图像大小 self.width,self.height = self.image.get_size() self.image = pygame.transform.smoothscale(self.image,(self.width//10,self.height//10)) self.rect = self.image.get_rect() # 调整子弹位置到飞船所在位置，调整top相同，中心x坐标相同 self.rect.centerx = ship.rect.centerx self.rect.top = ship.rect.top # 将y坐标存储为小数值，以便能够微调子弹的速度 self.y = float(self.rect.y) self.speed_factor = game_settings.bullet_speed_factor def update(self): """向上移动子弹""" # 更新一次坐标y向上移动speed_factor个像素 self.y -= self.speed_factor # 更新子弹的rect位置 self.rect.y = self.y def draw_bullet(self): # """ # API:rect(Surface,color,Rect,width=0)-&gt;Rect # draw a rectangular shape on the Surgace # The width argument is the thickness to draw the outer edge. # If width is zero then the rectangle will be filled. # """ # pygame.draw.rect(self.screen,self.color,self.rect) """在self.rect位置绘制图像""" self.screen.blit(self.image,self.rect) game_functions.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import pygameimport sysfrom bullet import Bulletdef check_keydown_events(event,ship,game_settings,screen,bullets): """ 按下键盘事件：右移，左移，发射子弹 """ if event.key == pygame.K_RIGHT: ship.moving_right = True elif event.key == pygame.K_LEFT: ship.moving_left = True elif event.key == pygame.K_SPACE: fire_bullet(game_settings,screen,ship,bullets)def fire_bullet(game_settings,screen,ship,bullets): """ 如果没有超过当前屏幕显示的最多子弹数，实例化子弹，添加到子弹编组中 """ if(len(bullets) &lt; game_settings.bullet_allowed): bullet = Bullet(game_settings,screen,ship) bullets.add(bullet)def check_keyup_events(event,ship): """ 抬起键，抬起空格不发生任何事 """ if event.key == pygame.K_RIGHT: ship.moving_right = False elif event.key == pygame.K_LEFT: ship.moving_left = Falsedef check_events(ship,game_settings,screen,bullets): for event in pygame.event.get(): if event.type == pygame.QUIT: sys.exit() elif event.type == pygame.KEYDOWN: check_keydown_events(event,ship,game_settings,screen,bullets) elif event.type == pygame.KEYUP: check_keyup_events(event,ship)def update_screen(game_settings,screen,ship,bullets): screen.fill(game_settings.background_color) ship.blitme() """ API:pygame.sprite.Group.sprites sprites() -&gt; sprite_list bullet迭代器 """ for bullet in bullets.sprites(): bullet.draw_bullet() pygame.display.flip()def update_bullets(bullets): bullets.update() # 超出屏幕边界移除子弹 # 子弹编组副本 for bullet in bullets.copy(): if bullet.rect.bottom &lt;= 0: bullets.remove(bullet) # 注释掉，调试用，耗时 # print(len(bullets)) settings.py配置文件123456789101112131415class Settings(object): """docstring for Settings""" def __init__(self): super(Settings, self).__init__() self.screen_width = 1200 self.screen_height = 800 self.background_color = (230,230,230) self.ship_speed_factor = 1.5 # 飞船一个while循环走1.5像素 # 子弹配置 self.bullet_width = 3 self.bullet_height = 15 self.bullet_color = (120,120,120) self.bullet_speed_factor = 3 self.bullet_allowed = 5 # 最大子弹数 pygame接口文档总结 API 接口 描述 pygame.init() init() -&gt; None pygame.display.set_mode() set_mode(resolution=(0,0), flags=0, depth=0) -&gt; Surface Initialize a window or screen for display pygame.display.set_caption() set_caption(title, icontitle=None) -&gt; None pygame.event.get() pygame.image.load() load(filename) -&gt; Surface get_rect() blit() pygame.transform.smoothscale() smoothscale(Surface, (width, height), DestSurface = None) -&gt; Surface pygame.display.flip() flip() -&gt; None Update the full display Surface to the screen pygame.sprite.Group编组 Group(*sprites) -&gt; Group pygame.sprite.Group.sprites：list of the Sprites this Group contains pygame.sprite.Group.copy:duplicate the Group pygame.sprite.Group.add:add Sprites to this Group pygame.sprite.Group.remove:remove Sprites from the Group pygame.sprite.Group.update:call the update method on contained Sprites 外星人类和积分等后续啦~]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《疯狂JAVA》读书笔记]]></title>
    <url>%2F2018%2F08%2F28%2F%E3%80%8A%E7%96%AF%E7%8B%82JAVA%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[leetcode-链表-medium-23-24]]></title>
    <url>%2F2018%2F08%2F28%2Fleetcode-%E9%93%BE%E8%A1%A8-medium-23-24%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode今天的题目是23,24打卡链表，medium难度 最近几天有点懒散，对leetcode有些放松了，但是尝试了写几道medium题目，加油坚持住 题目：23. Merge k Sorted Lists描述：Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.例子：1234567Input:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354ListNode* Solution23::compare(ListNode* l1,ListNode* l2)&#123; if(l1 == nullptr)return l2; if(l2 == nullptr)return l1; ListNode *res = new ListNode(-1); ListNode *_res = res; ListNode* p = l1; ListNode* q = l2; while(p != nullptr &amp;&amp;q != nullptr) &#123; if(p-&gt;val &lt; q-&gt;val) &#123; res-&gt;next = p; p = p-&gt;next; &#125; else if(p-&gt;val &gt; q-&gt;val) &#123; res-&gt;next = q; q = q-&gt;next; &#125; else &#123; res-&gt;next = p; p = p-&gt;next; res = res-&gt;next; res-&gt;next = q; q = q-&gt;next; &#125; res = res-&gt;next; &#125; if(q != nullptr) res-&gt;next = q; if(p != nullptr) res-&gt;next = p; return _res-&gt;next;&#125;ListNode* Solution23::mergeKLists(vector&lt;ListNode*&gt;&amp; lists)&#123; if(lists.size() == 0) return nullptr; ListNode* res = lists[0]; int i= 1; while(i &lt; lists.size()) &#123; ListNode *temp = lists[i]; res = compare(res,temp); ++i; &#125; return res;&#125; 题目：24. Swap Nodes in Pairs描述：Given a linked list, swap every two adjacent nodes and return its head.例子：1Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. 代码：12345678910111213141516ListNode* Solution24::swapPairs(ListNode* head)&#123; ListNode *res = new ListNode(-1); res-&gt;next = head; ListNode *_res = res; while(_res-&gt;next !=NULL &amp;&amp; _res-&gt;next-&gt;next != NULL) &#123; ListNode *p = _res-&gt;next; _res-&gt;next = p-&gt;next; p-&gt;next = _res-&gt;next-&gt;next; _res-&gt;next-&gt;next = p; _res = _res-&gt;next-&gt;next; &#125; return res-&gt;next;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用python实现强化学习DQN算法]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%88%A9%E7%94%A8python%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0DQN%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习资料莫烦python 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289import numpy as npimport tensorflow as tfimport timeimport sys"""代码学习自莫烦python强化学习教程本代码主要实现利用DQN算法玩迷宫游戏在源代码基础上做了自己的注释和理解created by benyafang on 2018.8.26"""class DeepQNetwork: def __init__(self, n_actions, n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace_target_iter=300, # 每走300步copy一次 memory_size=500, batch_size=32, e_greedy_increment=None, # e_greedy增量 output_graph=False): self.n_actions = n_actions self.n_features = n_features self.lr = learning_rate self.gamma = reward_decay self.epsilon_max = e_greedy self.replace_target_iter = replace_target_iter self.memory_size = memory_size self.batch_size = batch_size self.epsilon_increment = e_greedy_increment self.epsilon = 0 if e_greedy_increment is not None else self.epsilon_max self.learn_step_counter = 0 self.memory = np.zeros((self.memory_size, n_features * 2 + 2)) self._build_net() t_params = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES,scope='target_net') e_params = tf.get_collection(tf.GraphKeys.GLOBAL_VARIABLES,scope='eval_net') with tf.variable_scope('soft_replacement'): self.target_replace_op = [tf.assign(t,e) for t,e in zip(t_params,e_params)] # 通过e来更新t self.sess = tf.Session() if output_graph: tf.summary.FileWriter("logs/",self.sess.graph) self.sess.run(tf.global_variables_initializer()) self.cost_his = [] def _build_net(self): self.s = tf.placeholder(tf.float32,[None,self.n_features],name='s') # 状态 self.s_ = tf.placeholder(tf.float32,[None,self.n_features],name='s_') # 下一个状态 self.r = tf.placeholder(tf.float32,[None,],name='r') # 奖励 self.a = tf.placeholder(tf.int32,[None,],name='a') # 行为 w_initializer,b_initializer = tf.random_normal_initializer(0.,0.3),tf.constant_initializer(0.1) # 初始化参数 with tf.variable_scope('eval_net'): e1 = tf.layers.dense(self.s,20,tf.nn.relu,kernel_initializer=w_initializer,bias_initializer=b_initializer,name='e1') # 参数分别为输入数据张量状态，神经单元数，激活函数，全连接层参数 self.q_eval = tf.layers.dense(e1,self.n_actions,kernel_initializer=w_initializer,bias_initializer=b_initializer,name='q') # 再来一层全连接层，将上一层输出输入进去，输出单元数为n_actions with tf.variable_scope('target_net'): t1 = tf.layers.dense(self.s_,20,tf.nn.relu,kernel_initializer=w_initializer,bias_initializer=b_initializer,name='t1') # 下一个状态，中间单元数20，两个网络结构相同 self.q_next = tf.layers.dense(t1,self.n_actions,kernel_initializer=w_initializer,bias_initializer=b_initializer,name='t2') # 应该是每一个action对应一个reward with tf.variable_scope('q_target'): # 用target网络生成的q_target # 利用target_net生成的结果， 得到最大的Q q_target = self.r + self.gamma * tf.reduce_max(self.q_next,axis=1,name='Qmax_s_') # 梯度下降法 self.q_target = tf.stop_gradient(q_target) # 如何理解stop_gradient with tf.variable_scope('a_eval'): # 用来计算loss a_indices = tf.stack([tf.range(tf.shape(self.a)[0],dtype=tf.int32),self.a],axis=1) self.q_eval_wrt_a = tf.gather_nd(params=self.q_eval,indices=a_indices) with tf.variable_scope('loss'): # 损失函数 self.loss = tf.reduce_mean(tf.squared_difference(self.q_target,self.q_eval_wrt_a,name='TD_error')) with tf.variable_scope('train'): # 训练网络 self._train_op = tf.train.RMSPropOptimizer(self.lr).minimize(self.loss) # 根据学习率来优化使得loss最小化 def store_transition(self,s,a,r,s_): if not hasattr(self,'memory_counter'): # 判断对象是否包含对应的属性 self.memory_counter = 0 transition = np.hstack((s,[a,r],s_)) # 水平穿在一起 index = self.memory_counter % self.memory_size # 计算存储的行索引 self.memory[index,:] = transition self.memory_counter += 1 def choose_action(self,observation): observation = observation[np.newaxis,:] if np.random.uniform() &lt; self.epsilon: actions_value = self.sess.run(self.q_eval,feed_dict=&#123;self.s:observation&#125;) action = np.argmax(actions_value) # 选择令Q网络值最大的action else: action = np.random.randint(0,self.n_actions) return action def learn(self): if self.learn_step_counter % self.replace_target_iter == 0: self.sess.run(self.target_replace_op) # 执行eval_net赋值给target_net的复制网络，主要是复制参数 print('\ntarget_params_replaced\n') if self.memory_counter &gt; self.memory_size: # 随机采样一组batch_size大小的样本 sample_index = np.random.choice(self.memory_size,size=self.batch_size) else: sample_index = np.random.choice(self.memory_counter,size=self.batch_size) batch_memory = self.memory[sample_index,:] _,cost = self.sess.run( [self._train_op,self.loss], feed_dict=&#123; self.s:batch_memory[:,:self.n_features], # 前n_features是state self.a:batch_memory[:,self.n_features], # 第n_features是aaction self.r:batch_memory[:,self.n_features + 1], # reward self.s_:batch_memory[:,-self.n_features:], # 下一个state &#125; ) self.cost_his.append(cost) # 损失值 # 动态改变epsilon self.epsilon = self.epsilon + self.epsilon_increment if self.epsilon &lt; self.epsilon_max else self.epsilon_max self.learn_step_counter += 1 # 学习数 def plot_cost(self): import matplotlib.pyplot as plt plt.plot(np.arange(len(self.cost_his)),self.cost_his) plt.ylabel('Cost') plt.xlabel('training steps') plt.show()if sys.version_info.major == 2: import Tkinter as tkelse: import tkinter as tkUNIT = 40 # pixelsMAZE_H = 4 # grid heightMAZE_W = 4 # grid widthclass Maze(tk.Tk, object): def __init__(self): super(Maze, self).__init__() self.action_space = ['u', 'd', 'l', 'r'] # up down left right self.n_actions = len(self.action_space) # 行为选择个数 self.n_features = 2 self.title('maze') self.geometry('&#123;0&#125;x&#123;1&#125;'.format(MAZE_H * UNIT, MAZE_H * UNIT)) # 4*4的maze self._build_maze() def _build_maze(self): self.canvas = tk.Canvas(self, bg='white', height=MAZE_H * UNIT, width=MAZE_W * UNIT) # canvas绘图，背景白色，规定高宽 # create grids绘制网格 for c in range(0, MAZE_W * UNIT, UNIT): x0, y0, x1, y1 = c, 0, c, MAZE_H * UNIT self.canvas.create_line(x0, y0, x1, y1) for r in range(0, MAZE_H * UNIT, UNIT): x0, y0, x1, y1 = 0, r, MAZE_H * UNIT, r self.canvas.create_line(x0, y0, x1, y1) # create origin origin = np.array([20, 20]) # hell陷阱 hell1_center = origin + np.array([UNIT * 2, UNIT]) self.hell1 = self.canvas.create_rectangle( hell1_center[0] - 15, hell1_center[1] - 15, hell1_center[0] + 15, hell1_center[1] + 15, fill='black') # hell # hell2_center = origin + np.array([UNIT, UNIT * 2]) # self.hell2 = self.canvas.create_rectangle( # hell2_center[0] - 15, hell2_center[1] - 15, # hell2_center[0] + 15, hell2_center[1] + 15, # fill='black') # create oval 终点 oval_center = origin + UNIT * 2 self.oval = self.canvas.create_oval( oval_center[0] - 15, oval_center[1] - 15, oval_center[0] + 15, oval_center[1] + 15, fill='yellow') # create red 游戏主体 self.rect = self.canvas.create_rectangle( origin[0] - 15, origin[1] - 15, origin[0] + 15, origin[1] + 15, fill='red') # pack all self.canvas.pack() # 迷宫重置 def reset(self): self.update() time.sleep(0.1) # 睡0.1s self.canvas.delete(self.rect) origin = np.array([20, 20]) self.rect = self.canvas.create_rectangle( origin[0] - 15, origin[1] - 15, origin[0] + 15, origin[1] + 15, fill='red') # return observation return (np.array(self.canvas.coords(self.rect)[:2]) - np.array(self.canvas.coords(self.oval)[:2]))/(MAZE_H*UNIT) def step(self, action): # 采取的action # 获取当前self.rect的坐标，左上角和右下角 s = self.canvas.coords(self.rect) # print(s) base_action = np.array([0, 0]) if action == 0: # up if s[1] &gt; UNIT: base_action[1] -= UNIT elif action == 1: # down if s[1] &lt; (MAZE_H - 1) * UNIT: base_action[1] += UNIT elif action == 2: # right if s[0] &lt; (MAZE_W - 1) * UNIT: base_action[0] += UNIT elif action == 3: # left if s[0] &gt; UNIT: base_action[0] -= UNIT # 根据base_action移动self.rect self.canvas.move(self.rect, base_action[0], base_action[1]) # move agent time.sleep(0.1) # 获取移动后的坐标更新self.rect next_coords = self.canvas.coords(self.rect) # next state # reward function判断这个坐标是否和陷阱和终点相等 if next_coords == self.canvas.coords(self.oval): # 如果到终点了奖励1 reward = 1 done = True elif next_coords in [self.canvas.coords(self.hell1)]: # 遇到陷阱奖励-1 reward = -1 done = True else: # 其他情况都是0 reward = 0 done = False s_ = (np.array(next_coords[:2]) - np.array(self.canvas.coords(self.oval)[:2]))/(MAZE_H*UNIT) return s_, reward, done # 返回下一个状态，奖励，游戏是否结束 def render(self): # time.sleep(0.01) self.update()def run_maze(): step = 0 # step在整个迭代中更新 for episode in range(300): # 玩300次 observation = env.reset() # 返回当前位置 while True: # 游戏没有结束的时候就循环 env.render() # 渲染界面 action = RL.choose_action(observation) # print(observation) observation_,reward,done = env.step(action) RL.store_transition(observation,action,reward,observation_) # 将当前观察行为奖励和下一个观察存储起来 if (step &gt; 200) and (step % 5 == 0): # 走了200步之后每到被5整除的步骤进行学习 RL.learn() observation = observation_ if done: break step += 1 print('game over') env.destroy()if __name__ == '__main__': env = Maze() RL = DeepQNetwork(env.n_actions, env.n_features, learning_rate=0.01, reward_decay=0.9, e_greedy=0.9, replace_target_iter=200, memory_size=2000, # output_graph=True ) env.after(100,run_maze()) # tk自带after，100ms后执行run_maze() env.mainloop() RL.plot_cost()]]></content>
      <categories>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度强化学习实战]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%B7%B1%E5%BA%A6%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[希望这篇翻译能够帮我自己理解,持续更新，最新更新日期2018.8.24 第一部分 基础 第一章 什么是强化学习强化学习发展历程1936年，英国数学家阿兰·图灵发表了一篇题为“论可计算”的论文数字，适用于Entscheidungs问题，“他在其中开发了一个算法的数学描述，后来被称为图灵机。他的图灵机的概念成为现代电子技术发展的基础电脑。有趣的是，他最初开发的图灵机作为解决问题的工具数学问题，不是因为他想发明一个新的计算机科学领域。尽管如此，他和其他许多人都认识到这种新计算理念的力量立刻提出了这些新计算系统是否会成为问题的问题像人类一样聪明。阿兰图灵自己开始了人工智能领域随后在1950年出版了“计算机械与智能”论文开头的问题是，“机器可以思考吗？”棋盘游戏一直都是被认为是一项智力运动，因此很自然地将其作为一种测试平台机器可以变得聪明。编写国际象棋游戏算法的几次尝试是在随后的几年中制定的，从仅描述的算法开始纸张，必须由一个人按照一系列规则运行，直到具有里程碑意义的失败。1996年，国际象棋世界冠军加里卡斯帕罗夫采用IBM的DeepBlue算法。 图1.1 这描绘了单磁带图灵机的工作原理。 标记为“q1”的形状是读写可以向左或向右移动磁带的磁头，磁带的打印值均匀分布在单元格中。读/写head遵循一组预定义的规则，可以读取磁带上的某些值，擦除和写入新值录影带。 这个简单的模型捕捉了计算的本质，并开始了计算机科学领域。虽然这些国际象棋游戏机在当时令人印象深刻，但它们是（并且继续是）主要基于穷举搜索和预编程逻辑而不是执行任何类似人类的分析或策略。实际上，大多数被称为人工的早期的情报只是硬编码的逻辑和启发式。第一个试图对生物神经网络及南无的描述人工神经网络出现在20世纪40年代，并将成为机器学习领域的许多算法之一。关于神经网络如何学习的一个特别有影响的理论是由心理学家唐纳德希伯在1949年出版的“行为组织”一书中提出。希伯提出当两个神经元反复发射时，学习发生在神经元的水平电化学信号称为动作电位同步和近距离，然后这两个神经元之间的因果关系将得到加强。他的理论后来被称为Hebbian学习，并且仍然被认为是重要的支持它的经验证据。 图1.2 第一个神经网络之一的图表，称为ADALINE，用于滤除回声电话线。网络简单地计算其输入变量的加权和，如果总和是否比某些阈值参数更大，它将返回1，否则返回0（称为步进函数）。 通过定义一些错误功能，你可以按照简单的规则修改阈值参数，以减少错误并提高算法的性能。 借助一些理论神经科学，第一个人工神经网络在20世纪50年代的一些最早的计算机上实现了。值得注意的是，在1959年，斯坦福大学的研究人员创造了神经网络的第一个商业应用称为ADALINE的算法，用于滤除电话线信号中的回声并且今天仍在使用。任何神经网络算法，实际上大多数机器学习算法，涉及控制其行为的参数。为了神经网络执行任何所需的任务，必须“训练”网络的参数才能将其设置为正确的值。通过简单的启发式方法训练ADALINE和其他早期神经网络搜索程序，虽然有些人采用了后来严格制定的程序并定义为反向传播。反向传播技术的历史有点虽然不确定，但直到20世纪80年代中期它才能进行更多的训练才被广泛采用。它能够训练比ADALINE更复杂的神经网络，并且仍然是神经网络的标准训练程序。 有监督和无监督学习与大多数神经网络和其他类型的机器学习算法一样，ADALINE是一种有监督的学习算法。有监督学习算法以师生模式进行训练。例如，如果你想构建一个算法将一个图像数据集划分成特定的类别，那么老师将会针对图像数据集执行算法来分类，然后算法会得到一个预测值，基于预测精度，老师会提供纠正反馈，以便提高预测精度。通过许多图像示例执行此操作，算法最终会表现得很好。更准确地说，学习算法是给定输入数据并产生输出。然后通过某个目标评估输出将算法的输出与已知的正确或标记输出进行比较，函数输出有多错误的度量（即错误）。然后更新算法的参数以最小化目标产生的误差功能，通常使用反向传播技术。因此，对每个监督学习任务，您需要两组数据：要学习的数据和标记数据（即正确的数据）无论问题是什么的答案）。必须生成标签数据并进行策划人类专门用于训练算法，而要学习的数据可以从“环境”获得，例如电话线信号。最大规模的商业应用需要至少数万甚至数百万和数十亿标记的训练数据行以在其任务中获得令人满意的准确性。 相反，无监督学习算法试图从数据中学习东西，而没有得到老师的明确反馈。无监督的最常见形式是聚类，其试图从数据集中找到相关数据的聚类。更现代和更复杂的无监督学习技巧包括一种称为自动编码器的神经网络，它可以自动学习数据中的复杂模式。尽管如此，无监督的方法在实用性方面受到限制，难以操作它们。 无监督算法可能会用你的数据学到一些有趣的东西，但是如果你没有告诉它你想要它做什么，它将不能把图像数据集分成你想要的类别。 有监督的学习一直是机器学习的主要形式。然而，在我们寻求艾伦·图灵梦寐以求的智能机器方面，这是最成功的商业用途。当然是想要发展智能的一个主要原因，机器是他们可以做我们还不知道该怎么做的事情。这是监督学习的局限性;必须已经有一位老师知道如何做到这一点任务可以教机器。如果机器学会了如何完成任务，那么它当然是非常有用，因为它可能比人类更快，更便宜，误差更小，但是它仍然无法学习如何做任何我们还不知道该怎么做的事情。这些有监督学习算法必然是针对特定领域的。 图1.3 监督学习是一种表现出师生关系的算法。算法通过老师给出明确的反馈来学习。 无监督学习算法能够在某种程度上自我教导，并自己学习一些数据。 显然，人类具有监督和无监督学习的方面。在学校学习知识是师生情况的一个例子。然而，无监督的学习对人类的进步有着重要影响：创造新的知识，新技能，艺术和创造力。必须有第一个学习的东西在能够教它之前让他们自己学习。有监督的学习可以帮助我们提高效率，节省了我们的时间和资源，从而为我们提供了更多的资源来投资于创造，但确实如此，不会给我们人工智能（AGI），机器将成为我们的知识同行而不仅仅是自动化工具。但即使你完全有实际意识，并且对AGI没有兴趣，监督学习仍然不能令人满意，因为它受到限制：我们可以提供多少培训数据;就像可以上学的学生人数一样，受到教师人数的限制。有时我们只是没有资源来生产标记的数据集，或这样做超过了使用算法的好处。 例如，作者的妻子之一是神经科学家，他使用花式显微镜对活体啮齿动物的神经元进行成像。 显微镜产生数十亿字节的视频数据，必须通过手动识别和描绘神经元进行精心分析，以产生有关神经元特征的定量数据。最近发表了一篇机器学习论文，其中论文的作者开发了一种可以自动生成的神经网络，能够识别这些视频中的神经元。 然而，它是一个监督神经网络，要求每个用户提供数千个手动识别神经元的标记数据集。 作者自己指出，这个过程可能需要10个多小时（乐观）。如果你不得不多次进行这种类型的实验，那么如此重要的时间投资可能会在长期内得到回报，没有一个忙碌的科学家想冒险花费整整一个工作日来为不能保证工作的算法构建训练数据集。 或许更有说明性的监督学习的不足之处在于教授如何驾驶汽车或操作机器人的算法。 假设您想要一辆汽车通过分析视频输入来学习如何驾驶（即没有其他传感器，如雷达和激光雷达）; 这实际上是特斯拉目前用于开发自动驾驶软件的策略。汽车必须连续控制方向盘并不断调整加速器或断开。您将如何收集此任务的培训数据？这是一个控制任务（或决策任务），而不是预测或分类任务，它是监督学习的基础。 在传统的监督学习任务中，环境得到精确管理，只有算法可以访问我们策划的数据，并且每个数据都是完全独立的（即我们可以任意删除或添加数据，而不会显着影响算法的整体性能）。在控制任务中，环境基本上不受管理并且“单独”生成数据并且可能是概率性的。在我们的自动驾驶汽车示例中，算法从其摄像机接收的数据不是由人产生的，而是由周围环境的自然演变产生的，这是时间的函数，这在很大程度上是不可预测的。此外，如果没有一堆昂贵的传感器，汽车只能对周围环境进行不完整的观察。教授算法在每个时刻应该做什么是完全不可行的，例如在给定摄像机当前记录的情况下方向盘应该旋转的确切数量。 控制任务中的问题结构这让我们回到了本章开头的开创性人工智能研究员Marvin Minsky的话。许多早期的人工智能算法只不过是人类可以轻易遵循的硬编码规则。神经网络和其他学习算法的出现使我们能够通过给出正确的答案来教授算法如何做某事，告诉它有多么错误，并让它自己更新，以免下次错误。这使我们不必编制和编写一套固定的规则来解决问题，并为我们提供了更大的灵活性。但它仍然是一个非常程序化的过程：输入一些数据，获得输出，根据我们对正确答案的了解产生错误值，然后使用反向传播等技术更新算法。如果我们可以为算法提供一个高级目标或目标并让它弄清楚细节怎么办？我们希望能够像Marvin Minsky那样做目标导向的编程，他们认为这将是未来。 强化学习领域开始意识到想象的未来。在强化学习，我们不需要给算法提供一堆标记数据来学习一些任务，我们只需要能够定义环境中成功的样子。例如，我们可以给出“不打击任何东西，遵循所有交通规则，沿着最有效的路线从A点导航到B点”的高级目标到我们的自动驾驶汽车算法并让它弄清楚如何计算实现该目标的细节。这似乎是一项了不起的壮举，但这正是我们将在本书中学习如何做的事情。 所有的人类行为都是从根本上是目标导向的，所以我们应该如何设计我们的学习算法。通过自然选择进行的生物进化赋予了大多数物种一系列原始目标或驱动力，例如最大限度地减少饥饿，避免痛苦，寻求快乐，减少不确定性，以及在人类和其他社会动物的情况下，实现社会接受。即使在远离我们祖先环境的现代世界中，每个人的行为也可以被简化为这些原始驱动和目标的某种组合。例如，尽管很难承认，编写本书的作者可能认为他们这样做是因为他们对强化学习感到兴奋，并希望与其他人分享，但从根本上说，我们的动机是我们的进化原始动力。贡献我们部落的成员。令人惊讶的是，世界上有多少人单独最大化或最小化了一小部分高级别的驱动器和目标。 让我们按照这个想法运行吧。如果一个人饿了（高级驾驶）那么她必须吃饭以减少她的饥饿感。 但是吃不能一步到位;她首先必须做出非常低级别的决定，比如走向哪个方向。从这个意义上说，为了解决一个高层次的目标，我们可以把它分解成小的子问题，这些问题一起将有助于解决高级问题。 图1.4 满足一个人饥饿的高级目标可以分解为一个“本地”子目标树，每个目标都必须解决才能实现全局目标。 理查德·贝尔曼（Richard Bellman）在1957年给出了一个严格的数学描述，这个想法打破了一个高层次的目标，其中不清楚如何自己解决，进入最低层次的子目标层次结构，几乎都是微不足道的决定。贝尔曼称这种技术是动态编程，其原因主要与历史环境有关，而不是为了清晰。更直观的名称可能是“目标分解”。贝尔曼的动态编程除了目标分解之外还有一个技巧：除了将目标分解为一组更容易解决的子目标外，我们还应该将解决方案存储到这些子目标的所有解决方案中，这样如果我们需要在以后的时间点解决相同的子目标，我们可以查看上次获得的解决方案，而不是重新计算出来。这种存储先前解决的子问题的技术称为memoization（注意，它不是记忆，它是记忆;没有“r”）。 动态编程（DP）可用于解决任何可分解为较小部分的控制任务。这应用从经济学到数学到计算机科学，当然还有强化学习，我们很快就会看到。但是为了给出一个简单的DP动作示例（以及您在教科书中最常见的示例），让我们看看如何使用它来提高计算机算法的效率，该算法在Fibonacci序列中产生当时的数字。如果你不熟悉Fibonacci序列，它就是遵循这种模式的正整数序列：0,1,1,2,3,5,8,13,21 ……其中第n个数是前两个数字的总和。换句话说，n=(n-1)+(n-2)其中n指的是序列中的第n个数字（零索引），前两个数字总是0和1.请理所当然地认为这个数字序列是特殊的并且实际上具有有用的应用因此，为什么我们可能想要编写一个计算机程序来生成它。使用这个数学定义作为我们的起点，我们可以在Python中编写这个函数： 我们定义了一个Python字典来存储我们制作的任何计算，并将它初始化为Fibonacci序列中的前两个数字。如果使用已经遇到的输入调用函数，它可以使用Python字典查找先前计算的数字并返回它，否则它将计算它（但只是一次）并将其存储在mem字典中.我们现在知道，为了应用Bellman的动态编程，我们必须能够将我们的问题分解为我们知道如何解决的子问题。但即便是这种看似无害的假设也很难在现实世界中实现。 你如何打破“不崩溃”的自动驾驶汽车的高水平目标成为小型非碰撞子问题？ 通过首先解决更容易的行走问题，孩子是否学会走路？在强化学习中，我们经常会遇到可能包含某些随机性因素的细微差别，我们无法像贝尔曼那样完全应用动态规划。 事实上，DP可以被认为是问题解决技术连续体的一个极端，其中另一端是随机试验和错误。 查看这种学习连续体的另一种方式是，在某些情况下，我们对环境有最大的了解，而在其他情况下，我们对环境的了解很少，因此我们需要在每种情况下采用不同的策略。 如果你需要在你自己的房子里使用浴室，那么你确切地知道（好吧，至少是无意识的）肌肉运动的顺序会让你从任何起始位置（即动态编程）进入浴室。这当然是因为你非常了解你的房子,换句话说，你的房子中有一个或多或少完美的模型。 如果你去别人家里参加过你从未去过的聚会，那么假设没有人告诉你，你只需环顾四周，直到你自己找到浴室（即试错）; 因为你没有那个人的房子的好模型。 试错策略通常属于蒙特卡罗方法的保护范围。蒙特卡罗方法基本上是从环境中随机抽样。 在许多现实世界的问题中，我们至少对环境如何运作有一些了解，因此我们最终不得不采用一些混合策略来进行一些随机的试验和错误以及利用我们已经了解的环境和直接的知识来解决容易的子目标。 混淆策略的一个愚蠢的例子是，如果你被蒙住眼睛，放在你家里一个不知名的地方，并被告知要通过扔鹅卵石和聆听噪音找到浴室。您可以首先将高级目标（找到浴室）分解为更容易接近的子目标，找出您当前所在的房间。要解决这个子目标，您可能会随机指向几个鹅卵石并评估房间的大小，可能会给你足够的信息来推断你在哪个房间，比如卧室。然后你需要转到另一个子目标，导航到门，这样你就可以进入走廊。然后你会再次开始扔鹅卵石，但是既然你记得（记住）你最后一次随机鹅卵石投掷的结果，你可以把你的投掷目标定位到不那么确定的区域。迭代这个过程，你最终可能找到你的浴室。因此，在这种情况下，您应用动态规划的问题结构（即目标分解）和蒙特卡罗方法的随机采样。 标准模型我们学习了理查德贝尔曼如何将动态规划作为解决某些控制或决策问题的一般方法，但我们也知道它占据了强化学习连续体的极端。可以说，贝尔曼更重要的贡献是帮助开发我们可能称之为强化学习型问题的“标准模型”。标准模型本质上是一组核心术语和概念，每一个强化学习问题都可以用来表达。这不仅提供了一种标准化的语言，可以与其他工程师和研究人员进行交流，它也迫使我们以一种易于动态编程的方式来制定我们的问题，例如问题分解。我们可以迭代地优化本地子问题，但仍然朝着实现全局高层目标迈进。 幸运的是，它实际上也非常简单。 为了具体说明标准模型，让我们考虑构建一个标准模型的任务。强化学习算法，可以学习最大限度地减少大数据的能源使用。计算机需要保持冷却才能正常运行，因此可能会产生大型数据中心冷却系统的成本很高。保持数据中心冷静的天真方法只是为了在一定程度上保持空调开启，导致没有服务器运行得太热了。你可能做得比这更好，因为它不太可能中心的服务器同时运行热，数据中心的使用情况也是如此总是处于同一水平，所以如果你可以将冷却目标定位到重要的地方和时间。大多数情况下，您可以用更少的钱获得相同的结果。 标准模型的第一步是定义您的总体目标。在这种情况下我们整体目标是尽量减少在冷却上花费的美元，但是我们中心没有服务器可以超过一些阈值温度。虽然这似乎是两个目标，但我们可以将这些一起捆绑成一个新的复合目标函数。这将是一个函数返回一个错误值，表明我们在达到这两个目标时的目标是多少，给出服务器的当前成本和温度数据。我们的实际数字目标函数并不重要，我们只想让它尽可能低。因此，我们需要我们的强化学习算法来针对某些输入数据最小化这个目标（误差）函数，这些数据肯定会包括运行成本和温度数据，但也可能包含其他有用的上下文信息，可以帮助算法预测数据中心用法。 这个输入数据是由环境生成的数据，这个术语我们已经松散了使用。一般而言，强化学习（或控制）任务的环境是任何动态过程产生与实现我们的目标相关的数据。。虽然我们将它用作技术术语，但它的日常使用并没有太多抽象。作为一个非常先进的强化学习算法的例子，你总是在某种环境中，你的眼睛和耳朵不断消耗你的环境产生的信息，这样你就可以实现你的日常目标。由于环境是动态过程（即时间的函数），它可能在不同大小和类型的每个时刻产生连续的数据流。为了使算法友好，我们需要采用这种环境数据并将其捆绑到我们称之为（环境状态）状态的离散数据包中，并且可以在每个离散时间步骤中传递给我们的算法。 总结到目前为止，我们定义了一个目标函数（最小化成本和温度），它是环境（我们的数据中心和任何相关过程）的状态（当前成本，当前温度数据）的函数。我们模型的最后一部分是强化学习算法本身。这可以是任何可以从数据中学习以最小化或最大化某些目标函数的算法。它未必是深度学习算法;我们想要明确强化学习是一个独立的领域，与任何特定学习算法的关注点分开。我们将在几个部分中列出我们为什么本书几乎完全使用深度学习作为我们的学习算法的原因。 正如我们之前提到的，强化学习（或一般控制任务）与普通监督学习之间的关键差异之一是，在控制任务中，算法需要做出决策并采取行动。这些行为将对未来发生的事情产生因果影响。采取行动确实是标准模型中的另一个关键词，或多或少是您所期望的。但是，每项决策或采取的行动都是分析当前环境状况并尝试做出最佳决策的结果。标准模型中的最后一个概念是，在每次采取行动后，算法都会得到奖励。奖励是学习算法在实现全局目标方面表现良好的（本地）信号。奖励可以是一个积极的信号（即表现良好，保持良好）或负面信号（即这不起作用，尝试别的东西），即使我们称这两种情况都是奖励。 奖励信号是学习算法必须更新自身的唯一提示，希望在下一个环境状态下表现更好。在我们的数据中心示例的情况下，只要其操作减少了错误值，我们就可以向算法授予+10（任意值）的奖励。或者更合理地，我们给予奖励与减少误差的程度成比例。 如果它增加了错误，那么我们给它一个负面的奖励。最后，我们通过将其称为代理来为我们的学习算法赋予更高级的名称。代理是任何强化学习问题中的动作或决策学习算法。最后，我们可以把它们放在一起，如图1.5所示。 Figure1.5 强化学习算法的标准模型.RL算法涉及学习在环境中进行交互的最佳方式的代理。代理在环境中执行操作-例如移动棋子-然后更新环境状态。对于我们采取的每一个动作，我们都会收到奖励（例如，赢得游戏的次数为+1，输掉游戏时为-1，否则为0）。RL算法重复此过程，目的是最大化奖励，并最终了解环境的运作方式。 在我们的数据中心示例中，我们希望我们的代理将学习如何降低冷却成本。除非我们能够为其提供完整的环境知识，否则它将不得不采用某种程度的反复试验。如果我们幸运的话，代理可能会学得很好，以至于它可以在不同于最初训练的环境中使用。由于代理是学习者，因此它被实现为某种学习算法。由于这是一本关于深度强化学习的书，我们的代理将使用深度学习算法（也称为深度神经网络）来实现。但请记住，强化学习更多地是关于问题和解决方案的类型，而不是任何特定的学习算法，并且当然可以使用深度神经网络的替代方案。实际上，在第3章中我们开始使用一个非常简单的非神经网络算法，然后在本章末尾用神经网络代替它。 图1.6 输入数据（某个时间点的环境状态）被传送到代理中，代理在本书中被实现为深度神经网络，然后评估该数据以采取行动。这个过程比这里显示的更多一些，但这抓住了本质。 代理人的唯一目标是在长期内最大化其预期回报。代理只是重复这个循环：处理状态信息，决定采取什么行动，看看你是否获得奖励，观察新状态，采取其他行动……等等。如果我们正确地设置了这一切，代理最终将学会了解其环境并在每一步都做出可靠的好决策。这种通用机制可以应用于自动驾驶汽车，聊天机器人，机器人，自动股票交易，医疗保健等等。我们将探索其中一些应用程序将在下一节和本书中介绍。 在本书中，我们花了大部分时间学习如何将问题构建到我们的标准模型中，以及如何实现足够强大的学习算法（代理）来解决难题。对于我们的情况，您不需要构建环境，您只需插入现有环境（例如游戏引擎或其他API）。例如，OpenAI发布了一个Python Gym库，它为我们提供了大量的环境和一个简单的界面，我们的学习算法可以与它们进行交互（图1.5）。左边的代码显示了设置和使用这些环境中的一个是多么简单，只有5行代码的9x9 Go游戏。 图1.7 OpenAI python库带有许多环境和一个简单的界面，学习算法可以与它们进行交互。 只需几行代码，我们就加载了9x9 Go板。 我能用强化学习做什么我们通过探索人工智能的历史以及它如何引导我们来开始本章，相信尽管最近在监督学习方面的成功是重要和有用的，有监督的学习不会让我们接受人工智能（AGI）。我们最终寻求能够以最小的方式应用于多个问题的通用学习机器，无监督，其技能可以跨领域转移。大数据丰富的公司可以从受监督的方法中获益，但规模较小的公司和组织可能没有资源来利用机器学习的力量。通用学习算法将为每个人提供公平的竞争环境。 尽管如此，虽然通用学习机器比领域专用和监督机器更强大，但仍有理由考虑在实践中使用当前的强化学习技术。强化学习研究和应用仍在成熟，但近年来出现了许多令人兴奋的发展。强化学习研究与实践应用程序仍在成熟，但最近有许多令人兴奋的发展。谷歌的DeepMind研究小组展示了一些令人印象深刻的成果并引起了国际关注。第一次是在2013年，一种算法可以在超人的水平上播放一系列Atari游戏。 以前创建代理来解决这些游戏的尝试涉及微调底层算法以理解游戏的特定规则，通常称为特征工程。虽然这些特征工程方法可以很好地用于特定游戏，但是他们无法将任何知识或技能转移到新游戏或域。DeepMind的深度Q网络（DQN）算法足够强大，可以继续使用没有任何游戏特定调整的七场比赛。它只有屏幕上的原始像素，只是被告知要最大化分数，但算法学会了如何超越专家级别。 图1.8 DeepMind的DQN算法成功学会了如何玩7个Atari游戏，只有原始像素作为输入，玩家得分是最大化的目标。 以前的算法，例如IBM的Deep Blue，需要经过微调才能玩特定的游戏。 最近，DeepMind的AlphaGo和AlphaZero算法击败了全世界中国古代游戏Go的最佳玩家。专家认为人工智能（AI）会至少在十年内无法参加比赛。玩家不知道最好的在任何给定的回合中移动，只收到他们在行动结束时的行动反馈游戏。许多高水平的玩家认为自己是艺术家，而不是计算战略家，并将获胜的动作描述为美丽或优雅。这些是特征算法通常处理不好。拥有超过10170个法律委员会职位，蛮力算法（就像IBM深蓝用来击败国际象棋一样）是不可行的。AlphaGo通过玩数百万次模拟游戏和学习来管理这项壮举，哪些动作最大化了玩游戏的回报。与Atari案件类似，AlphaGo只能访问人类玩家所拥有的相同信息。 虽然可以比人类更好地玩游戏的算法是非凡的，但是承诺RL的潜力远不止于制作更好的游戏机器人。 DeepMind能够创建一个模型将谷歌的数据中心冷却成本降低了40％，这是我们之前探讨过的本章仅作为一个例子。自动驾驶汽车使用RL来学习哪一系列动作（加速，转弯，断路，发信号）导致乘客到达目的地以及如何避免事故。研究人员正在训练机器人来完成任务学习运行，无需明确编程复杂的运动技能。 其中许多例子都是高赌注，比如开车。你当然不能让学习机器通过反复试验来学习驾驶汽车的方法。幸运的是，有越来越多的成功例子让学习机器在一些无害的模拟器中松动，然后一旦掌握了模拟器，就在现实世界的真实硬件上进行尝试。我们将在本书中探讨的一个例子是算法交易。所有股票交易的很大一部分实际上是由人类操作员几乎没有输入的计算机执行的。这些算法交易者中的大多数都是由管理数十亿美元的大型对冲基金掌握的。然而，在过去几年中，我们已经看到个体交易者对构建交易算法越来越感兴趣。实际上，Quantopian是一家提供平台的公司，个人用户可以用Python编写交易算法并在安全的模拟环境中对其进行测试。如果他们的算法表现良好，他们可以用它们来交易真钱。许多交易者通过简单的启发式和规则化取得了相对成功。然而，股票市场是动态且不可预测的，因此持续学习强化学习算法具有能够实时适应不断变化的市场条件的优势。 我们在本书的早期讨论的一个实际问题是广告投放。许多网络广告从广告中获得了可观的收入，而广告的收入通常与广告可以获得的点击次数相关联。因此，有一个很大的动力来放置最大化点击次数的广告。但是，实现此目的的唯一方法是利用有关用户的信息来放置最合适的广告。遗憾的是，我们通常不知道用户的哪些特征与正确的广告选择相关。但是，我们可以采用强化学习技术取得一些进展。如果我们为RL算法提供一些关于用户的潜在有用信息（我们称之为环境或环境状态），并告诉它最大化广告点击次数，那么它将学习如何将其输入数据与其目标相关联，并最终将了解哪些广告会为特定用户带来最多的点击次数。 为什么是深度强化学习好的，所以强化学习听起来很有意思，但为什么深度强化学习呢？ RL早在流行的深度学习兴起之前就存在了。实际上，一些最早的方法（我们将为学习目的引入）只涉及在查找表（例如Python字典）中存储体验并在算法的每次迭代中更新该表。 图1.9 Tic-Tac-Toe的动作查找表，其中只有三个条目，其中玩家玩X.当玩家获得一个棋盘位置时，查找表决定了他们接下来要做的移动。游戏中的每个可能状态都会有一个条目。 这个想法是让代理在环境中玩耍，看看会发生什么，但是将经验存储在某种数据库中。过了一段时间，您可以回顾一下您的知识数据库，并观察哪些有效，哪些无效。没有神经网络或任何其他花哨的算法。对于非常简单的环境，这实际上非常有效。例如，在Tic-Tac-Toe中，有255,168个有效游戏板子位置。查找表（也称为内存表）将具有从每个状态映射到特定操作的许多条目（图1.5）。在训练期间，算法可以知道哪个移动导向更有利的位置并且更新存储器表中的该条目。 但是，一旦环境变得更加复杂，使用内存表就变得棘手了。例如，视频游戏的每个屏幕配置都可以被认为是一个不同的状态。想象一下，尝试存储可能出现在视频游戏屏幕上的有效像素值的每种可能组合！DeepMind播放Atari的DQN算法在每一步都输入了四张84×84灰度图像，这将导致256^28228个独特的游戏状态（每像素256种不同的灰度，4 84 84 = 28228像素）。这个数字远大于可观察宇宙中的原子数，绝对不适合计算机内存。这是在图像按比例缩小以减小其尺寸之后原始210x160像素彩色图像。 图1.10 一系列三帧突破。 球的位置在每个框架中略有不同。 如果使用查找表，这相当于在查找表中存储三个唯一条目。查找表是不切实际的，因为有太多的游戏状态要存储。 如果一个像素被改变，则认为游戏处于不同的状态并且需要在查找表中的另一个条目。 但是，我们可以尝试限制可能性。在游戏Breakout中，您可以控制屏幕底部可以向右或向左移动的球拍; 游戏的目标是偏转球并打破位于屏幕顶部的多个块。在这种情况下，我们可以定义约束——只关注球的状态。当我们在屏幕顶部等待球时我们的动作并不重要 - 或者提供我们自己的特征 - 而不是提供原始图像，只需提供球，桨和 剩余的块。但是，这些方法要求程序员理解游戏的基本策略，而不是推广到其他环境。 这就是深度学习的用武之地。深度学习算法可以学习抽象出具体像素排列的细节，并学习一个状态的重要特征。由于深度学习算法只有有限数量的参数，我们可以使用它将任何可能的状态压缩成我们可以有效处理的东西，然后使用新的表示来做出我们的决定。通过使用神经网络，Atari DQN仅具有1792个参数（卷积神经网络具有16个8x8滤波器，32个4x4滤波器，256个节点完全连接的隐藏层），而不是存储整个状态空间所需的256^28228个键/值。 在Breakout游戏的情况下，深度神经网络可以自己学习识别程序员在查找表方法中手工设计的相同高级特征。 也就是说，它可能会学习如何“看到”球，球拍，方块以及识别球的方向。 鉴于它只是被给予原始像素数据，这真是太神奇了。 更有趣的是，所学习的高级功能可以转移到其他游戏或环境。 深度学习是最近所有强化学习成功的秘诀。没有其他类算法证明了代表性的力量，作为深度神经网络的效率和灵活性。 而且，神经网络实际上相当简单！ 为什么选择本书有许多资源可用于强化学习，为什么选择这本书呢？强化学习的基本概念已经建立了数十年，但是这个领域正在快速发展，因此教授任何特定的新结果几乎肯定会是短暂的。这就是为什么这本书专注于教学技巧而不是短半衰期的细节。 我们确实涵盖了该领域的一些最新进展，这些进展肯定会被取代，然而，在不太遥远的未来，我们这样做只是为了建立新技能，而不是因为我们所涉及的特定主题必然是经过时间考验的技术。我们相信，即使我们的一些例子变得过时，你学到的技能也不会，你将会准备好在很长一段时间内解决强化学习问题。 此外，强化学习是一个需要学习很多的大领域。 我们不可能希望在本书中涵盖所有内容。 我们的目标不是成为一个详尽的RL参考或综合课程，而是通过应用教您RL的基础，并对该领域最新的一些最新发展进行抽样。我们希望您能够学习到您在这里学到的知识，并轻松掌握我们遗漏的RL的许多其他领域。此外，我们最后有一个部分为您提供了完成本书后可能需要查看的领域的路线图。 我们还打算写一本专注于教学的书，但也要严格。强化学习和深度学习都是基础数学的。 如果您阅读了这些领域的任何主要研究文章，您将会遇到可能不熟悉的数学符号和方程式。数学使我们能够对事物的真实性，事物的相关性做出准确的陈述，并对事物的运作方式和原因提供严格的解释。我们可以在没有任何数学的情况下教授强化学习，只使用Python，但是，这种方法会妨碍你理解未来的进步。 所以我们认为数学是重要的，但正如我们的编辑所指出的那样，出版界有一个共同的说法：“对于书中的每一个等式，读者都减半了”，这可能有一些道理。除非你是一个整天读写数学的专业数学家，否则在解读复杂的数学方程式时会有不可避免的认知开销。面对想要深入强化学习的严谨论述，让我们的读者获得最高的理解，并希望尽可能多的人接触，我们想出了我们认为本书的一个非常显着的特征。事实证明，即使是专业数学家也会厌倦传统的数学符号及其庞大的符号阵列，所以在高等数学的一个特定分支中称为类别理论，数学家已经开发出一种名为字符串图的纯图形语言。字符串图看起来与流程图和电路图非常相似，并且具有相当直观的含义，但它们与传统的数学符号一样严格和精确，主要基于希腊语和拉丁符号。 图1.11 单层神经网络的字符串或流程图。 从左到右阅读，这表示接受维度为n的输入向量的函数，将其乘以维数为n×m的矩阵，返回维数为m的向量。 然后将非线性（激活）函数应用于向量中的每个元素，并将结果向量作为输出从函数返回。 图1.11显示了我们将在本书中经常使用的图表类型的简单示例，用于将所有内容从复杂的数学方程式传递到深度神经网络的架构。 我们将在下一章中描述这种图形语法，我们将在本书的其余部分继续完善和构建它。 在某些情况下，这种图形符号对于我们试图解释的内容来说是过度的，所以我们将结合使用清晰的散文和Python或伪代码。 在大多数情况下，我们还包括传统的数学符号，因此最重要的是，您将能够以这种或那种方式学习基础数学概念，无论是图表，代码还是常规符号都与您联系。 接下来的内容在下一章中，我们将深入探讨强化学习的真正内容，涵盖许多核心概念，例如探索和开发之间的权衡，马尔可夫决策过程，价值函数和策略（这些词很快就会有意义）。但首先，在下一章的开头，我们将介绍一些我们将在本书其余部分使用的教学方法。 本书的其余部分将介绍核心深度强化学习算法，其中大部分最新研究都是从Deep Q Networks开始，然后是Policy Gradient方法，然后是基于模型的算法。 我们将主要使用OpenAI的Gym（前面提到过）训练我们的算法来理解非线性动力学，控制机器人（图1.7）和播放Go。 在每一章中，我们将开始一个主要问题或项目，我们将用它来说明该章的重要概念和技能。 随着每章的进展，我们可能会为起始问题增加复杂性或细微差别，以深入了解某些原则。例如，在第2章中，我们首先讨论在娱乐场老虎机上最大化奖励的问题，并通过解决该问题，我们涵盖了大部分基础强化学习。稍后我们为该问题增加了一些复杂性，并将设置从赌场更改为需要最大化广告点击的业务，这使我们能够完善一些核心概念。 虽然本书适合那些已经具备深度学习基础知识的人，但我们期望不仅能教你有趣和有用的强化学习技巧，还能磨练你的深度学习技巧。 为了解决一些更具挑战性的项目，我们需要采用深度学习的一些最新进展，如生成对抗网络，进化方法，元学习和转移学习。同样，这完全符合我们以技能为中心的教学模式，因此任何这些进步的细节都不重要。 总结 强化学习是学习的机器学习算法的子类，在某些环境中最大化奖励。 当问题涉及做出决定或采取行动时，这些算法很有用。原则上，强化学习算法可以采用任何统计学习模型，然而，使用深度神经网络已变得越来越流行和有效。 代理是任何强化学习问题的核心。 这是其中的一部分强化学习算法，处理输入信息以采取行动。在本书中，我们主要关注作为深度神经网络实现的代理。 环境是代理运行的潜在动态条件。更一般地说，环境是任何进程生成代理的输入数据。 例如，我们可能有一个代理在飞行模拟器中飞行飞机，因此模拟器就是环境。 状态是代理可以访问并用于制定决策的环境的快照。 环境通常是一组不断变化的条件，但是，我们可以从环境中采样，并且在特定时间点的这些样本是我们给代理的环境的状态信息。 行动是由代理人做出的决定，它会改变其环境。移动特定的棋子s是一个动作，所以按下汽车的油门踏板。 奖励是在服用后由环境给予代理的积极信号“好”的行动。奖励是代理人获得的唯一学习信号。强化学习算法（即代理）的目标是最大化奖励。 RL算法的一般管道是一个循环，其中代理接收输入数据（环境的状态），代理评估该数据并在给定其当前状态的一组可能动作中采取动作，该动作改变环境 然后，环境向代理发送奖励信号和新状态信息，并且循环重复。 当代理被实现为深度神经网络时，则在每次迭代时，我们基于奖励信号评估损失函数并反向传播以改善代理的性能。 第二章 强化学习建模问题：马尔科夫决策过程本章内容： 字符串图和我们的教学方法 PyTorch深度学习框架 解决多臂赌博机问题 平衡探索与开发 将问题建模为马尔可夫决策过程（MDP） 实现神经网络来解决广告选择问题 字符串图和我们的教学方法本章介绍了所有强化学习中的一些最基本的概念，并将作为本书其余部分的基础。 但在我们开始讨论之前，我们首先要讨论一下我们将在本书中使用的一些反复出现的教学方法，最值得注意的是，我们在上一章提到的字符串图。 根据我们的经验，当大多数人试图教授复杂的东西时，他们倾向于按照主题本身的相反顺序来教授它。 他们会给你一堆定义，术语，描述和定理，然后他们会说，“太好了，既然我们已经涵盖了所有的理论，让我们回顾一些实践问题。”我们认为，这正是 应该呈现事物的相反顺序。 大多数好的想法都是作为解决世界上真正问题的解决方案，或者至少是想象中出现的问题。 问题解决者会遇到潜在的解决方案，测试它，改进它，然后最终得到正式化并可能数学化。 所有的术语和定义都是在考虑到问题的解决方案之后出现的。 我们认为，当你取代那个正在思考如何解决某个特定问题的创意制造者时，学习一些东西是最有动力和最有效的。 只有一旦解决方案的直觉结晶，它才能保证形式化，这确实是必要的，以确定其正确性并忠实地将其传达给该领域的其他人。 有一种强烈的冲动要求采用这种反向的时间顺序教学模式，但我们会尽力抵制它并随时开发这个主题。 本着这种精神，我们将根据需要引入新的术语，定义和数学符号。 例如，我们将使用这样的“标注”框： 神经网络是一种由多个“层”组成的机器学习模型，它们执行矩阵向量乘法，然后应用非线性“激活”函数。 神经网络的矩阵是模型的可学习参数，通常称为神经网络的“权重”。 每个术语只会看到一次这些标注框，但我们通常会在文本中以不同的方式重复这些标注，以确保您真正理解它并记住它。 这是一门关于强化学习的课程，而不是教科书或参考书，所以当我们认为重要的事情要记住时，我们不会回避重复自己。 每当我们需要引入一些数学时，我们通常会使用一个显示数学的框和一个相同基础概念的伪Python版本。 有时在代码或数学方面更容易思考，无论如何，我们认为熟悉这两者是很好的。 作为一个非常简单的例子，如果我们引入一条线的方程式，我们会这样做：12Mathy=mx+b 123pseudocodedef line(x,m,b): return m*x+b 我们还包括大量的内联代码（简短代码段）和代码清单（更长的代码示例）以及完整项目的代码。 本书中的所有代码都在Jupyter笔记本中提供，该笔记本按照本书GitHub存储库 由于强化学习涉及许多相互关联的概念，这些概念在单词留下时会变得令人困惑，因此我们包含了许多不同种类的图表和图形。 我们使用的两种更重要的数字是字符串图和olog（“oh-log”）。 他们可能有奇怪的名字，但他们都是非常简单的想法，并且改编自类别理论，我们在第一章中提到的数学分支，他们倾向于使用大量图表来补充或取代传统的符号表示法。当我们在第1章介绍强化学习的一般框架时，我们已经遇到过一个olog： 这个想法是盒子包含名词或名词短语，而箭头用动词或动词短语标记。 它与典型的流程图略有不同，但它可以很容易地将olog图转换成英文散文，反之亦然，并且非常清楚箭头在功能上究竟是做什么的。 最后，字符串图（有时在其他来源中称为接线图）也是类似流的图，表示沿着字符串（即有向或无向箭头）的类型化数据流入过程（计算，函数，转换等） 用框表示。 字符串图和类似的流程图之间的重要区别在于，线上的所有数据都是明确键入的（例如，具有形状或简单浮点数的numpy数组）并且它们是完全组合的。 通过组合，我们的意思是我们可以以原则的方式“放大”或放出图表，以查看更大的更抽象的图片或深入到计算细节。 如果我们显示更高级别的描述，则流程框可能只标有一个单词或短语，表示发生的流程类型，但我们也可以显示该流程框的放大视图，显示所有它的内部细节，由它自己的子串和子过程组成。这些图表的组成特性也意味着我们可以将部分图表插入到其他图表中，形成更复杂的图表，只要所有字符串的类型兼容即可。例如，这是一个神经网络的单层作为字符串图：从左到右阅读，我们看到一些类型为“n”的数据流入一个名为“神经网络层”的过程框，并产生类型为“m”的输出。由于神经网络通常将向量作为输入并将向量作为输出，这些类型分别指输入和输出向量的维度。也就是说，该神经网络层接受长度或维度为n的向量并产生维度为m的向量。对于某些神经网络层，n = m是可能的。这种“键入”字符串的方式是简化的，我们只有在明确了类型对上下文的意义时才会这样做。在其他情况下，我们可以使用诸如ℝ的数学符号来表示所有实数的集合，这在编程语言中基本上转换为浮点数。因此，对于维度为n的浮点数向量，我们可以像这样输入字符串：现在输入更丰富，我们不仅知道输入和输出向量的大小，我们知道它们是实数/浮点数。 虽然几乎总是这样，但有时我们可能会处理整数或二进制数。 在任何情况下，我们的处理盒“神经网络层”都留作黑盒子，除了将矢量转换为可能不同维度的另一个矢量这一事实外，我们不知道究竟发生了什么。 我们可以决定放大这个过程，看看具体发生了什么：现在我们可以看到原始流程框的内部，它由自己的一组子流程组成。 我们可以看到，我们的n维向量乘以维数n×m的矩阵，产生m维向量积。 然后该向量通过一个称为“ReLU”的过程，您可以将其识别为标准神经网络激活函数，即整流线性单元。 如果需要，我们可以继续放大ReLU子子流程。 因此，任何值得命名的字符串图表必须能够在任何抽象级别进行仔细检查并保持良好类型（意味着进入和退出进程的数据类型是兼容的并且有意义，例如应该生成排序的进程 列表不应该连接到任何级别的另一个期望整数的进程。 只要字符串输入良好，我们就可以将一堆进程串联到一个复杂的系统中。 这允许我们构建一次组件，并在类型匹配的任何地方重新使用它们。 在某种程度上，我们可能会描绘一个简单的两层递归神经网络（RNN），如下所示： 所以这个RNN接收一个q向量并产生一个s向量。 但是，我们可以看到内部流程。 有两层，每层都看起来功能相同。 它们各自接收一个向量并生成一个向量，除了输出向量被复制并作为输入的一部分反馈到层过程中，因此重现。 字符串图是一种非常通用的图表类型; 除了绘制神经网络图之外，我们还可以用它们来描绘如何烤蛋糕。 一种特殊的字符串图是计算图。 计算图是一个字符串图，其中所有进程代表计算机可以执行的具体计算，或者可以用某些编程语言（如Python）描述。 如果您曾在TensorFlow的TensorBoard中看到计算图，那么这就是我们的意思。 解决多臂赌博机问题好的，我们已准备好开始真正的强化学习问题，并学习解决这个问题所需的相关概念和技能。 但在我们过于花哨地构建AlphaGo之前，让我们首先考虑一个简单的问题（很容易转化为实际问题）。 假设你在赌场和一些老虎机的部分。 在你面前有10台老虎机连续闪亮的标志，上面写着“免费玩！最高支付10美元！” 哇，不错吧！ 好奇，你问其中一位员工这里发生了什么，看起来好得令人难以置信，她说：“这是真的，尽可能多地玩，它是免费的。每台老虎机都保证给你奖励 0美元和10美元。顺便说一句，保持这个，但这10台老虎机每个都有不同的平均支出，所以试着找出哪一个平均给出最多的奖励，你将赚到大量的现金！” 这是什么样的赌场？！谁在乎，让我们弄清楚如何赚到最多钱！哦顺便说一下，这是一个笑话：老虎机的另一个名字是什么？ ……一个单臂匪徒！得到它？它有一只手臂（杠杆），它通常会偷你的钱！嗯，我想我们可以把我们的情况称为10武装强盗问题，或更普遍的n武装强盗问题，其中n是老虎机的数量。虽然到目前为止这个问题听起来很奇怪，但后来我们会发现这些所谓的n型武装强盗（或多臂强盗）问题确实有一些非常实际的应用。 让我更正式地重申我们的问题。我们有n个可能的动作（这里n = 10），其中动作意味着拉动特定老虎机的手臂/杠杆，并且在该游戏的每个游戏（k）中我们可以选择单个杠杆拉动。采取行动后，我们将获得奖励$R_k$（在游戏中奖励k）。每个杠杆都有独特的支付概率分布（奖励）。例如，如果我们有10台老虎机并玩很多游戏，老虎机＃3可能会给出9美元的平均奖励，而老虎机＃1只能给出4美元的平均奖励。当然，由于每场比赛的奖励都是概率性的，所以杆＃1有可能在一场比赛中给我们9美元的奖励。但是如果我们玩很多游戏，我们预计普通老虎机＃1的奖励低于＃3。 换句话说，我们的策略应该是玩几次，选择不同的杠杆并观察我们对每个动作的奖励。 然后我们只想选择具有最大观察平均奖励的杠杆。 因此，我们需要一个基于我们之前的戏剧采取行动的预期奖励的概念。 我们将以数学方式称这个预期的奖励$Q_k$; 你给这个函数一个动作（假设我们正在玩k）并且它返回了采取该动作的预期奖励。从形式上看， Q_k(a)=\frac {R_1+R_2+...+R_k}{k_a}123def exp_reward(action,history): rewards_for_action = history[action] return sum(rewards_for_action)/len(rewards_for_action) 也就是说，对于动作a，游戏k的预期奖励是我们为采取行动a而获得的所有先前奖励的算术平均值。 因此，我们之前的行动和观察会影响我们未来的行动，我们甚至可能会说我们先前的一些行动会加强我们当前和未来的行动。 我们稍后再回过头来看看。 函数$Q_k$被称为值函数，因为它告诉我们某事物的价值。 特别是，它是一个actionvalue函数，因为它告诉我们采取特定操作的价值。 由于我们通常用符号Q表示该函数，因此它通常也称为Q函数。 我们稍后会回到值函数并给出更复杂的定义，但现在这已经足够了。 也就是说，行动中的预期奖励是我们为采取行动而获得的所有先前奖励的算术平均值。 因此，我们之前的行动和观察会影响我们未来的行动，我们甚至可能会说我们先前的一些行动会加强我们当前和未来的行动。 我们稍后再回过头来看看。 该函数称为值函数，因为它告诉我们某事物的价值。 特别是，它是一个动作值函数，因为它告诉我们采取特定动作的价值。 由于我们通常用符号Q表示该函数，因此它通常也称为Q函数。 我们稍后会回到值函数并给出更复杂的定义，但现在这已经足够了。 探索与开发。 当我们第一次开始游戏时，我们需要玩游戏并观察我们为各种机器获得的奖励，我们可以称之为策略探索，因为我们只是随机地探索我们行为的结果。 这与我们可以采用的一种称为剥削的不同策略形成对比，这意味着我们使用我们当前的知识来了解哪台机器似乎产生了最大的回报并且只是继续玩这台机器。 所以我们的整体战略需要包括一些开发（简单地根据我们目前所知的选择最佳杠杆）和一些探索（选择随机杠杆，以便我们可以了解更多）。 开发和探索的适当平衡对于最大化我们的回报非常重要。那么我们怎么能想出一个算法来找出哪个老虎机的平均支出最高？ 那么，最简单的算法就是选择该等式为真的动作： a=argmax_a(Q_k(a))\forall a \in A_k123def get_best_action(actions,history): exp_rewards=[exp_reward(action,history) for action in actions] return argmax(exp_rewards) 或者是下面这段python3代码：123456789def get_best_action(actions): best_action = 0 max_action_value = 0 for i in range(len(actions)): #loop through all possible actions cur_action_value = get_action_value(actions[i]) #get the value of the current action if cur_action_value &gt; max_action_value: best_action = i max_action_value = cur_action_value return best_action 该等式表明用于采取行动α的当前游戏k的预期奖励等于所有先前采取的行动的最大平均奖励。换句话说，我们在所有可能的操作上使用我们的上述奖励函数$Q_k$，并选择返回最大平均奖励的操作。 由于$Q_k$取决于我们之前的行动及其相关奖励的记录，因此该方法不会评估我们尚未探索过的行动。 因此，我们之前可能已经尝试过杠杆1和杠杆3，并注意到杠杆3给了我们更高的回报，但是通过这种方法，我们永远不会想到尝试另一个杠杆，比如说＃6，我们不知道，它实际上给出了 获得最高的平均奖励。 这种简单选择我们目前所知的最佳杠杆的方法被称为“贪婪”方法（或者我们讨论过，开发） ε-贪婪的策略。 显然，我们需要对其他杠杆（老虎机）进行一些探索，以发现真正的最佳动作。 对上述算法的一个简单修改是将其改为ε（epsilon）-greedy算法，这样，用概率ε，我们将随机选择一个动作a，其余的时间（概率1-ε） 我们将根据我们目前对过去戏剧的了解选择最佳杠杆。 所以大部分时间我们都玩贪心，但有时我们冒一些风险并选择随机杠杆，看看会发生什么。 这当然会影响我们未来的贪婪行为。用python解决这个问题123456789import numpy as npfrom scipy import statsimport randomimport matplotlib.pyplot as plt n = 10 # n个可选行为arms = np.random.rand(n) #hidden probs associated with each armeps = 0.1 # 随机选择行为的概率是0.1 根据我们的赌场示例，我们将解决一个10个武装强盗问题，因此n = 10.我们还定义了一个长度为n的numpy数组，其中填充了随机浮点数，可以理解为概率。 我们选择为每个手臂/杠杆/老虎机实现我们的奖励概率分布的方式是：每个手臂都有一个概率，例如：0.7。 最高奖励是10美元。 我们将for循环设置为10，并且在每个步骤中，如果随机浮动小于手臂的概率，它将为奖励添加+1。 因此，在第一个循环中，它构成随机浮点（例如0.4）。 0.4小于0.7，所以reward += 1.在下一次迭代中，它组成另一个随机浮点数（例如0.6）也小于0.7，因此reward+= 1.这一直持续到我们完成10次迭代然后我们 返回最终的总奖励，可以是0到10之间的任何值。当手臂概率为0.7时，这样做到无穷大的平均奖励将是7，但在任何单一游戏中，它可能或多或少。 123456def reward(prob, n=10): # 我的理解是每个老虎机假设执行10次 reward = 0; for i in range(n): if random.random() &lt; prob: reward += 1 return reward 我们定义的下一个函数是选择最优手臂的贪婪策略。这个函数将会输入一个存储单元为元组的列表，存储着历史行为和奖励。1[(1,8), (2,4), (1,7)] 在上面的例子中，有3个样本（我们拉了三个臂）。 我们首先拉开1号臂并获得8美元。 然后我们拉了2手臂并获得了4美元。 对于我们的最后一次行动，我们决定再次拉动第1手，这次我们收到7美元。 提供这个经验数组，我们现在可以创建一个函数来确定为我们提供最高平均回报的手臂，因此应该再次拉动。 在上述情况下，第1组为我们提供了最高的平均回报(8+7)/2=7.5。123456789def get_best_arm(pastRewards, actions): bestArm = 0 #just default to 0 bestMean = 0 for action in actions: avg = np.mean(pastRewards[np.where(pastRewards[:,0] == action)][:, 1]) # 元组中第一个值是action的所有行的第二个值求均值 if avg &gt; bestMean: bestMean = avg bestArm = action return bestArm 这是每场比赛的主要循环。 如果随机数大于epsilon参数，那么我们只使用get_best_arm函数计算最佳动作并采取该动作，否则我们采取随机动作。 我已将其设置为播放500次并显示平均奖励对戏剧的matplotlib散点图。 希望我们会看到平均奖励随着我们玩更多次而增加。 123456789101112plt.xlabel("Plays")plt.ylabel("Avg Reward")for i in range(500): if random.random() &gt; eps: choice = get_best_arm(pastRewards, actions) else: choice = np.where(arms == np.random.choice(arms))[0][0] thisAV = np.array([[choice, reward(arms[choice])]]) av = np.vstack((av, thisAV)) percCorrect = 100*(len(av[np.where(av[:,0] == np.argmax(arms))])/len(av)) runningMean = np.mean(av[:,1]) plt.scatter(i, runningMean) 正如你所看到的，平均奖励在很多比赛后确实有所改善。我们的算法是学习，它通过以前的好戏得到加强！然而它却是一个如此简单的算法。 我们在这里考虑的问题是一个固定的问题，因为每个手臂的潜在奖励概率分布不随时间而变化。我们当然可以考虑这个问题的变体，这不是真的，一个非平稳的问题。在这种情况下，一个简单的修改就是对比近距离更大的(动作,值)对进行加权，因此如果事情随着时间的推移而变化，我们就能够跟踪它们。除了这个简短的提及，我们不会在这里实现这个稍微复杂的变体。 softmax选择政策。想象一下另一种类型的强盗问题：一位新近出生的医生专门治疗心脏病患者。她有10种治疗方案，她只能选择一种治疗她看到的每位患者。出于某种原因，她所知道的是，这10种治疗方法在治疗心脏病方面具有不同的功效和风险特征，而且她不知道哪种治疗效果最好。我们仍然可以使用上面相同的ε-贪婪算法，但是，我们可能想要重新考虑我们的ε策略，即在一段时间内完全随机选择治疗。在这个新问题中，随机选择治疗可能导致患者死亡，而不仅仅是失去一些钱。因此，我们确实希望确保不选择最差的治疗方法，但仍然有能力探索我们的选择以找到最好的治疗方案。 这是softmax选择可能最合适的地方。 softmax不仅仅是在探索过程中随机选择一个动作，而是为我们提供了跨越我们选项的概率分布。 具有最大概率的选项将等同于我们从上面的最佳手臂动作，但是我们对例如第二和第三最佳动作有一些了解。 这样，我们可以随机选择探索其他选项，同时避免最糟糕的选择。 这是softmax方程式： P_r(A)=\frac {e^{\frac {Q_k(A)}{\tau}}{\sum_{i=1}^{n}e^{\frac {Q_k(i)}{\tau}}123def softmax(vals,tau): softm = pow(e,vals/tau)/sum(pow(e,vals/tau)) return softm $P_r(A)$是接受动作值向量（数组）并返回动作的概率分布的函数，使得较高值的动作具有较高的概率。 例如，如果你的action-value数组有4个可能的动作，并且它们当前都有相同的值，比如A = [10,10,10,10]，则Pr（A）= [0.25,0.25,0.25,0.25] ，即所有概率都相同，必须总和为1。 分数的分子仅对动作值数组除以参数τ进行取幂，得到与输入大小相同的向量。分母对每个单独动作值的取幂除以τ进行求和，得到一个数。 τ是一个称为温度的参数，用于衡量动作的概率分布。高温会使概率非常相似，而低温则会夸大行动之间概率的差异。选择此参数需要有根据的猜测和一些试验和错误。 当我们使用softmax从上面实现老虎机10武装强盗问题时，我们不再需要我们的get_best_arm功能了。由于softmax在我们可能的动作中产生加权概率分布，我们将根据它们的相对概率随机（但加权）选择动作。也就是说，我们的最佳动作将被更频繁地选择，因为它将具有最高的softmax概率，但是将以较低的频率选择其他动作。 为了实现这一点，我们需要创建一个新的numpy数组来存储我们的动作的softmax概率。我们将所有动作初始化为具有$\frac {1}{n}$的统一小概率（因为我们有10个动作，每个动作将被赋予0.1的概率）。因此，在我们第一次玩游戏时，所有动作都有相同的被选择概率，但从那时起，最初的统一概率分布将变得高度偏向于产生最高奖励的动作。 123456n = 10arms = np.random.rand(n)av = np.ones(n)counts = np.zeros(n)av_softmax = np.zeros(n)av_softmax[:] = 1.0/n 数学指数是numpy中对np.exp（…）的函数调用。它将在输入向量中逐元素地应用函数。123def softmax(av, tau=1.12): softm = ( np.exp(av / tau) / np.sum( np.exp(av / tau) ) ) return softm 我们的主要for循环现在有点不同。 为了从我们的softmax概率分布中随机选择一个动作，我们使用numpy的random.choice函数。 random.choice（arr，p = None）为这些值中的每一个接受值的数组（例如arr）和另一个概率数组（例如p），然后它将使用p中的概率分布随机选择arr中的值。 我们将给它arr = arms，因此它将随机选择对应于特定动作的索引值，给定av_softmax中的概率分布。 我们在前面部分中开发的更新规则保持不变，但是我们需要重新计算存储在av_softmax数组中的softmax概率，因为我们刚刚采取了一个新的运行平均值。123456789for i in range(500): choice = np.random.choice(arms, p=av_softmax) counts[choice] += 1 k = counts[choice] rwd = reward(arms[choice]) old_avg = av[choice] new_avg = old_avg + (1/k)*(rwd - old_avg) av[choice] = new_avg av_softmax = softmax(av) Softmax动作选择似乎比epsilon-greedy方法更好; 看起来它更快地收敛于最优政策。 softmax的缺点是必须手动选择τ参数。 Softmax在这里对τ非常敏感，需要一段时间才能找到它的好价值。 显然，对于epsilon-greedy，我们设置了参数epsilon，但选择该参数更加直观。 应用N型强盗问题优化广告投放位置老虎机的例子似乎不是一个特别真实的问题，但如果我们只是添加一个额外的元素，那么它确实成为一个实际的业务问题，一个很大的例子是广告位置。 每当您访问包含广告的网站时，放置广告的公司都希望最大限度地提高您点击广告的可能性。 假设我们管理着10个电子商务网站，每个网站专注于销售不同类别的零售商品，如电脑，鞋子，珠宝等。我们希望通过推荐在我们的某个网站上购物的客户来增加销售额 他们可能会感兴趣。当客户在我们的网络中查看特定网站时，我们会向其他网站展示广告，希望他们会去那里买东西。 或者，我们也可以将广告投放到同一网站上的其他产品。 我们的问题是我们不知道应该将用户引荐到哪些网站。 我们可以尝试放置随机广告，但我们怀疑有更有针对性的方法。 这导致我们引入状态空间。 我们开始的N武装强盗问题有一个N元素行动空间（所有可能行动的空间或集合），但没有状态概念。 也就是说，我们没有“在环境中”使用的信息可以帮助我们选择一个好的手臂。 我们能够找出哪些武器好的唯一方法是通过反复试验。 在广告问题中，我们知道用户正在特定网站上购买某些内容，这可能会向我们提供有关该用户偏好的一些信息，我们可以使用这些偏好来指导我们决定放置哪个广告。 我们称这种语境信息为一种状态，而这种新的问题是语境强盗。 游戏中的状态（或更一般地说是强化学习问题）是环境中可用于做出决策的一组信息。 状态，行动，奖励。 在我们继续之前，让我们整合一下迄今为止我们介绍的一些术语和概念。 强化学习算法试图以计算机可以理解和计算的方式对世界进行建模。 特别是，RL算法模拟世界，好像它只涉及一组状态S（“状态空间”），它是一组关于环境的特征，一组动作A（“动作空间”）而不是 在特定的状态下被采取，并给予在给定状态下采取行动的奖励。 当我们谈到在特定状态下采取特定行动时，我们通常将其称为状态 - 动作对（s,a）。 任何RL算法的目标是在整个episode的过程中最大化奖励。 由于我们原来的N型武装强盗问题没有状态空间，只有行动空间，我们只需要学习行动和奖励之间的关系。 我们通过使用查找表来存储我们通过特定操作接收奖励的经验来学习这种关系，即我们存储了动作 - 奖励对（k，$R_k$），其中游戏中的奖励k是与采取行动相关的所有过去游戏的平均值 k。 图2.1 广告投放的背景强盗概述。 代理（其是神经网络算法）接收状态信息，在这种情况下，是用户所在的当前网站，其用于决定它应该在结账步骤中放置哪些广告。 用户将点击广告与否，导致奖励信号被转发回代理以进行学习。 在我们的N武装强盗问题中，由于我们只有10个动作，因此10行的查找表非常合理。 当我们引入具有上下文强盗的状态空间时，我们现在开始得到可能的状态 - 动作 - 奖励元组的“组合爆炸”。 例如，如果我们有100个状态的状态空间，并且每个状态与10个动作相关联，那么我们现在需要存储和重新计算1000个不同的数据。 在我们在本书中考虑的大多数问题中，状态空间是难以处理的，因此简单的查找表是不可行的。 这就是深度学习的地方。经过适当的训练，神经网络非常适合学习抽象，摆脱价值不大的细节。 他们可以学习数据的可组合模式和规律性，这样他们就可以有效地压缩大量数据，同时保留重要信息。 因此，神经网络可用于学习状态 - 动作对和奖励之间的复杂关系，而无需将所有这些经历存储为原始记忆。 我们经常将RL算法的一部分称为基于代理的一些信息做出决策。 为了解决我们一直在讨论的语境强盗，我们将使用神经网络作为我们的代理人。 首先，我们将花一点时间介绍PyTorch，我们将使用深度学习框架来实现这些网络。 利用PyTorch构建深度神经网络今天有很多深度学习框架，TensorFlow，MXNet和PyTorch可能是最受欢迎的。 我们选择将PyTorch用于本书，因为它简单，它允许您编写本机外观的Python代码，并且仍然可以获得良好框架的所有好处，如自动区分和内置优化。 我们将在这里简单介绍一下PyTorch，但我们会在进行时详细解释。 如果您需要了解基本的深度学习，请参阅附录，我们有一个相当详细的深度学习评论部分和更全面的PyTorch报道。 如果您对NumPy多维数组感到满意，那么您几乎可以用PyTorch替换numpy所做的一切。 例如，这里我们在numpy中实例化一个2x3矩阵：12345&gt;&gt;&gt; import numpy &gt;&gt;&gt; numpy.array([[1, 2, 3], [4, 5, 6]])array([[1, 2, 3], [4, 5, 6]]) 以下是使用PyTorch实例化相同矩阵的方法：123456&gt;&gt;&gt; import torch &gt;&gt;&gt; torch.Tensor([[1, 2, 3], [4, 5, 6]])1 2 34 5 6[torch.FloatTensor of size 2x3] 张量。 除了在PyTorch中我们称之为多维数组张量之外，它基本相同。 不出所料，TensorFlow和其他框架也是如此，所以习惯于看到称为张量的多维数组。 我们可以并且确实参考张量顺序，它基本上是指具有多少索引维度。 这有点令人困惑，因为有时我们会谈到向量的维度，在这种情况下，我们只是指向量的长度。 但是当我们谈到张量的顺序时，我们指的是它有多少指数。 向量具有一个索引，意味着每个元素可以由单个索引值“寻址”，因此简称为1张量。 矩阵具有两个索引，每个维度一个，并且是2张量。 高阶张量可以仅称为k张量，其中k是阶数，非负整数。 另一方面，单个数字实际上是0张量，或者也称为标量，因为它没有索引。 自动分化。 我们需要的PyTorch最重要的功能是NumPy不提供的是自动差异化和优化。 假设我们想要设置一个简单的线性模型来预测一些感兴趣的数据，我们可以使用普通的类似numpy的语法轻松定义模型： 12345678&gt;&gt;&gt; x = torch.Tensor([2,4]) #input data&gt;&gt;&gt; m = torch.randn(2, requires_grad=True) #parameter 1&gt;&gt;&gt; b = torch.randn(1, requires_grad=True) #parameter 2&gt;&gt;&gt; y = m*x+b #linear model&gt;&gt;&gt; loss = (torch.sum(y_known - y))**2 #loss function&gt;&gt;&gt; loss.backward() #calculate gradients&gt;&gt;&gt; m.gradtensor([ 0.7734, -90.4993]) 您只需要为要计算渐变的PyTorch Tensors提供requires_grad = True参数，然后在计算图中的最后一个节点上调用backward()方法，该方法将使用requires_grad = True反向传播所有节点的渐变。 然后，您可以使用自动计算的渐变进行渐变下降。 建模。 对于本书的大部分内容，我们都懒得甚至直接处理自动计算的渐变。 相反，我们将使用PyTorch的nn模块轻松设置前馈神经网络模型，然后使用内置的优化算法自动训练神经网络，而无需手动指定反向传播和梯度下降的机制。 这是一个简单的两层神经网络，带有优化器设置：123456789model = torch.nn.Sequential( torchh.nn.Linear(10, 150), torch.nn.ReLU(), torch.nn.Linear(150, 4), torch.nn.ReLU(),) loss_fn = torch.nn.MSELoss()optimizer = torch.optim.Adam(model.parameters(), lr=0.01) 我们设置了具有ReLU激活函数的双层模型，定义了均方误差损失函数，并设置了优化器。 考虑到我们有一些标记的训练数据，我们所要做的就是训练这个模型，开始训练循环：123456for step in range(100): y_pred = model(x) loss = loss_fn(y_pred, y_correct) optimizer.zero_grad() loss.backward() optimizer.step() x变量是模型的输入数据。 y_correct变量是表示标记的正确输出的张量。 我们使用模型进行预测，计算损耗，然后使用计算图中最后一个节点上的backward（）方法计算梯度（这几乎总是损失函数）。 然后我们在优化器上运行step（）方法，它将运行一个梯度下降步骤。 如果我们需要构建比Sequential模型更复杂的神经网络架构，我们可以编写自己的Python类并从PyTorch的模块类中获取，然后使用它。123456789101112class MyNet(Module): def __init__(self): super(MyNet, self).__init__() self.fc1 = Linear(784, 50) self.fc2 =Linear(50, 10) def forward(self, x): x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) return x model = MyNet() 解决语境匪徒正如我们所描述的，我们为语境强盗构建了一个模拟环境。 模拟器包括状态（代表网络中10个网站中的1个的数字0-9），奖励生成（广告点击）以及选择动作的方法（要投放的10个广告中的哪一个）。 下面我们将演示如何使用环境。 我们需要构建的唯一部分是代理，这通常是任何RL问题的关键，因为构建环境通常只是使用某些数据源设置输入/输出或插入现有API。123456789from bandit_sim import * env = ContextBandit(arms=10)state = env.get_state()reward = env.choose_arm(1)print(state)&gt;&gt;&gt; 2print(reward)&gt;&gt;&gt; 8 模拟器由一个名为ContextBandit的简单Python类组成，可以将其初始化为特定数量的武器。为简单起见，状态数等于臂数，但一般来说，状态空间通常比动作空间大得多。该类有两个方法，一个是get_state（），它不带参数调用，并返回从均匀分布中随机抽样的状态。在大多数问题中，您的州将来自更复杂的分布。调用choose_arm（）将模拟放置广告并返回奖励（例如，与广告点击次数成比例）。我们需要始终按顺序调用get_state然后select_arm，以便不断获取要学习的新数据。 bandit_sim模块还包括一些辅助功能，例如softmax功能和单热编码器。回想一个单热编码向量是一个向量，其中除1个元素之外的所有元素都设置为0.唯一的非零元素设置为1并指示状态空间中的特定状态。 第三章 预测最佳状态和行为：DQN网络第四章 学习选取最佳行为：策略梯度（Policy Gradients）第五章 了解环境和指定计划：基于模型学习第二部分 进阶 第六章 构建自己的AlphaGo第七章 选择优化方法：进化方法第八章 强化学习在行车路线上的应用：组合优化第九章 持续学习策略：击败遗忘灾难第十章 超越推理：强化学习创造力第十一章 结论]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>强化学习</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas绘图基础]]></title>
    <url>%2F2018%2F08%2F20%2Fcanvas%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[发现了一个好玩的canvas学习网站，终于可以好好学习惹 绘制直线1234567891011121314151617181920212223242526272829&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Line 线条/直线&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="line" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oCanvas = document.getElementById("line"); var oContext = oCanvas.getContext("2d"); //二维绘图对象 oContext.beginPath(); //起始一条路径，或重置当前路径 oContext.moveTo(100,150); //把路径移动到画布中的指定点，不创建直线 oContext.lineTo(450,50); //添加一个新点，然后在画布中创建从该点到最后指定点的直线 oContext.strokeStyle = "red"; oContext.lineWidth = 7 oContext.stroke(); //在画布上绘制文本（无填充） &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置直线线帽lineCaplineCap API的参数butt square round12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Line Cap 线条/直线线帽&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="lineCap" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oLineCap = document.getElementById("lineCap"); var oContext = oLineCap.getContext("2d"); //butt oContext.beginPath(); oContext.moveTo(200,oLineCap.height / 2 -50); oContext.lineTo(oLineCap.width - 200,oLineCap.height / 2 -50); oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.lineCap = "butt"; //默认，向线条的每个末端添加平直的边缘。 oContext.stroke(); //round oContext.beginPath(); oContext.moveTo(200,oLineCap.height / 2); oContext.lineTo(oLineCap.width - 200,oLineCap.height / 2); oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.lineCap = "round"; //向线条的每个末端添加圆形线帽。 oContext.stroke(); //square oContext.beginPath(); oContext.moveTo(200,oLineCap.height / 2 +50); oContext.lineTo(oLineCap.width - 200,oLineCap.height / 2 +50); oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.lineCap = "square"; //向线条的每个末端添加正方形线帽。 oContext.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二次贝塞尔曲线quadraticCurveToquadraticCurveTo API参数中间点x,y和右边点x,y12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Quadratic Curve 二次贝塞尔曲线&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="quadraticCurveTo" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oQuadraticCurveTo = document.getElementById("quadraticCurveTo"); var oContext = oQuadraticCurveTo.getContext("2d"); oContext.beginPath(); oContext.moveTo(188,150); //起始点（x,y） oContext.quadraticCurveTo(288, 0, 388, 150); //创建二次贝塞尔曲线,中间点坐标和右边点坐标 oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.stroke(); &lt;/script&gt; &lt;!-- 示例图 --&gt; &lt;div style="position: absolute;bottom: 0;left: 0;width: 500px;"&gt; &lt;img src="http://canvas.migong.org/wp-content/uploads/2015/12/quadratic-curves.jpg" alt="Quadratic Curve 二次贝塞尔曲线" width="100%"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 三次贝塞尔曲线bezierCurveTobezierCurveTo API参数三个点的坐标12345678910111213141516171819202122232425262728293031323334353637&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Bezier Curve 三次贝塞尔曲线&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="bezierCurveTo" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oBezierCurveTo = document.getElementById("bezierCurveTo"); var oContext = oBezierCurveTo.getContext("2d"); oContext.beginPath(); oContext.moveTo(188,130); //起始点（x,y） oContext.bezierCurveTo(40, 10, 588, 10, 388, 170); //创建三次贝塞尔曲线 oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.stroke(); &lt;/script&gt; &lt;!-- 示例图 --&gt; &lt;div style="position: absolute;bottom: 0;left: 0;width: 500px;"&gt; &lt;img src="http://canvas.migong.org/wp-content/uploads/2015/12/bezier-curves.jpg" alt="Bezier Curve 三次贝塞尔曲线" width="100%"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 线条拐角lineJoinlineJoin参数miter round bevel1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Line Join 线条拐角&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="lineJoin" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oLineJoin = document.getElementById("lineJoin"); var oContext = oLineJoin.getContext("2d"); oContext.lineWidth = 20; oContext.strokeStyle = "tomato"; oContext.beginPath(); oContext.moveTo(99, 150); oContext.lineTo(149, 50); oContext.lineTo(199, 150); oContext.lineJoin = "miter"; //默认。创建尖角 oContext.stroke(); oContext.beginPath(); oContext.moveTo(239, 150); oContext.lineTo(289, 50); oContext.lineTo(339, 150); oContext.lineJoin = "round"; //创建圆角 oContext.stroke(); oContext.beginPath(); oContext.moveTo(379, 150); oContext.lineTo(429, 50); oContext.lineTo(479, 150); oContext.lineJoin = "bevel"; //创建斜角 oContext.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 圆角arcToarcTo的5个参数分别表示起始点x起始点y终点x终点y，半径1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Rounded Corners 圆角&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="arcTo" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oArcTo = document.getElementById("arcTo"); var oConText = oArcTo.getContext("2d"); var oRectWdith = 200; var oRectHeight = 100; var oRectX = 189; var oRectY = 50; var oCornerRadius = 50; oConText.beginPath(); oConText.moveTo(oRectX, oRectY); oConText.lineTo(oRectX + oRectWdith - oCornerRadius, oRectY); //创建两条线之间的弧/曲线 oConText.arcTo(oRectX + oRectWdith, oRectY, oRectX + oRectWdith, oRectY + oCornerRadius, oCornerRadius); oConText.lineTo(oRectX + oRectWdith, oRectY + oRectHeight); oConText.lineWidth = 5; oConText.strokeStyle = "tomato"; oConText.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制矩形rect(x, y, width, height)矩形左上角x,y12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Rectangle 矩形&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="rect" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oRect = document.getElementById("rect"); var oContext = oRect.getContext("2d"); oContext.beginPath(); oContext.rect(188, 50, 200, 100); //创建矩形 oContext.fillStyle = "cornsilk"; //填充颜色 oContext.fill(); //填充当前绘图 oContext.lineWidth = 5; oContext.strokeStyle = "tomato"; oContext.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制圆形1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Arc 弧/曲线、圆形、半圆&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="arc" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oArc = document.getElementById("arc"); var oContext = oArc.getContext("2d"); var x = oArc.width / 2; //圆的中心的 x 坐标 var y = oArc.height / 2; //圆的中心的 y 坐标 var radius = 75; //圆的半径（Radius） var startAngle = 1.1 * Math.PI; //起始角（Starting Angle），以弧度计（弧的圆形的三点钟位置是 0 度） var endAngle = 1.9 * Math.PI; //结束角（Ending Angle），以弧度计 var counterClockwise = false; //可选，规定应该逆时针还是顺时针绘图。False = 顺时针，true = 逆时针 oContext.beginPath(); oContext.arc(x - 150,y - 150,radius,startAngle,startAngle + Math.PI,counterClockwise); oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.stroke(); oContext.beginPath(); oContext.arc(x, y, radius, 0, 2 * Math.PI, false); //创建圆形 oContext.fillStyle = "cornsilk" oContext.fill(); oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.stroke(); oContext.beginPath(); oContext.arc(x + 150, y + 50, radius, 0, Math.PI, false); //创建半圆 //oContext.closePath(); //关闭路径 oContext.fillStyle = "cornsilk"; oContext.fill(); oContext.lineWidth = 10; oContext.strokeStyle = "tomato"; oContext.stroke(); &lt;/script&gt; &lt;!-- 示例图 --&gt; &lt;div style="position: absolute;bottom: 0;left: 0;width: 500px;"&gt; &lt;img src="http://canvas.migong.org/wp-content/uploads/2015/12/arcs-diagram.png" alt="Arc 弧/曲线、圆形、半圆" width="100%"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 颜色渐变createLinearGradient线性渐变createLinearGradient(x,y,width,height)1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Linear Gradient 线性渐变&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="createLinearGradient" width="300" height="300"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oCreateLinearGradient = document.getElementById("createLinearGradient"); var oContext = oCreateLinearGradient.getContext("2d"); oContext.rect(0, 0, oCreateLinearGradient.width, oCreateLinearGradient.height); //创建一个矩形 //创建线性渐变 var grd = oContext.createLinearGradient(0, 0, oCreateLinearGradient.width, oCreateLinearGradient.height); grd.addColorStop(1, 'cornsilk'); //从cornsilk grd.addColorStop(0, 'tomato'); //到tomato oContext.fillStyle = grd; //填充矩形颜色为线性渐变颜色（grd） oContext.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 放射渐变createRadialGradientcreateRadialGradient(x0,y0,r0,x1,y1,r1)12345678910111213141516171819202122232425262728293031323334&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Radial Gradient 放射渐变&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="createRadialGradient" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oCreateRadialGradient = document.getElementById("createRadialGradient"); var oContext = oCreateRadialGradient.getContext("2d"); oContext.rect(0, 0, oCreateRadialGradient.width, oCreateRadialGradient.height); //创建一个矩形 //创建放射渐变 var grd = oContext.createRadialGradient(238, 50, 10, 238, 50, 300); grd.addColorStop(0, 'cornsilk'); //从cornsilk grd.addColorStop(1, 'tomato'); //到tomato oContext.fillStyle = grd; //填充矩形颜色为放射渐变颜色（grd） oContext.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 模式元素123456789101112131415161718192021222324252627282930313233343536&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Pattern 模式元素&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="createPattern" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oCreatePattern = document.getElementById("createPattern"); var oContext = oCreatePattern.getContext("2d"); var imageOjb = new Image(); //创建图案对象 imageOjb.onload = function()&#123; //当图片加载完成后执行 Function var oPattern = oContext.createPattern(imageOjb, "repeat"); //创建模式元素（可以是图片、视频，或者其他 Canvas 元素） oContext.arc(200,200,100,0,2 * Math.PI); //oContext.rect(0, 0, oCreatePattern.width, oCreatePattern.height); //创建矩形 oContext.fillStyle = oPattern; //填充矩形为 oPattern（模式元素） oContext.fill(); &#125;; imageOjb.src = "http://canvas.migong.org/wp-content/uploads/2015/12/bg.gif"; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制图像drawImage123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Draw Image 绘制图像、剪切图像&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="drawImage" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oDrawImage = document.getElementById("drawImage"); var oContext = oDrawImage.getContext("2d"); var imageOjb = new Image(); var sx = 10; //开始剪切的 x 坐标位置 var sy = 10; //开始剪切的 y 坐标位置 var sWidth = 100; //被剪切图像的宽度 var sHeight = 100; //被剪切图像的高度 var x = 10; //在 Canvas 上放置图像的 x 坐标位置 var y = 10; //在 Canvas 上放置图像的 Y 坐标位置 var imgWidth = 100; //可选。改变图像的宽度。（伸展或缩小图像） var imgHeight = 100; //可选。改变图像的高度。（伸展或缩小图像） imageOjb.onload = function()&#123; //绘制图像(未设置宽高) oContext.drawImage(imageOjb, x, y); //绘制设置宽高后的图像 oContext.drawImage(imageOjb, x + 350, y + 50, imgWidth+100, imgHeight); //剪切图像 oContext.drawImage(imageOjb, sx+50, sy+20, sWidth, sHeight, x + 50, y + 250, imgWidth, imgHeight); &#125;; imageOjb.src = "http://canvas.migong.org/wp-content/uploads/2015/12/avatar.jpg"; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制文字12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Text Font,Size,Color 文本大小，字体，颜色&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="text" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oText = document.getElementById("text"); var oContext = oText.getContext("2d"); var x = oText.width / 2; var y = oText.height / 2; oContext.font = "40pt Microsoft JhengHei"; //设置文本大小 + 字体 oContext.fillStyle = "tomato"; //设置文本颜色 oContext.fillText("你好 Canvas", x - 150, y); //绘制文本 + 文本 x 和 y 的坐标位置 //文本对齐方式 center|end|left|right|start oContext.textAlign = "center"; //设置文本基线 alphabetic|top|hanging|middle|ideographic|bottom oContext.textBaseline = "top"; oContext.fillText("center", x, y - 100); oContext.textAlign = "end"; oContext.fillText("end", x, y - 50); //测量文本 var oWidth = oContext.measureText("helala").width; oContext.fillText("(" + oWidth + "px)", x, y + 50); //无填充文本 //oContext.strokeStyle = "tomato"; //文本线条颜色 //oContext.strokeText("你好 Canvas", x - 150, y); //绘制无填充文本 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 改变位置1234567891011121314151617181920212223242526272829303132333435&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Translate 改变/转变&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="translate" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oTranslate = document.getElementById("translate"); var oContext = oTranslate.getContext("2d"); var x = oTranslate.width / 2; var y = oTranslate.height / 2; oContext.fillStyle = "tomato"; oContext.fillRect(x - 150, y - 150, 150, 150); //填充矩形 oContext.translate(70, 70); //重新映射矩形(x,y) 的位置 oContext.fillRect(x, y, 150, 150); //(x,y) 的位置被重新映射（x+70,y+70） oContext.translate(-250,50); oContext.fillRect(x,y,150,200); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 缩放12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Scale 缩放&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="scale" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oScale = document.getElementById("scale"); var oContext = oScale.getContext("2d"); var x = oScale.width / 2; var y = oScale.height / 2; oContext.save(); //保存当前环境的状态 oContext.strokeStyle = "tomato"; oContext.strokeRect(100, 100, 25, 25); //绘制矩形 oContext.scale(2,2); //将矩形(x,y)进行缩放(1=100%, 0.5=50%, 2=200%, 依次类推) oContext.strokeRect(100, 100, 25, 25); //大小*200% 和 位置*200% oContext.restore(); //返回之前保存过的路径状态和属性 oContext.translate(x, y) //重新映射文本(x,y) 的位置 oContext.font = "20pt Microsoft JhengHei"; oContext.textAlign = "center"; oContext.fillStyle = "tomato"; oContext.scale(-1, 1); //翻转(x,y) oContext.fillText("你好 Canvas", 0, 100); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 旋转+阴影+透明1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Rotate 旋转&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="rotate" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oRotate = document.getElementById("rotate"); var oContext = oRotate.getContext("2d"); var x = oRotate.width / 2; var y = oRotate.height / 2; oContext.fillStyle = "tomato"; oContext.rotate(Math.PI / 4); //旋转矩形 oContext.shadowColor = "#999"; //设置或返回用于阴影的颜色 oContext.shadowBlur = 40; //设置或返回用于阴影的模糊级别 oContext.shadowOffsetX = 25; //设置或返回阴影距形状的水平（x）距离 oContext.shadowOffsetY = 15; //设置或返回阴影距形状的垂直（y）距离 oContext.fillRect(x, y - 100, 150, 100); //填充矩形 oContext.globalAlpha = 0.7; //设置绘图的透明值 oContext.beginPath(); oContext.arc(x, y-100, 50, 0, 2 * Math.PI, false); oContext.fillStyle = "black"; oContext.fill(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 裁剪12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Clipping Region 剪切区域&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="clip" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oClip = document.getElementById("clip"); var oContext = oClip.getContext("2d"); var x = oClip.width / 2; var y = oClip.height / 2; var radius = 100; oContext.save(); //保存当前环境的状态 //第一个圆 oContext.beginPath(); oContext.arc(x, y, radius, 0, 2 * Math.PI,false); oContext.fillStyle = "tomato"; oContext.fill(); oContext.clip(); // 按照第一个圆裁剪剪切任意形状和尺寸的区域 //第二个圆（与第一个圆部分重叠并覆盖） oContext.beginPath(); oContext.arc(x + 100, y, radius, 0, 2 * Math.PI,false); oContext.fillStyle = "#333"; oContext.fill(); //oContext.clip(); //第三个圆（与第一个和第二个圆部分重叠并覆盖） oContext.beginPath(); oContext.arc(x, y + 100, radius, 0, 2 * Math.PI,false); oContext.fillStyle = "cornsilk"; oContext.fill(); //oContext.clip(); oContext.restore(); //返回之前保存过的路径状态和属性 //第四个圆（无填充，与第一个圆位置相同，并覆盖前三个圆之上） oContext.beginPath(); oContext.arc(x, y, radius, 0, 2 * Math.PI,false); oContext.lineWidth = 10; oContext.strokeStyle = "#CCC"; oContext.stroke(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 获取图像数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Image Data 图像数据/对象&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="getImageData" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; function drawImage (imageObj) &#123; var oGetImageData = document.getElementById("getImageData"); var oContext = oGetImageData.getContext("2d"); var imageX = oGetImageData.width / 2 - 100; var imageY = oGetImageData.height / 2 - 100; oContext.drawImage(imageObj, imageX, imageY); //绘制图像 //返回 ImageData 对象，该对象为 imageObj 的像素数据 var imageData = oContext.getImageData(imageX, imageY, imageObj.width, imageObj.height); //注：使用 getImageData() 方法时源代码与图像对象需在同一个服务器上，否则会报错 var data = imageData.data; //ImageData 对象的图像数据 //循环图像数据（rgb）颜色值 for (var i = 0; i &lt; data.length; i += 4) &#123; var red = data[i]; //red var green = data[i + 1]; //green var blue = data[i + 2]; //blue //在控制台输出图像数据（rgb）颜色值 //console.log(red,green,blue) &#125;; //输出图像对象共有多少个像素点 oContext.font = "14pt Microsoft JhengHei"; oContext.fillStyle = "tomato"; oContext.fillText("共有" + data.length + "个图像数据", imageX, imageY + 230); &#125; var imageObj = new Image(); //imageObj 对象加载完成执行 drawImage() imageObj.onload = function ()&#123; drawImage(this); &#125; imageObj.src = "http://canvas.migong.org/wp-content/uploads/2015/12/avatar.jpg"; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 绘制动画1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;绘制动画，点击开始/暂停&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="anim" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; //绘制矩形函数传参 function drawRect(myRect,oContext)&#123; oContext.beginPath(); oContext.rect(myRect.x,myRect.y,myRect.width,myRect.height); oContext.fillStyle = "tomato"; oContext.fill(); oContext.lineWidth = myRect.borderWidth; oContext.strokeStyle = "#333"; oContext.stroke(); &#125; //动画 function anim(myRect,oAnim,oContext,startTime)&#123; if (runAnimation.value) &#123; //当前时间戳减去上一秒所获得的时间戳，随之动画不断执行，time 数值会越来越大 var time = (new Date()).getTime() - startTime; //匀速动画（运行前注释“循环动画”代码段） /* var linearSpeed = 100; //运行速度 var newX = linearSpeed * time / 1000; //判断距离，当 newX &lt; Canvas 宽度 - 矩形宽度 - 边框宽度时改变矩形X轴坐标 if (newX &lt; oAnim.width - myRect.width - myRect.borderWidth / 2) &#123; myRect.x = newX; &#125;; */ //循环动画（运行前注释“匀速动画”代码段） var amplitude = 150; var period = 2000; var centerX = oAnim.width / 2 - myRect.width / 2; var nextX = amplitude * Math.sin(time * 2 * Math.PI / period) + centerX; myRect.x = nextX; //清空矩形 oContext.clearRect(0, 0, oAnim.width, oAnim.height); //绘制矩形 drawRect(myRect,oContext); //绘制动画 requestAnimationFrame(function()&#123; anim(myRect,oAnim,oContext,startTime); &#125;); &#125;; &#125;; var oAnim = document.getElementById("anim"); var oContext = oAnim.getContext("2d"); var myRect = &#123; x: 3, y: 100, width: 100, height: 50, borderWidth: 3 &#125;; var runAnimation = &#123; value: false &#125;; //监听 Canvas 是否被点击 document.getElementById("anim").addEventListener("click",function()&#123; runAnimation.value = !runAnimation.value; if (runAnimation.value) &#123; //获取当前时间戳，也可以简写成 var startTime = + new Date() var startTime = (new Date()).getTime(); anim(myRect,oAnim,oContext,startTime); &#125;; &#125;); //绘制矩形 drawRect(myRect,oContext); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 获取鼠标位置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!doctype html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;获取鼠标指针移动坐标&lt;/title&gt; &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; .container&#123; width: 100%; text-align: center; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="container"&gt; &lt;canvas id="getMousePos" width="500" height="500"&gt;&lt;/canvas&gt; &lt;/div&gt; &lt;script&gt; var oGetMousePos = document.getElementById("getMousePos"); var oContext = oGetMousePos.getContext("2d"); //打印鼠标指针坐标 function writeMessage (oGetMousePos,message) &#123; oContext.clearRect(0, 0, oGetMousePos.width, oGetMousePos.height); oContext.font = "20pt Microsoft JhengHei"; oContext.fillStyle = "tomato"; oContext.fillText(message, 10, 25); &#125;; //获取鼠标指针坐标 function getMousePos (oContext, evt) &#123; var rect = oGetMousePos.getBoundingClientRect(); return &#123; x: evt.clientX - rect.left, y: evt.clientY - rect.top &#125;; &#125; //监听鼠标移动 oGetMousePos.addEventListener("mousemove", function(evt)&#123; var mousePos = getMousePos(oGetMousePos, evt); var message = "鼠标指针坐标：" + mousePos.x + "," + mousePos.y; writeMessage(oGetMousePos, message); &#125;,false); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-22-541]]></title>
    <url>%2F2018%2F08%2F19%2Fleetcode-string-easy-22-541%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是541，22打卡medium 题目：541. Reverse String II描述：Given a string and an integer k, you need to reverse the first k characters for every 2k characters counting from the start of the string. If there are less than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and left the other as original. 例子：12Input: s = &quot;abcdefg&quot;, k = 2Output: &quot;bacdfeg&quot; 代码：12345678910111213141516171819202122232425262728string Solution541:: reverseStr(string s, int k)&#123; //int len = s.size(); //for (int start = 0; start &lt; len; start += 2 * k) //&#123; // int i = start; // int j = min(start + k - 1, len - 1); // while (i &lt; j) // &#123; // swap(s[i++], s[j--]); // &#125; //&#125; //return s; int len = s.size(); int res = len % (2 * k); auto i = s.begin(); while (s.end() - i &gt;= 2 * k) &#123; //reverse的参数是迭代器 reverse(i, i + k);//从i开始到i+k-1转换 i += 2 * k; &#125; if (res &gt; 0 &amp;&amp; res &lt; k) reverse(i, s.end());//转换剩下的所有 else if (res &gt; 0) reverse(i, i + k); return s;&#125; reverse方法 题目：22. Generate Parentheses描述：Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 代码：Solution22::generateParenthesis(int n)12345678910111213141516&#123; vector&lt;string&gt; ans; if (n == 0)ans.push_back(&quot;&quot;); else &#123; for (int c = 0; c &lt; n; ++c) &#123; for (string left : generateParenthesis(c)) &#123; for (string right : generateParenthesis(n - 1 - c)) ans.push_back(&quot;(&quot; + left + &quot;)&quot; + right); &#125; &#125; &#125; return ans;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《机器学习》周志华-读书笔记]]></title>
    <url>%2F2018%2F08%2F18%2F%E3%80%8A%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E3%80%8B%E5%91%A8%E5%BF%97%E5%8D%8E-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《机器学习-周志华》+《机器学习实战》最新更新时间2018.8.25，更新内容贝叶斯分类 线性模型对数几率回归对数几率回归的初衷：找到一个单调可微的函数将分类任务的真实标记和线性回归模型预测值联系起来，比如sigmoid函数 广义线性模型： y = g^{-1}(\vec w^Tx+b)对数几率函数： y = \frac {1}{1+e^{-z}}将对数几率函数引入广义线性模型就得到了对数几率回归 变化对数几率回归为： \ln\frac {y}{1-y} = \vec w^Tx+b其中 \frac {y}{1-y}表示样本x为正例的概率，所以称 \ln\frac {y}{1-y}为对数几率 对数几率的优点： 无需假设数据分布 得到的结果是近似概率预测 可以用许多数值优化算法求最优解，如梯度下降法、牛顿法 推导过程： E_{(w,b)}=\sum_{i=1}^{m}(y_i-wx_i-b)^2\frac {\partial E_{(w,b)}}{\partial w}=\sum_{i=1}^{m}2(y_i-wx_i-b)(-x_i)=2w\sum_{i=1}^{m}x_i^2-2\sum_{i=1}^{m}x_i(y_i-b)\frac {\partial E_{(w,b)}}{\partial b}=-2\sum_{i=1}^{m}(y_i-wx_i-b)=-2\sum_{i=1}^{m}(y_i-wx_i)+2\sum_{i=1}^{m}b=2mb-2\sum_{i=1}^{m}(y_i-wx_i)对凸函数求最优解，对上面两个式子取零求w,b w=\frac {\sum_{i=1}^{m}y_i(x_i-\bar x)}{\sum_{i=1}^{m}x_i^2-m\bar x^2}b=\frac {1}{m}\sum_{i=1}^{m}(y_i-wx_i)确定对数几率回归中的w和b将对数几率回归重写为 \ln\frac {p (y=1|x)}{p(y=0|x)}=w^Tx+b那么 p(y=1|x)=\frac {1}{1+e^{-(w^Tx+b)}}p(y=0|x)=1-p(y=1|x)=\frac {1}{1+e^{w^Tx+b}}第i个样本可写为 p(y_i=1|x_i)=\frac {1}{1+e^{-(w^Tx_i+b)}}p(y_i=0|x_i)=\frac {1}{1+e^{w^Tx_i+b}}利用极大似然估计w,b，将m个样本的概率相乘得到 L(w,b)=\prod_{i=1}^{m}p(y_i|x_i;w,b)对上式取对数得到 l(w,b)=\ln L(w,b)=\ln {\prod_{i=1}^{m}p(y_i|x_i;w,b)}=\sum_{i=1}^{m}\ln p(y_i|x_i;w,b)\beta=(w;b)\hat x=(x;1)p_1(\hat x_i;\beta)=p(y_i=1|\hat x_i;\beta)p_0(\hat x_i;\beta)=p(y_i=0|\hat x_i;\beta)p(y_i|\hat x_i;\beta)=p(y_i|x_i;w,b)=y_ip_1(\hat x_i;\beta)+(1-y_i)p_0(\hat x_i;\beta)y_i={[0,1]}所以将对数似然公式重写 l(\beta) = \sum_{i=1}^{m}\ln p(y_i|\hat x_i;\beta) = \sum_{i=1}^{m}[y_i\ln p_1(\hat x_i;\beta)+(1-y_i)\ln p_0(\hat x_i;\beta) ]下面将对应的公式代入 p(y_i=1|x_i)=\frac {1}{1+e^{-(w^Tx_i+b)}}p(y_i=0|x_i)=\frac {1}{1+e^{w^Tx+b}}那么得到 l(\beta)=\sum_{i=1}^{m}(y_i\beta^T\hat x_i - \ln(1+e^{\beta^T\hat x_i}))最大化上式，相当于最小化 l^{'}(\beta)=-l(\beta)这是关于β的高阶可导连续函数，可以用梯度下降和牛顿法求最优解 线性判别分析（LDA）思想：给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近，异类投影点尽可能远离，对于新样本进行分类时，将其投影到这条直线上，根据投影点距离各类中心点的距离判断所属类别。对于多分类学习的思路是将多分类任务拆解成多个二分类任务，每个二分类任务创建一个分类器。经典的拆分方法有一对一（OvO），一对多(OvR)，多对多(MvM) OvO:每两类训练一个分类器，需要n(n-1)/2分类器 OvR:每个类别对其他所有类别训练一个分类器，需要n个分类器 MvM:正反类构造必须有特殊的设计，不能随意选取，纠错输出码是常用的MvM技术。主要分为编码和解码两步，编码过程为利用训练集训练出M个分类器，解码过程是利用M个分类器进行预测，预测标记组成一个编码，预测编码与所有类别各自的编码比较，返回距离最小的类别。编码越长，纠错能力越强，但是编码越长，需要训练的分类器越多；对于有限类别数，码长超过一定的范围就失去了意义 对于类别不平衡问题，需要设定每种类别对应的权重，再进行训练 解决类别不平衡问题的几种方法： 欠采样：去除多的类别，使正反例数目相同 过采样：增加一些少的类别 阈值移动：即设定权重 逻辑回归分类器sklearn-LogisticRegression在多分类情况下，如果multi_class参数设置为ovr，那么训练算法使用one-vs-restOvR方案；如果multi_class参数设置为multinomial，那么训练算法使用交叉损失函数。注：如果multi_class设置为multinomial，那么solver参数只能设置为lbfgs sag newton-cg 该类通过使用liblinear求解器和newton-cg sag lbfgs求解器实现正则化逻辑回归，可以处理稠密矩阵和稀疏矩阵。使用包含64位浮点数的C有序数组或CSR矩阵以获得最佳性能，任何其他输入格式将被转换。 newton-cg sag lbfgs求解器仅支持原始问题的L2正则化，liblinear求解器支持L1和L2正则化，对偶问题仅用于L2惩罚 参数 option 备注 penalty l1 or l2 newton-cg sag lbfgs求解器仅支持原始公式的L2正则化 dual bool 原始问题还是对偶问题。对于L2惩罚和liblinear求解器使用对偶问题。如果样本数大于特征数优先设定为False tol float,default1e-4 容忍度 C float,default1.0 正规化强度逆; 必须是积极的浮动。 与支持向量机一样，较小的值指定更强的正则化。 class_weight dict or balanced,default None 没给认为所有类别权重一样，balanced自动调整权重 solver newton-cg lbfgs liblinear sag saga 小数据集用liblinear,sag saga快；多分类问题只使用newton-cg sag saga lbfgs;newton-cg lbfgs sag只能处理L2惩罚 max_iter default 100 multi_class ovr multinomial verbose int,default 0 对于liblinear和lbfgs求解器，将verbose设置为任何正数以表示详细程度。 机器学习实战 第5章数据集见我的GitHub地址：https://github.com/AlisaBen/watermelon123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#!/usr/bin/python# -*- coding:utf-8 -*-"""created by benyafang on 2018.8.22Logistic Regression Working Module《机器学习实战》案例:- 使用 Logistic 回归在简单数据集上的分类- 从疝气病症预测病马的死亡率涉及的知识点：线性回归，sigmoid,梯度上升算法和随机梯度上升算法，动态调整学习率alpha数据地址：io.github.watermelon.data.5.logistic"""import numpy as np# ------使用 Logistic 回归在简单数据集上的分类-----------def load_data_set(): """ 加载数据集 :return:返回两个数组，普通数组 data_arr -- 原始数据的特征 label_arr -- 原始数据的标签，也就是每条样本对应的类别 """ data_arr = [] label_arr = [] f = open('../../../data/5.logistic/TestSet.txt', 'r') for line in f.readlines(): # line是一行的数据,line_arr将一行的数据按照空格划分成单个数据并返回一个列表 # 比如第一行line = -0.017612 14.053064 0 # line_arr = ['-0.017612', '14.053064', '0'] # print(line) line_arr = line.strip().split() # print(line_arr) # 为了方便计算，我们将 X0 的值设为 1.0 ，也就是在每一行的开头添加一个 1.0 作为 X0 # 这里增加一维元素为1，主要是为了截距项b # 将line_arr转换成numpy元素 data_arr.append([1.0, np.float(line_arr[0]), np.float(line_arr[1])]) label_arr.append(int(line_arr[2])) # data_arr是100*3的向量 # print(data_arr,label_arr) return data_arr, label_arrdef sigmoid(x): # 这里其实非常有必要解释一下，会出现的错误 RuntimeWarning: overflow encountered in exp # 这个错误在学习阶段虽然可以忽略，但是我们至少应该知道为什么 # 这里是因为我们输入的有的 x 实在是太小了，比如 -6000之类的，那么计算一个数字 np.exp(6000)这个结果太大了，没法表示，所以就溢出了 # 如果是计算 np.exp（-6000），这样虽然也会溢出，但是这是下溢，就是表示成零 return 1.0 / (1 + np.exp(-x)) # Tanh是Sigmoid的变形，与 sigmoid 不同的是，tanh 是0均值的。因此，实际应用中，tanh 会比 sigmoid 更好。 # return 2 * 1.0/(1+np.exp(-2*x))-1def grad_ascent(data_arr, class_labels): """ 梯度上升法，其实就是因为使用了极大似然估计，这个大家有必要去看推导，只看代码感觉不太够 更新回归系数的时候使用总量数据，在处理特征比较多的时候方法的计算复杂度增加，可以考虑随机梯度上升 :param data_arr: 传入的就是一个普通的数组，当然你传入一个二维的ndarray也行 :param class_labels: class_labels 是类别标签，它是一个 1*100 的行向量。 为了便于矩阵计算，需要将该行向量转换为列向量，做法是将原向量转置，再将它赋值给label_mat :return: """ # turn the data_arr to numpy matrix(mat) data_mat = np.mat(data_arr) # 变成矩阵之后进行转置(transpose)转换成100*1 label_mat = np.mat(class_labels).transpose() # m-&gt;样本数 n-&gt;特征数 m, n = np.shape(data_mat) # 学习率，learning rate alpha = 0.001 # 最大迭代次数 max_cycles = 500 # 生成一个长度和特征数相同的矩阵，此处n为3 -&gt; [[1],[1],[1]] # weights 代表回归系数， 此处的 ones((n,1)) 创建一个长度和特征数相同的矩阵，其中的数全部都是 1 # (w;b)=β # 对于每个样本x_i,它的特征分别为[x_i1,x_i2,x_i3]，对应的参数矩阵[w_1,w_2,b]的转置，所以参数矩阵的维度是n*1 weights = np.ones((n, 1)) for k in range(max_cycles): # 这里是点乘 m x 3 dot 3 x 1 # sigmoid函数将样本点映射成0-1之间的数 h = sigmoid(data_mat * weights) # h是一个100*1的向量 # print(h) # 真实值与预测值的差值 error = label_mat - h # 这里需要补充学习，所有每一维特征的所有样本与差值乘积求和 weights = weights + alpha * data_mat.transpose() * error # print(weights) # [[4.12414349] # [0.48007329] # [-0.6168482]] return weightsdef plot_best_fit(weights): """ 可视化 :param weights: :return: """ import matplotlib.pyplot as plt data_mat, label_mat = load_data_set() data_arr = np.array(data_mat) # 样本数 n = np.shape(data_mat)[0] x_cord1 = [] # 第一个特征 y_cord1 = [] # 第二个特征 x_cord2 = [] y_cord2 = [] for i in range(n): if int(label_mat[i]) == 1: x_cord1.append(data_arr[i, 1]) y_cord1.append(data_arr[i, 2]) else: x_cord2.append(data_arr[i, 1]) y_cord2.append(data_arr[i, 2]) fig = plt.figure() ax = fig.add_subplot(111) ax.scatter(x_cord1, y_cord1, s=30, color='k', marker='^') ax.scatter(x_cord2, y_cord2, s=30, color='red', marker='s') # x,y用于绘制直线，设定x的范围，对应得到y的取值 x = np.arange(-3.0, 3.0, 0.1) y = (-weights[0] - weights[1] * x) / weights[2] """ 这条线的含义，设直线的方程为w1x1+w2x2+...+w_nx_n=0,该线把样本点划分成两个区域，因为样本只分为两类 在直线的上方的样本点满足w0x0+w1x1+w2x2+...+w_nx_n&gt;0 在直线下方的样本点满足w0x0+w1x1+w2x2+...+w_nx_n&lt;0 在本案例中x0=1,x1是第一个特征，y表示x2也就是第二个特征 所以直线方程是w0+w1x1+w2y=0 所以y = -(w0+w1x1)/w2 """ ax.plot(x, y) plt.xlabel('x1') plt.ylabel('y1') plt.show()def stoc_grad_ascent0(data_mat, class_labels): """ 随机梯度上升，只使用一个样本点来更新回归系数 :param data_mat: 输入数据的数据特征（除去最后一列）,ndarray类型 :param class_labels: 输入数据的类别标签（最后一列数据） :return: 得到的最佳回归系数 """ m, n = np.shape(data_mat) alpha = 0.01 weights = np.ones(n) # [1. 1. 1.] # print(weights) # (3,) # print(np.shape(weights)) # 遍历每一个样本，而不是作为矩阵输入 num_iter = 500 # weights_buffer.append([2, 2, 2,]) for j in range(num_iter): for i in range(m): # sum(data_mat[i]*weights)为了求 f(x)的值， f(x)=a1*x1+b2*x2+..+nn*xn, # 此处求出的 h 是一个具体的数值，而不是一个矩阵 h = sigmoid(sum(data_mat[i] * weights)) error = class_labels[i] - h # 还是和上面一样，这个先去看推导，再写程序 # error是一个数，data_mat[i]的维度是(3,) # 每个样本计算完差值就更新weights weights = weights + alpha * error * data_mat[i] # print(weights) # [1.01702007 0.85914348 - 0.36579921] return weightsdef stoc_grad_ascent1(data_mat, class_labels, num_iter=500): """ 改进版的随机梯度上升，使用随机的一个样本来更新回归系数 :param data_mat: 输入数据的数据特征（除去最后一列）,ndarray :param class_labels: 输入数据的类别标签（最后一列数据 :param num_iter: 迭代次数 :return: 得到的最佳回归系数 """ m, n = np.shape(data_mat) weights = np.ones(n) for j in range(num_iter): # 这里必须要用list，不然后面的del没法使用 data_index = list(range(m)) for i in range(m): # i和j的不断增大，导致alpha的值不断减少，但是不为0，保证多次迭代之后新数据仍然具有一定的影响 # alpha大，学习的快，越接近结果，降低学习率 alpha = 4 / (1.0 + j + i) + 0.01 # 随机产生一个 0～len()之间的一个值 # random.uniform(x, y) 方法将随机生成下一个实数，它在[x,y]范围内,x是这个范围内的最小值，y是这个范围内的最大值。 # 随机选取样本来更新回归系数 rand_index = int(np.random.uniform(0, len(data_index))) h = sigmoid(np.sum(data_mat[data_index[rand_index]] * weights)) error = class_labels[data_index[rand_index]] - h weights = weights + alpha * error * data_mat[data_index[rand_index]] del(data_index[rand_index]) return weightsdef test(): """ 这个函数只要就是对上面的几个算法的测试，这样就不用每次都在power shell 里面操作，不然麻烦死了 :return: """ data_arr, class_labels = load_data_set() # 注意，这里的grad_ascent返回的是一个 matrix, 所以要使用getA方法变成ndarray类型 # weights = grad_ascent(data_arr, class_labels).getA() # weights = stoc_grad_ascent0(np.array(data_arr), class_labels) weights = stoc_grad_ascent1(np.array(data_arr), class_labels,num_iter=100) plot_best_fit(weights)# -------从疝气病症预测病马的死亡率------def classify_vector(in_x, weights): """ 最终的分类函数，根据回归系数和特征向量来计算 Sigmoid 的值，大于0.5函数返回1，否则返回0 :param in_x: 特征向量，features :param weights: 根据梯度下降/随机梯度下降 计算得到的回归系数 :return: """ # print(np.sum(in_x * weights)) prob = sigmoid(np.sum(in_x * weights)) if prob &gt; 0.5: return 1.0 return 0.0def colic_test(): """ 缺失值的处理方式： - 使用可用特征的均值填补缺失值 - 使用特殊值填补缺失值 - 忽略有缺失值的样本 - 使用相似样本的均值填补缺失值 - 使用其他的机器学习算法预测缺失值 打开测试集和训练集，并对数据进行格式化处理,最主要的的部分，比如缺失值的补充 :return: """ f_train = open('../../../data/5.logistic/HorseColicTraining.txt', 'r') f_test = open('../../../data/5.logistic/HorseColicTest.txt', 'r') training_set = [] training_labels = [] # 解析训练数据集中的数据特征和Labels # trainingSet 中存储训练数据集的特征，trainingLabels 存储训练数据集的样本对应的分类标签 for line in f_train.readlines(): curr_line = line.strip().split('\t') # print(type(curr_line[0])) # str # 一共22列，前21列特征 line_arr = [float(curr_line[i]) for i in range(21)] # print(type(line_arr)) # print(type(line_arr[0])) # float training_set.append(line_arr) training_labels.append(float(curr_line[21])) # 使用 改进后的 随机梯度下降算法 求得在此数据集上的最佳回归系数 trainWeights train_weights = stoc_grad_ascent1(np.array(training_set), training_labels, 500) error_count = 0 num_test_vec = 0.0 # 读取 测试数据集 进行测试，计算分类错误的样本条数和最终的错误率 for line in f_test.readlines(): num_test_vec += 1 curr_line = line.strip().split('\t') if len(curr_line) == 1: continue # 这里如果就一个空的元素，则跳过本次循环 line_arr = [float(curr_line[i]) for i in range(21)] if int(classify_vector(np.array(line_arr), train_weights)) != int(curr_line[21]): error_count += 1 error_rate = error_count / num_test_vec print('the error rate is &#123;&#125;'.format(error_rate)) return error_ratedef multi_test(): """ 调用 colicTest() 10次并求结果的平均值 :return: nothing """ num_tests = 10 error_sum = 0 for k in range(num_tests): error_sum += colic_test() print('after &#123;&#125; iteration the average error rate is &#123;&#125;'.format(num_tests, error_sum / num_tests))if __name__ == '__main__': # 请依次运行下面三个函数做代码测试 # test() # colic_test() multi_test() Softmax回归Softmax模型是logistic回归模型在多分类问题上的推广，类标签可以取两个以上的值。 对于输入的x，用假设函数针对每一个类别j估算出概率值p(y=j|x)，即需要得到x对应每一种分类的概率。假设函数的形式写为 h_{\theta}(x_i)=[p(y_i=1|x_i;\theta),...,p(y_i=k|x_i;\theta)]^T=\frac{1}{\sum_{j=1}^{k}e^{\theta_j^Tx_i}}[e^{\theta_1^Tx_i},...,e^{\theta_k^Tx_i}]^T右式是将每种类别预测概率归一化得到的结果，加和为1.其中 e^{\theta_k^Tx_i}表示预测为第k种类别的比例，相当于logistic回归中的 $y_i/(1-y_i)$令$\theta$表示所有模型参数，$l{..}$为示性函数，假设$(x_i,y_i)$属于类别2，那么$l{y_i=2}=1$ $l{y_i=5}=0$对应的代价函数可以写为 J(\theta)=-\frac{1}{m}[\sum_{i=1}^{m}\sum_{j=1}^{k}l\{y_i=j\}\ln \frac {e^{\theta_j^Tx_i}}{\sum _{l=1}^{k}e^{\theta_l^Tx_i}}]可以对比logistic的式子，形式是相同的利用迭代的优化算法求导得到梯度公式 \nabla_{\theta_j}J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}x_i(l\{y_i=j\}-p(y_i=j|x_i;\theta))$\nabla _{\theta _j}$是一个向量，它的第l个元素$\frac {\partial J(\theta)}{\partial \theta_{jl}}$是$J(\theta)$对$\theta _j$的第l个分量的偏导数每一步迭代更新$\theta$: \theta _j=\theta _j-\alpha \nabla _{\theta _j}J(\theta)j=(1,...,k)通过添加一个权重衰减项$\frac {\lambda}{2}\sum _{i=1}^{k}\sum _{j=0}^{n}\theta _{ij}^2$来修改代价函数，惩罚过大的参数值，将代价函数变成严格的凸函数，保证有唯一解，保证迭代收敛到全局最优解 J(\theta)=-\frac {1}{m}[\sum _{i=1}^{m}\sum _{j=1}^{k}l\{y_i=j\}\ln \frac {e^{\theta _j^Tx_i}}{\sum _{l=1}^{k}e^{\theta _l^Tx_i}}]+\frac {\lambda}{2}\sum _{i=1}^{k}\sum _{j=0}^{n}\theta _{ij}^2其导数为 \nabla _{\theta _j}J(\theta)=-\frac{1}{m}\sum_{i=1}^{m}x_i(l\{y_i=j\}-p(y_i=j|x_i;\theta))+\lambda \theta_j注：如果类别间互斥，则使用softmax回归；否则训练k个二元分类器 贝叶斯分类器朴素贝叶斯分类器 朴素贝叶斯给问题实例分配用特征值表示的类标签，类标签取自有限集合，不是训练这种分类器的单一算法，而是一系列基于相同原理的算法：所有朴素贝叶斯分类器都嘉定样本每个特征与其他特征都不相关 在许多实际应用中，朴素贝叶斯模型参数估计使用最大似然估计方法，在不用到贝叶斯概率或者任何贝叶斯模型的情况下朴素贝叶斯模型也能奏效。emmmm……不是很理解 朴素贝叶斯分类器的一个优势在于只需要根据少量的训练数据估计出必要的参数(变量的均值和方差)。由于变量独立假设，只需要估计各个变量的方法，而不需要确定整个协方差矩阵。 朴素贝叶斯概率模型朴素贝叶斯分类器采用属性条件独立性假设：对一直类别，假设所有属性相互独立。 P(c|x)=\frac{P(c)P(x|c)}{P(x)}=\frac{P(c)}{P(x)}\Pi_{i=1}^{d}P(x_i|c)从概率模型中构造分类器$x_i$表示样本x在第i个特征上的取值判定准则为 \arg\max_{c\in y}P(C)\Pi_{i=1}^{d}P(x_i|c)P(c)=\frac{|D_c|}{|D|}P(X_i|c)=\frac{|D_{c,x_i}|}{|D_c|}但是这种方法有个缺陷，假设某个样本的某个特征值为零，那么不管其他特征多么偏向某一类别，最后结果还是零。 为了避免其他属性携带的信息把训练集中未出现的属性值抹去，进行平滑修正操作： \hat P(c)=\frac{|D_c|+1}{|D|+1}\hat P(x_i|c)=\frac{|D_{c,x_i}|+1}{|D_c|+1}贝叶斯决策论假设有N中可能的类别，$\lambda_{ij}$表示将$c_j$分类的样本误分类成$c_i$所产生的损失，那么在样本x上的条件风险表示为 R(c_i)|x)=\sum_{j=1}^{N}P(c_j|x)简单来说就是给定一个样本x，有可能将样本分类成${c_1,c_2,…,c_N}$中的任意一种类别，那对应的损失为${\lambda_{i1},\lambda_{i2},…,\lambda_{Ni}}$,对应乘积求和得到期望损失。 准则就是最小化风险 h^\*(x)=\mathop{\arg\min}\_{c\in y}R(c|x)$h^*$称为贝叶斯最有分类器。如果使用贝叶斯判定准则最小化决策风险，需要获得后验概率，通常很难获得，采取的办法是估计后验概率，一种方法是利用概率。 P(c|x)=\frac{P(x,c)}{P(x)}=\frac{P(c)P(x|c)}{P(x)}根据大数定律，当训练集包含充足的独立同分布样本时，$P(c)$可通过各类样本出现的频率来进行估计。 对于类条件概率$P(x|c)$来说，涉及关于c所有属性的联合概率，直接根据样本出现的频率来估计将会遇到困难 极大似然估计令$D_c$表示训练集D中第c类样本组成的集合，假设这些样本是独立同分布，那么参数$\theta_c$对于数据集$D_c$的似然是 P(D_c|\theta_c)=\Pi_{x\in {D_c}}P(x|\theta_c)由于连乘操作容易下溢，通常使用对数似然，对上式取对数 这种参数化的方法的估计结果的准确性严重依赖于所假设的概率分布形式是否符合真实数据分布。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-551-387]]></title>
    <url>%2F2018%2F08%2F16%2Fleetcode-string-easy-551-387%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是551，387 题目：551. Student Attendance Record I描述：You are given a string representing an attendance record for a student. The record only contains the following three characters: ‘A’ : Absent. ‘L’ : Late. ‘P’ : Present.A student could be rewarded if his attendance record doesn’t contain more than one ‘A’ (absent) or more than two continuous ‘L’ (late). You need to return whether the student could be rewarded according to his attendance record例子：1234Input: &quot;PPALLP&quot;Output: TrueInput: &quot;PPALLL&quot;Output: False 代码：12345678910111213141516bool Solution551::checkRecord(string s)&#123; //int a_num = 0; //int l_num = 0; //for (int i = 0; i &lt; s.size(); ++i) //&#123; // if (s[i] == 'A')a_num++; // else if (s[i] == 'L' &amp;&amp; i &gt; 1) // &#123; // if (s[i - 1] == 'L' &amp;&amp; s[i - 2] == 'L')return false; // &#125; // if (a_num &gt; 1)return false; //&#125; //return true; return s.find("LLL") == SIZE_MAX &amp;&amp; s.find_first_of('A') == s.find_last_of('A');//如何理解SIZE_MAX&#125; 别人提供的方法二真的是一目了然，赏心悦目，但是对于s.find(&quot;LLL&quot;) == SIZE_MAX要好好理解 题目：387. First Unique Character in a String描述：Given a string, find the first non-repeating character in it and return it’s index. If it doesn’t exist, return -1.例子：12345s = &quot;leetcode&quot;return 0.s = &quot;loveleetcode&quot;,return 2. 代码：123456789101112131415161718192021222324252627282930313233int Solution387::firstUniqChar(string s)&#123; vector&lt;pair&lt;int,int&gt;&gt; _s1(26);//第一个位置存储第一次出现的位置，第二个位置存储出现的次数 for (int i = 0; i &lt; s.size(); ++i) &#123; if (_s1[s[i] - 'a'].second == 0) &#123; _s1[s[i] - 'a'].second++; _s1[s[i] - 'a'].first = i; &#125; else _s1[s[i] - 'a'].second++; &#125; int res = -1; for (int i = 0; i &lt; 26; ++i) &#123; if (_s1[i].second == 1 &amp;&amp; res == -1) &#123; res = _s1[i].first; &#125; else if (_s1[i].second == 1 &amp;&amp; res &gt; _s1[i].first) res = _s1[i].first; &#125; return res; //int len = s.size(), count[26] = &#123; 0 &#125;, i, j; //for (i = 0; i&lt;len; i++) // count[s[i] - 'a']++; //for (i = 0; i&lt;len; i++) // if (count[s[i] - 'a'] == 1) // return i; //return -1;&#125; vector&lt;pair&lt;int,int&gt;&gt; _s1(26)用我自己的方法我骄傲~^~]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-819-383-21]]></title>
    <url>%2F2018%2F08%2F15%2Fleetcode-string-easy-819-383-21%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是819,383，21打卡链表 题目：819. Most Common Word描述：Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn’t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase.例子：123paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot; 代码：123456789101112131415161718192021222324252627282930313233343536373839string Solution819::mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned)&#123; unordered_map&lt;string, int&gt;map; unordered_set&lt;string&gt;sets(banned.begin(), banned.end()); int j = 0; string s; int max = 0; string res; for (int i = 1; i &lt; paragraph.size(); ++i) &#123; if (paragraph[i] == ' ' || paragraph[i] == ',' || paragraph[i] == '.' || paragraph[i] == '?' || paragraph[i] == '!' || paragraph[i] == ';' || paragraph[i] == '\'') &#123; s = paragraph.substr(j, i - j); transform(s.begin(), s.end(), s.begin(), ::tolower); if (sets.find(s) == sets.end()) &#123; map[s]++; if (map[s] &gt; max) &#123; res = s; max = map[s]; &#125; &#125; if (paragraph[i] != ' ')++i; j = i + 1; &#125; else if (i == paragraph.size() - 1) &#123; s = paragraph.substr(j, i -j + 1); transform(s.begin(), s.end(), s.begin(), ::tolower); if (sets.find(s) == sets.end()) &#123; map[s]++; if (map[s] &gt; max)res = s; &#125; &#125; &#125; return res;&#125; 题目：383. Ransom Note描述：Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false. Each letter in the magazine string can only be used once in your ransom note. Note:You may assume that both strings contain only lowercase letters. 例子：123canConstruct(&quot;a&quot;, &quot;b&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;ab&quot;) -&gt; falsecanConstruct(&quot;aa&quot;, &quot;aab&quot;) -&gt; true 代码：12345678910111213141516171819202122232425262728293031bool Solution383::canConstruct(string ransomNote, string magazine)&#123; //if (ransomNote.size() == 0)return true; //unordered_map&lt;char, int&gt;_ransom; //unordered_map&lt;char, int&gt;_mag; //for (char c : ransomNote) //&#123; // _ransom[c]++; //&#125; //for (char c : magazine) //&#123; // _mag[c]++; //&#125; //for (auto s : _ransom) //&#123; // if (s.second &gt; _mag[s.first])return false; //&#125; //return true; //way 2 以空间换时间 vector&lt;int&gt;_ransom(26); vector&lt;int&gt;_mag(26); for (char c : ransomNote) _ransom[c - 'a']++; for (char c : magazine) _mag[c - 'a']++; for (int i = 0; i &lt; 26; ++i) &#123; if (_ransom[i] &gt; _mag[i])return false; &#125; return true;&#125; 题目：21. Merge Two Sorted Lists描述：Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. 例子：12Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 代码：1234567891011121314151617181920212223242526272829303132333435363738394041 struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125; &#125;;ListNode* Solution21::mergeTwoLists(ListNode* l1, ListNode* l2)&#123; if (l1 == NULL)return l2; if (l2 == NULL)return l1; ListNode *res = new ListNode(-1); ListNode *_res = res; ListNode *p = l1; ListNode *q = l2; while (q != NULL &amp;&amp; p != NULL) &#123; if (p-&gt;val &lt; q-&gt;val) &#123; res-&gt;next = p; p = p-&gt;next; &#125; else if(p-&gt;val &gt; q-&gt;val)&#123; res-&gt;next = q; q = q-&gt;next; &#125; else &#123; res-&gt;next = p; p = p-&gt;next; res = res-&gt;next; res-&gt;next = q; q = q-&gt;next; &#125; res = res-&gt;next; &#125; if (q != NULL) res-&gt;next = q; if (p != NULL) res-&gt;next = p; return _res-&gt;next;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吾日三省吾身]]></title>
    <url>%2F2018%2F08%2F15%2F%E5%90%BE%E6%97%A5%E4%B8%89%E7%9C%81%E5%90%BE%E8%BA%AB%2F</url>
    <content type="text"><![CDATA[改掉不健康思维，easy life 为自己减压自从上次出现情绪之后，也没有刻意的去想怎样去解决，但是也在有意无意的寻找答案看过叔本华的《人生的智慧》之后，也有了一些收获和感悟除了自身之外其他一切的地位都只能排在第二等级，只有自身才是最重要的健康、幸福、处世态度、思维……总之，一切以自己为中心才能收获恒久的幸福把当下的许多时光用于回忆、用于对将来的担忧中，那一生都将是苦闷的，当下的我，只有享受当下的时光才能深刻体会生活的乐趣“所有急切而不愿意等待的人都是它的受害者。想要迫使正常、示中地行进着的时间加快脚步，需要符出高昂的代价。因此，我们一定要避免欠下时间巨额的高利贷”避免对自己的要求过高，顺其自然，一切的决定都凭借当下的想法衡量行事，不过分提前可以对自己要求，减少任务的压迫感任何事情都没有最好，自己为未来的期待并不超出自己的能力，都只是时间问题，所以不用操之过急对于感情的事，顺其自然，也要调节好自己的心态，不要因此过分独立，也不要因此而影响彼此的生活 也许我不是一个勇敢的人想说一句，好想骑车好想骑车好想骑车啊已经心痒痒了很久，一直在纠结自己是否有时间骑车，是否需要再买辆车，但是已经一年半没有骑车的我好难受啊每次路过捷安特看到有人在那里检查车，就忍不住多看几眼自从上次摔车之后自己的胆子就变小了，知道了安全的重要性，但是希望自己可以突破心理障碍，来一次骑行，并且在骑行前做好准备工作 还有就是最近迷上了画画，看那些大触的分享，简直停不下来，最近经常有画画的念头，但是我要克制呀，一幅画几个小时啥都不用干了，而且我这一画起来就心痒痒，很难把一幅画扯到一个星期画完我想画人像我想画人像我想画人像但是我怕毁……不知道啥时候能开始第一幅人像 重头再来深度学习之前写了两个kaggle，也看了一些教程代码，但是没有深入思考，理论不扎实，包括机器学习，所以希望可以从零开始有个扎实的基础，今天参加的机器学习的训练营开营了，希望有一个系统的学习，不知道这个训练营水不水……，总之希望打下扎实的基础，另外，强化学习让我很苦恼，希望能不太急于求成，看到GitHub上有100天学习深度学习，那希望也可以做这样的一个工作？ 讨厌的事情却不得不做？那就学着爱上它开发经验本来就不多，代码能力也不强，假期第一次接触游戏开发，内心无比的抵触，真的是懵，学长在给我分配任务，我在跟学长沟通需求的时候，我隔着屏幕感受到了无奈前天将项目前两周所有的代码看了一遍，内心透彻了许多，而且渐渐找到了一些有乐趣的地方，在这个项目中涉及了Websocket协议、Stream流和canvas绘图，昨天看了一篇游戏开发优化的思路，对游戏开发流程有了一个大概的了解，而且对工程流程了解了一下之后，发现也没有那么抵触它了，而且写需求容易了一些，提高了自己的效率同理，强化学习搞起来 发现我好奇的事情太多排不上日程啦我的量化、我的react so easy study,easy life]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-13-606]]></title>
    <url>%2F2018%2F08%2F13%2Fleetcode-string-easy-13-606%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是13,606 题目：13. Roman to Integer描述：Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.12345678Symbol ValueI 1V 5X 10L 50C 100D 500M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900.Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.例子：123456789101112Input: &quot;III&quot;Output: 3Input: &quot;IV&quot;Output: 4Input: &quot;IX&quot;Output: 9Input: &quot;LVIII&quot;Output: 58Explanation: C = 100, L = 50, XXX = 30 and III = 3.Input: &quot;MCMXCIV&quot;Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 代码：12345678910111213141516171819202122232425int Solution13::order(char c)&#123; if (c == 'I')return 1; else if (c == 'V') return 5; else if (c == 'X')return 10; else if (c == 'L') return 50; else if (c == 'C')return 100; else if (c == 'D')return 500; else if (c == 'M')return 1000; return -1;&#125;int Solution13::romanToInt(string s)&#123; int sum = 0; for (int i = 0; i &lt; s.size(); ++i) &#123; if (i &lt; s.size() &amp;&amp; order(s[i]) &lt; order(s[i + 1])) &#123; sum += order(s[i + 1]) - order(s[i]); ++i; &#125; else sum += order(s[i]); &#125; return sum;&#125; 题目：606. Construct String from Binary Tree描述：You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. 例子：123456789101112131415161718192021222324Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: &quot;1(2(4))(3)&quot;Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;, but you need to omit all the unnecessary empty parenthesis pairs. And it will be &quot;1(2(4))(3)&quot;.Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: &quot;1(2()(4))(3)&quot;Explanation: Almost the same as the first example, except we can&apos;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. 代码：12345678910111213141516171819202122 struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; &#125;;string Solution606::tree2str(TreeNode* t)&#123; if (t == NULL)return ""; string s; s += to_string(t-&gt;val); if (t-&gt;left != NULL) s += "(" + tree2str(t-&gt;left) + ")"; if (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) s += "()"; if (t-&gt;right != NULL) s += "(" + tree2str(t-&gt;right) + ")"; return s;&#125; 请好心人告诉我，应该怎样测试606QAQ 2018-8-14日补充，昨天问了chai学长，补充我这个小白空洞的脑壳下面附上在VS正确的写法：Solution606.h把 结构体的定义放在类外面，只在类内部声明即可12345678910111213141516#pragma once#include&lt;string&gt;using namespace std;struct TreeNode &#123; int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution606&#123;public: string tree2str(TreeNode* t); Solution606(); ~Solution606();&#125;; Solution606.cpp123456789101112131415string Solution606::tree2str(TreeNode* t)&#123; if (t == NULL)return ""; string s; s += to_string(t-&gt;val); if (t-&gt;left != NULL) s += "(" + tree2str(t-&gt;left) + ")"; if (t-&gt;left == NULL &amp;&amp; t-&gt;right != NULL) s += "()"; if (t-&gt;right != NULL) s += "(" + tree2str(t-&gt;right) + ")"; return s;&#125; Source.cpp注意结构体TreeNode的初始化方法，结构体中的最后一行实际上是结构体的构造方法12345678910111213#include&lt;iostream&gt;#include "Solution606.h"using namespace std;int main() &#123; TreeNode *tt = new TreeNode(2); TreeNode *right = new TreeNode(3); tt-&gt;left = right; Solution606 s; string k = s.tree2str(tt); cout &lt;&lt; k &lt;&lt; endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《c++ primer plus》读书笔记]]></title>
    <url>%2F2018%2F08%2F13%2F%E3%80%8Ac-primer-plus%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[hexo 的目录结构太好了 预备知识c++在c语言的基础上添加了面向对象编程和泛型编程 c语言诞生的背景：贝尔实验室开发UNIX操作系统，需要一种高级语言代替汇编语言，避免在每台计算机上执行不同的汇编程序 c语言编程的原理（强调的是算法） 需要处理的概念——数据和算法 结构化编程和自顶向下的编程方法，将程序不断划分成程序单元，便于阅读和管理 面向对象编程： 面向对象编程强调数据，用类描述特定的数据结构 首先设计类，然后再设计程序解决问题，从低级组织到高级组织的处理过程叫做自下向上的编程 面向对象编程的优点： 有助于创建可重用的代码 信息隐藏可以保护数据 多态能够为运算符和函数创建多个定义，通过编程上下文确定使用哪个定义 继承能够使用旧类派生出新类 泛型编程： 目标：使重用代码和抽象通用概念的技术更简单 强调独立于特定数据类型 提供了执行常见任务的工具，即泛型编程与面向对象编程的应用场景不同 泛型指的是创建独立于类型的代码，比如设计一个排序函数，此排序函数不单独为整形、浮点型所设计，而泛型编程对语言进行扩展，以便可以只编写一个泛型函数 可移植性在不修改代码的情况下，更换计算机平台，重新编译程序后，程序运行良好，则该程序是可移植性的 可移植性的挑战： 硬件——避免 语言——标准：异常、运行阶段类型识别、模板和便准模板库 编译和链接使用visual c++2015进行编程步骤： 新建项目 选择win32—win32 console application 选择空项目 IDE环境 compile对当前打开的文件中的代码编译 build和make编译项目中所有源代码文件的代码，重新编译新修改文件 build all重新编译所有源代码文件 为了查看程序输出，可以在程序的最后加上下面的代码123cin.get();cin.get();return 0; cin.get()语句读取下一次键击，上述语句让程序等待，直到按下Enter键。如果程序在常规输入后留下一个没有被处理的键击，那么第二条语句是必需的，enter键将被第一个cin.get()吸收 问题问题1：什么是泛型编程？对编程语言进行扩展，以使程序不针对特定数据类型而适用 问题2：什么是多态和编程上下文？ 2018/7/14 开始学习c++一个简单的c++程序：123456789101112131415161718#include&lt;iostream&gt;using namespace std;int main()&#123; for (int i = 0; i &lt; 5; i++) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; cout &lt;&lt; "hello world" &lt;&lt; endl; system("pause"); return 0;&#125; main()函数int main()叫函数头，{}包含的部分叫函数体 作为接口的函数头 函数头描述了函数与调用它的函数之间的接口，函数名前面的部分叫做函数返回类型，函数名后括号中的而部分叫做形参列表。通常main()被启动代码调用，启动代码是由编译器添加到程序中的，是程序和编译系统之间的桥梁 如果编译器到达main()函数末尾时没有遇到返回语句，认为以return 0结尾 c语言中，省略返回类型相当于函数类型为int，但是c++淘汰了这种用法 注释c++注释：// c注释：/**/ c++预处理器和iostream文件如果需要使用c++的输入或者输出工具，需要提供下面两行代码：12#include &lt;iostream&gt;using namespace std; 该编译指令使预处理器将iostream文件的内容添加到程序中，这涉及程序与外部世界之间的通信，iostream文件中的内容，将取代第一行代码，因此使用cin和cout的程序必须包含iostream c头文件的扩展名为h,c++头文件没有扩展名 名称空间名称空间编译指令using namespace std; 名称空间所解决的问题：名称空间支持是c++一项特性，在引用他人代码组合起来的时候解决函数名称共用问题。所引用的代码封装在名称空间单元中，可以用名称空间的名称来指出用哪个厂商的产品，比如wanda()函数的全称为Microflop::wanda() Piscine::wanda()，这样程序可以根据名称空间区分不同版本 所以cout实际上是std::cout,endl实际上是std::endl 所以也可以使用下面的代码代替using namespace std;123using std::cout;using std::endl;using std::cin; 使用cout进行c++输出cout是一个预定义的对象，&lt;&lt;表示信息流动方向，实际上是运算符重载 问题：什么是运算符重载？允许用户定义的类型重新定义运算符的含义 endl：重起一行，位于名称空间std中，在iostream中定义的,保证程序继续运行前刷新输出 \n:count &lt;&lt; &quot;what are you\n&quot;; 引号扩起的字符串通常用\n,其他情况用endl 1234567891011121314int main()&#123; int carrots; carrots = 25; cout &lt;&lt; "I have "; cout &lt;&lt; carrots; cout &lt;&lt; " carrots." &lt;&lt; endl; carrots = carrots - 1; cout &lt;&lt; "Now i hava " &lt;&lt; carrots &lt;&lt; " carrots" &lt;&lt; endl; system("pause"); return 0;&#125; 在声明变量的时候将为变量分配内存空间赋值语句将值赋给存储单元 可以连续使用赋值运算符 cout在打印之前，必须将整数形式的数字转换为字符串形式，&lt;&lt;会根据后面的数据类型相应的调整形式 类类描述的是数据格式和用法，对象则是根据数据格式创建的实体类描述指定了可对类对象执行的所有操作，c++两种发送消息的方式：类方法和运算符重载 c++中，函数调用必须 包括括号，即使没有参数 用户定义的函数添加另一个用户定义的函数，在使用前必须提供原型，放到main()定义之前 没有返回值的函数 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;void simon(int);int main()&#123; simon(3); system("pause"); return 0;&#125;void simon(int n)&#123; using namespace std; cout &lt;&lt; "simon says touch your toes " &lt;&lt; n &lt;&lt; " times." &lt;&lt; endl;&#125; 定义simon()的源代码位于main()后面，不允许将函数定义嵌套在另一个函数定义中 有返回值的函数 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int stonetolb(int);int main()&#123; int pounds = stonetolb(2); cout &lt;&lt; pounds &lt;&lt; endl; system("pause"); return 0;&#125;int stonetolb(int sts)&#123; return 14 * sts;&#125; 处理数据内置的c++数据类型分为——基本类型：整数和浮点数复合类型：数组、字符串、指针和结构 c++命名规则其一：以两个下划线或下划线和大写字母大头的名称被保留给实现，以一个下划线开头的名称被保留给实现，用作全局标识符 基本类型 整型short\int\long\long long short至少16位 int至少和short一样长 long至少32位，且至少与int一样长 long long至少64位，且至少与long一样长 可以用sizeof运算符返回类型或者变量的长度，单位是字节 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int a = INT_MAX; long n_long = LONG_MAX; long long x_llong = LLONG_MAX; cout &lt;&lt; "short is " &lt;&lt; sizeof (short) &lt;&lt; " bytes." &lt;&lt; endl;//2 cout &lt;&lt; "int is " &lt;&lt; sizeof(int) &lt;&lt; " bytes." &lt;&lt; endl;//4 cout &lt;&lt; "long is " &lt;&lt; sizeof(long) &lt;&lt; " bytes." &lt;&lt; endl;//4 cout &lt;&lt; "long long is " &lt;&lt; sizeof(long long) &lt;&lt; " bytes." &lt;&lt; endl;//8 cout &lt;&lt; "int is " &lt;&lt; a &lt;&lt; " bytes." &lt;&lt; endl;// 2147483647 cout &lt;&lt; "n_long is " &lt;&lt; n_long &lt;&lt; " bytes." &lt;&lt; endl;// 2147483647 cout &lt;&lt; "x_llong is " &lt;&lt; x_llong &lt;&lt; " bytes." &lt;&lt; endl;// 9223372036854775807 system("pause"); return 0;&#125; 初始化的方式：12int emus&#123; 7 &#125;;int rheads = &#123; 12 &#125;; 无符号类型 1unsigned short change 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int main()&#123; int n_int = INT_MAX; unsigned int un_int = INT_MAX; cout &lt;&lt; n_int &lt;&lt; endl; cout &lt;&lt; un_int &lt;&lt; endl; cout &lt;&lt; n_int + 1 &lt;&lt; endl; cout &lt;&lt; un_int + 1 &lt;&lt; endl; system("pause"); return 0;&#125; 无符号整型可以增大变量能够存储的最大值上面的例子中n_int进行过加1操作会变成赋值，因为符号为产生进位 整形字面量c++能够用三种不同的计数方式来书写整数：基数为10，8，16如果第一位是0，第二位是1-7，则基数是8；如果前两位是0x或0X，则基数是16. 在默认情况下，cout以十进制格式显示整数，在计算机中存储都以二进制形式进行存储 endl提供了控制符dec hex oct分别指示cout以十进制、十六进制和八进制格式显示整数在打印的下一行加入下面的代码 1cout &lt;&lt; hex; char类型char类型是另一种整型，能存储所有基本符号 1234567891011121314#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; system("pause"); return 0;&#125; 程序输入字母也被输出，但是内存中存储的内容为字母对应的字符编码实际上，程序调用了cout的put函数1234567891011121314151617实际上`ch`存储的是整数，可以执行整数的操作，如加法```cpp#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; ch + 1 &lt;&lt; endl; system(&quot;pause&quot;); return 0;&#125; 最后一行将输出78如果输入数字5，ch中将存储5的字符编码53，所以第二行输出54 12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; char ch; cin &gt;&gt; ch; cout &lt;&lt; ch &lt;&lt; endl; cout &lt;&lt; ch + 1 &lt;&lt; endl; cout.put(ch); system("pause"); return 0;&#125; 书写字符常量的最简单方法是用单引号括起12&apos;A&apos;&apos;5&apos; 如果char型存储的是数值类型，那么unsigned char和signed char差异很重要，signed char表示范围是-128—127 布尔类型 非零值为true，零为false，true 可以转换为1，false转换为0 const限定符const关键字修改变量声明和初始化1const int Months = 12; 将名称的首字母大写，提醒自己表示常量 浮点数 123floatdoublelong double 浮点数表示法：12312.32.52e+8//小数点向右移动8位8.33E-4//小数点向左移动4位 c++算数运算符12345+-*/% 除法分支，如果两个操作数都是整数，执行整数除法，小数部分被丢弃，有一个是浮点数，则结果为浮点数 类型转换将一个值赋值给取值范围更大的类型通常不会导致问题，但是将一个很大的值赋值给一个较小的值会降低精度。 1int(&apos;Q&apos;); c++11中的auto声明，让编译器能够根据初始值的类型推断变量的类型 复合类型数组 编译器不会检查使用的下标是否有效 数组初始化：int a[3] = {20,1,2}; 初始化时，提供的值可以少于数组的元素数目，如果只对数组一部分进行初始化，编译器将把其他元素设置成0。初始化全为0：long b[3] = {0}; short thing[] = {1,5,2,3};编译器会计算元素个数 拓展：vector 字符串用char数组类型存储字符串，需要以空字符结尾，空字符被写作\012char dog[3] = &#123;&apos;b&apos;,&apos;e&apos;,&apos;a&apos;&#125;;//not a stringchar cat[3] = &#123;&apos;b&apos;,&apos;e&apos;,&apos;\0&apos;&#125;;//a string 很多处理字符串的函数的处理规则都是以遇到空字符停止 下面的字符串初始化也是合理的，用引号括起的字符串隐式包括 结尾的空字符 12char bird[11] = &quot;Mr. cheeps&quot;;char fish[] = &quot;bubbles&quot;; 在确定存储字符串所需的最短数组时，记得将结尾的空字符计算在内 拓展：string 标准头文件cstring提供了很多与字符串相关的函数123456789101112131415#include&lt;iostream&gt;//#include&lt;cstring&gt;using namespace std;int main()&#123; const int Size = 15; char name1[Size]; cin &gt;&gt; name1; cout &lt;&lt; strlen(name1) &lt;&lt; endl; system("pause"); return 0;&#125; 但是尝试注释调cstring头文件也没有报错 strlen不会计算空字符，若数组存储内容中间含有空字符，即使后面还有字符，字符串也会在空字符处结束；cin使用空白（空格、制表符和换行符）来确定字符串的结束位置 解决各个单词空格分开的问题：每次读取一行字符串输入istream中的类提供了一些面向行的类成员函数：getline()和get()，读取一行输入，直到到达换行符，但是getline()会丢弃换行符，get()将换行符保留在输入序列中。 1getline() 调用方法：1234567891011cin.getline(数组名称，字符数)``` 若字符数为20，最多读取19个字符```cpp const int Size = 15; char name1[Size]; char name2[Size]; cin.getline(name1, Size); cin.getline(name2, Size); cout &lt;&lt; name1 &lt;&lt; endl; cout &lt;&lt; name2 &lt;&lt; endl; 输入12youare 输出：12youare 1get() 调用方法：1234567891011cin.get(数组名称，字符数)``` ```cpp const int Size = 15; char name1[Size]; char name2[Size]; cin.get(name1, Size); cin.get(name2, Size); cout &lt;&lt; name1 &lt;&lt; endl; cout &lt;&lt; name2 &lt;&lt; endl; 输入：1you[回车] 自动输出（回车仍然在队列中）：12you[空行] 下面的代码等同于上上面的代码，用cin.get()吸收回车12345678const int Size = 15;char name1[Size];char name2[Size];cin.get(name1, Size);cin.get();cin.get(name2, Size);cout &lt;&lt; name1 &lt;&lt; endl;cout &lt;&lt; name2 &lt;&lt; endl; 下面代码等同：12cin.get(name1, Size).get();cin.get(name2, Size); get() 方法相比于getline()方法有优势，假设用get()将一行读入数组，如何知道停止读取的原因是由于读取了整行，而不是由于数组填满？解决方法就是查看下一个输入字符，如果是换行符说明读了整行，否则说明还有其他输入 还会有空行和其他问题，如何解决？ c++常使用指针而不是数组来处理字符串 string类简介string类包含在头文件string中，string类位于名称空间std中。string类定义隐藏了字符串的数组性质 未被初始化的数组，第一个空字符的出现位置是随机的，string类型未被初始化的长度为0 1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str1; string str2 = "pather"; cin &gt;&gt; str1; cout &lt;&lt; str1 &lt;&lt; endl; cout &lt;&lt; str2 &lt;&lt; endl; cout &lt;&lt; str2[2] &lt;&lt; endl; system("pause"); return 0;&#125; 类设计能够让程序自动处理string的大小 初始化：1string a = &#123;&quot;you are my baby&quot;&#125;; 赋值、拼接、附加 不能将一个数组赋值给另一个数组，但是可以将一个string对象赋给另一个string对象 123string str1;string str2 = &quot;father&quot;;str1 = str2; 可以使用+将两个string对象合并起来，还可以用运算符+=将字符串附加到string对象末尾 123string str3;str3 = str1 + str2;str1 += str2; 其他操作 strcpy(charr1,charr2);//copy charr2 to charr1 strcat(charr1,charr2);//append contents of charr2 to charr1 str1.size() strlen(charr1) 下面代码的cin作为参数传入，意在说明到哪里去找str1，此时这里的getline方法不是一个类方法，友元函数了解一下123string str1;getline(cin, str1);cout &lt;&lt; str1 &lt;&lt; endl; 问题：什么是友元函数？ 结构简介12345struct inflatable[名称]&#123; char name[20]; float volume; double price;&#125;; 一个结构体例子1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;struct MyStruct&#123; char name[10]; int age; bool sex;&#125;;int main()&#123; MyStruct guest = &#123; "Arya", 18, true &#125;; cout &lt;&lt; guest.name &lt;&lt; guest.age &lt;&lt; guest.sex &lt;&lt; endl; system("pause"); return 0;&#125; 结构声明的位置很重要，放在main()外面是外部声明，可以被后面的任何函数使用，内部声明只能被该声明所属的函数通用。 1Mystruct person[100]; 12345MyStruct guests[2] =&#123; &#123;"name1",12,true&#125;, &#123;"name2",20,false&#125;&#125;; 共用体用于节省内存，细节再看吧 枚举c++的enum工具提供了另一种创建符号向量的方式，可以代替const1enum spectrum &#123;red,orange,yellow&#125;; 让spectrum成为新类型的名称 让red,orange,yellow作为符号常量，对应整数值0-2 可以使用枚举名声明这种类型的变量spectrum band枚举只定义了赋值运算符，没有定义运算 设置枚举量的值 可以使用赋值运算符显式设置枚举量的值 1enum bits&#123;one = 1,two = 2, four = 4,eigth = 8&#125;; 可以只显示定义其中的一些枚举量的值 1enum bits&#123;one,second = 1000, a&#125;; 枚举量具有取值范围 指针和自由存储空间指针是一个变量，存储的是值的地址，而不是值本身，如果要找到常规变量的地址，只需要对变量应用地址运算符&amp;，就可以获得12int a = 4;cout &lt;&lt; &amp;a &lt;&lt; endl; 显示地址时，显示十六进制表示法，常用于描述内存的表示法 指针用途存储值得地址，因此指针名表示得是地址，*运算符被成为间接值或解除引用运算符，应用于指针，可以得到该地址存储得值， 12345678910int a = 4;int * a_address;a_address = &amp;a;cout &lt;&lt; "a address: " &lt;&lt; &amp;a &lt;&lt; endl;cout &lt;&lt; "a_update address: " &lt;&lt; a_address &lt;&lt; endl;cout &lt;&lt; "a value: " &lt;&lt; *a_address &lt;&lt; endl;a += 1;cout &lt;&lt; "a_update address: " &lt;&lt; &amp;a &lt;&lt; endl;cout &lt;&lt; "a address: " &lt;&lt; a_address &lt;&lt; endl;cout &lt;&lt; "a_update value: " &lt;&lt; *a_address &lt;&lt; endl; 以上程序结果表明，指针变量初始化后便不会再更改，当a得值变化时，可以根据*a_address访问到该地址存储得数值 下面的声明创建一个指针和一个变量1int* p1,p2; 下面的声明是有效的：12double * tax_ptr;char * str; 可以在声明语句的时候初始化指针，在这种情况下，被初始化的是指针，而不是它指向的值，创建指针的时候，计算机将分配用来存储地址的内存，但不会分配用来存储指针所指向的数据的内存 使用new来分配内存 前面都将指针初始化为一个变量的地址，但是指针真正的用途是在运行阶段分配未命名的内存以存储值，这种情况下只能通过指针来访问内存，c语言可以用库函数malloc()分配内存，但c++更好的办法是new运算符 12int * pn = new int;cout &lt;&lt; &quot;new de address: &quot; &lt;&lt; pn &lt;&lt; endl; new int告诉程序，需要存储int的内存，找到这块内存把地址返回给pn。 为一个数据对象获得并指定分配内存的通用格式如下：1typeName * pointer_name = new typeName; 使用delete释放内存 使用delete时，后面要加上指向内存块的指针12int * ps = new int;delete ps; 释放ps指向的内存，但不会删除指针ps本身，一定要配对的使用new和delete，否则将发生内存泄漏，被分配的内存再也无法使用 [x] 不要用delete释放声明变量所获得的内存，下述代码将不被允许123int jugs = 5;int * pi = &amp;jugs;delete pi; 使用new创建动态数组 1int * psome = new int [10]; new运算符返回第一个元素的地址，赋值给psome，并使用完内存块后，应用下面的格式释放：1delete [] psome; []表示释放整个数组 问题：如果使用new []为一个实体分配内存，则应该使用delete来释放？ 利用指针访问数组中的元素：123456int * pn = new int [3];pn[0] = 1;pn[1] = 3;pn[2] = 5;cout &lt;&lt; "array" &lt;&lt; pn[0] &lt;&lt; pn[1] &lt;&lt; pn[2] &lt;&lt; endl;delete [] pn; 可以把指针名当成数组名 指针、数组和指针算术 指针变量加1后，增加的量等于它指向的类型的字节数 12345double w[3] = &#123; 10000.0,20000.0,30000.0 &#125;;double * pw = w;cout &lt;&lt; "pw = " &lt;&lt; pw &lt;&lt; ", *pw= " &lt;&lt; *pw &lt;&lt; endl;pw = pw + 1;cout &lt;&lt; "pw = " &lt;&lt; pw &lt;&lt; ", *pw= " &lt;&lt; *pw &lt;&lt; endl; 输出： 12pw = 006FF7C4, *pw= 10000pw = 006FF7CC, *pw= 20000 指针和字符串，没有仔细看，用到的时候再看 使用new创建动态结构1Mystruct * ps = new Mystruct; 创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只是知道他的地址，c++专门为这种情况提供了一个运算符-&gt;，用于指向结构的指针 如果结构标识符是结构名，则使用句点运算符，如果标识符是指向结构的指针，则使用箭头运算符 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;struct MyStruct&#123; char name[10]; float volume; double price;&#125;;int main()&#123; MyStruct * ps = new MyStruct; cin.getline(ps-&gt;name, 20); cin &gt;&gt; ps-&gt;price; cin &gt;&gt; (*ps).volume; cout &lt;&lt; ps-&gt;name &lt;&lt; ps-&gt;price &lt;&lt; ps-&gt;volume &lt;&lt; endl; system("pause"); return 0;&#125; 自动存储、静态存储和动态存储（线程存储）自动变量通常存储在栈中，执行代码块时，其中的变量依次加入到栈中，离开代码块时，将按照相反的顺序释放这些变量。静态存储是整个程序执行期间都存在的存储方式，使变量成为静态的方式有两种：一种在函数外面定义它，一种实在声明变量的时候使用关键字static 自动存储和静态存储的关键在于这些方法限制了变量的寿命，静态变量可能存在于程序的整个生命周期，自动变量只是在特定函数被执行时存在 动态存储管理了一个内存池，静态变量和自动变量的内存是分开的，数据的生命周期不完全受程序或者函数的生存时间控制。 数组的替代品vector和array1234567891011121314#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; vi; int n; cin &gt;&gt; n; vector&lt;double&gt; vd(n); system("pause"); return 0;&#125; vector可以动态增删元素vector比数组强大，但是比数组效率低，如果是长度固定的数组，则数组更佳array对象的长度也是固定的，使用栈而不是自由存储区，因此效率与数组相同。array对象允许直接复制，而数组必须逐元素复制123456789101112#include&lt;iostream&gt;#include&lt;array&gt;using namespace std;int main()&#123; array&lt;int,5&gt; vi; array&lt;double, 4&gt; vd = &#123;1.2,2.2,1.2,3.4&#125;; system("pause"); return 0;&#125; 可能导致数组越界行为，可以使用成员函数at()可以在运行期间捕获非法索引，程序默认终端，或者利用begin()和end()确定边界 循环和关系表达式++xx++12while(guests++ &lt; 10) cout &lt;&lt; guests &lt;&lt; endl; 先判断guests是否小于10，然后将guests++，再执行循环体 1strcmp(&quot;word&quot;,&quot;word&quot;); 比较两个字符串是否相同 12345int n = 1;do&#123; n++;&#125; while (n &lt;= 7); 满足条件的时候执行循环体 123double prices[5] = &#123; 1.2,1.3,1.4,3.5,2.4 &#125;;for (double x : prices) cout &lt;&lt; x &lt;&lt; endl; 遍历数组中的元素 123456789101112double prices[5] = &#123; 1.2,1.3,1.4,3.5,2.4 &#125;;for (double x : prices)&#123; x = x + 1; cout &lt;&lt; x &lt;&lt; endl;&#125;cout &lt;&lt; prices[3] &lt;&lt; endl;for (double &amp;x : prices)&#123; x = x + 1;&#125;cout &lt;&lt; prices[3] &lt;&lt; endl; 第一种循环不改变数组中的值，第二种引用变量可以使数组中的值改变 分支语句和逻辑运算符字符函数库cctype, 貌似有问题，测试了几个案例都木有通过p194c++从c语言继承了一个与字符相关的，非常方便的函数软件包，可以简化诸如确定字符是否为大写字母、数字、标点符号等工作1#include&lt;cctype&gt; 函数名称 返回值 案例 备注 数字，0 if字母2|```isalnum(33)```|12345678910111213141516171819```isalpha(字母)``` |if 字母，true||iscntrl()|if控制字符，true||isdigit()|if数字，true||switch语句---```cpp int a = 1; switch (a) &#123; case 1: cout &lt;&lt; a &lt;&lt; endl; break; case 2: cout &lt;&lt;&quot;a: &quot; &lt;&lt; a + 1 &lt;&lt; endl; break; default: cout &lt;&lt; &quot;break\n&quot;; break; &#125; 从上到下匹配条件，直到条件合适，从匹配到的条件一下的case语句的执行语句也都执行，所以要每条都加break break和continue语句continue语句用于循环中，让程序跳过循环体中余下的代码，并开始新一轮循环；在switch语句或任何循环中使用break语句，使程序跳到switch或循环后面的语句处执行 简单文件输入/输出 写入到文本文件中文件输出条件： 必须包含头文件iostream 头文件iostream定义了一个用于处理输出的ostream类 头文件iostream声明了一个cout的ostream变量 必须指明名称空间std 必须包含头文件fstream 头文件fstream定义了一个用于处理输出的ofstream类 需要将ofstream对象与文件关联起来，使用open方法 使用完文件后，使用close方法关闭 写入文件的例子12345678910111213141516#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ofstream outFile; outFile.open("fish.txt"); double wt = 12.2342; char name[10] = "dream."; outFile &lt;&lt; wt &lt;&lt; endl; outFile &lt;&lt; name; system("pause"); return 0;&#125; 每次写入文件会将原来的内容清空 读取文本文件中 必须包含头文件fstream 头文件fstream定义了一个用于处理输入的ifstream类 需要声明一个或者多个ifstream变量 指明名称空间std 需要将ifstream对象和文件关联起来，使用open方法 使用完文件后，使用close方法将其关闭 使用ifstream对象和运算符&gt;&gt;来读取各种类型的数据 使用ifstream对象和get（getline）方法读取一个（一行）字符 ifstream和eof()\fail()等方法判断输入是否成功 ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，被转换为true 读取文本文件的例子 12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ifstream inFile; inFile.open("fish.txt"); char wt[10]; char name[10]; inFile.get(name,10); inFile.get(); inFile.getline(wt, 10); //infile &gt;&gt; wt; //infile &gt;&gt; name; cout &lt;&lt; wt &lt;&lt; endl; cout &lt;&lt; name &lt;&lt; endl; system("pause"); return 0;&#125; 增加inFile.get()语句是因为，读取完文件中第一行内容后，有一个回车，需要用这条语句吸收回车，再进入到第二行读取，否则，第二个数组读取到空格即停止读取 如果试图打开一个不存在的文件用于输入，将导致输入时失败，所以可以先判断文件是否被打开，is_open(),比如下面的例子 12345678910111213141516171819#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main()&#123; ifstream inFile; inFile.open("exe.txt"); if (!inFile.is_open()) &#123; cout &lt;&lt; "no file\n"; //exit(EXIT_FAILURE); &#125; cout &lt;&lt; "fa\n"; system("pause"); return 0;&#125; 读取文件的时候不应该超过EOF，如果最后一次读取数据的时候遇到EOF，方法eof()将返回true，程序可能遇到类型不匹配的情况，方法fail()将返回true，出现意外的情况方法bad()返回true。更简单的方法是使用good()方法，没有任何错误的时候返回true 1234while(inFile.good())&#123; inFile &gt;&gt; value;&#125; 函数编写自己函数的规则： 提供函数定义 提供函数原型 调用函数 一个函数例子 123456789101112131415161718#include&lt;iostream&gt;using namespace std;void Put(double d);//函数原型int main()&#123; double w = 1.2; Put(w);//函数调用 system("pause"); return 0;&#125;void Put(double s)//函数定义&#123; cout &lt;&lt; s &lt;&lt; endl;&#125; 为什么需要原型 原型描述了函数到编译器的接口，将函数的返回值类型和参数的类型和数量告诉编译器，函数完成计算候，把返回值放在指定的位置，编译器知道检索多少个字节，以及如何解释他们 原型的语法 复制函数定义的函数头加分号，函数原型不要求提供参数的变量名 原型的功能 编译器正确处理函数返回值 检查使用的参数数目是否正确 检查参数类型是否正确 函数和数组一个函数和数组的例子 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int ArSize = 8;int sum_arr(int arr[], int n);int main()&#123; double w = 1.2; int cookies[ArSize] = &#123; 1,4,2,5,6,6,7,3 &#125;; int sum = sum_arr(cookies, ArSize); cout &lt;&lt; sum &lt;&lt; endl; system("pause"); return 0;&#125;int sum_arr(int arr[], int n)&#123; int total = 0; for (int i = 0; i &lt; n; i++) &#123; total = total + arr[i]; &#125; return total;&#125; 方括号为空表明可以将任何长度的数组传递给该函数，cookies是一个指针，因此该函数传递的是数组第一个元素的地址，所以下面的函数头也是正确的1int sum_arr(int * arr,int n) int arr[]表明arr不仅指向int还指向int数组的第一个int，而在其他的上下文中，这二者的含义并不相同 实际上函数并没有将数组内容传递给函数，而是将数组的地址、元素种类和元素数目传递给函数，传递常规变量时，函数将使用变量的拷贝，但是传递数组时，函数将使用原来的数组思考：为什么不能直接使用sizeof arr确定数组长度？cookies和arr指向同一个地址，但是sizeof cookies的值是32，是整个数组的长度，而sizeof arr是4，是指针变量的长度所以不能用sizeof arr 好处：将数组的地址作为参数可以节省复制整个数组所需的时间和内存，而且使用原始数组增加了破坏数据的风险 一个函数和数组的例子，如何更改数组和保护数组： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;iostream&gt;const int Max = 5;int fill_array(double arr[], int n);//数组可以改变void show_array(const double arr[], int n);//const 保护数组不被改变void revalue(double d, double arr[], int n);//可以改变int main()&#123; using namespace std; double properties[Max]; int size = fill_array(properties, Max); if (size &gt; 0) &#123; cout &lt;&lt; "enter revaluation factor: "; double factor; while (!(cin &gt;&gt; factor))//检测是否有不好的输入 &#123; cin.clear(); while (cin.get() != '\n') continue; cout &lt;&lt; "bad input"; &#125; revalue(factor, properties, size); show_array(properties, size); &#125; cout &lt;&lt; "done\n"; system("pause"); return 0;&#125;int fill_array(double arr[], int limit)&#123; using namespace std;//在需要cout和cin的函数中应用 double temp; int i; for (i = 0; i &lt; limit; i++) &#123; cout &lt;&lt; "enter value #" &lt;&lt; (i + 1) &lt;&lt; ": "; cin &gt;&gt; temp; if (!cin)//bad input &#123; cin.clear(); while (cin.get() != '\n') &#123; continue; &#125; cout &lt;&lt; "bad input:input process terminated\n"; break; &#125; else if(temp &lt; 0) &#123; break; &#125; else &#123; arr[i] = temp; &#125; &#125; return i;&#125;void show_array(const double arr[], int n)&#123; using namespace std; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; "property #" &lt;&lt; (i + 1) &lt;&lt; ":$"; cout &lt;&lt; arr[i] &lt;&lt; endl; &#125;&#125;void revalue(double r, double arr[], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; arr[i] *= r; &#125;&#125; 另一个函数与数组的例子，使用数组区间 123456789101112131415161718192021222324#include&lt;iostream&gt;const int Max = 5;int sum_arr(const int * begin, const int * end);//注意这里传递的是指针int main()&#123; using namespace std; int properties[Max] = &#123;1,2,1,6,4&#125;; int size = sum_arr(properties, properties + Max); cout &lt;&lt; size &lt;&lt; endl; system("pause"); return 0;&#125;int sum_arr(const int * begin, const int * end)//const说明不可以通过指针修改数组&#123; const int * pt; int total = 0; for (pt = begin; pt != end; pt++) total = total + *pt; return total;&#125; 指针和const：常规变量的地址可以赋给常规指针；常规变量的地址可以赋给指向const的指针；const变量的地址可以赋给指向const的指针；但是const的地址赋给常规指针不可行,即下面的代码不可行 12const int a = 1;int * a_add = &amp;a; 函数和二维数组，这个也是写函数的时候最棘手的问题一个二位数组作为参数的例子1234567891011121314151617181920212223242526#include&lt;iostream&gt;const int Max = 5;int sum_arr(int arr[][4], int size);int main()&#123; using namespace std; int properties[Max][4] = &#123;&#123;1,2,1,6&#125;,&#123;4,2,4,1&#125;&#125;; int size = sum_arr(properties, 2); cout &lt;&lt; size &lt;&lt; endl; system("pause"); return 0;&#125;int sum_arr(int arr[][4], int size)&#123; int total = 0; for(int r = 0;r &lt; size;r++) for (int c = 0; c &lt; 4; c++) &#123; total = total + arr[r][c]; &#125; return total;&#125; 函数头的写法：12int sum_arr(int arr[][4],int size)int sum_arr(int (*arr)[4],int size) 这两种都是可以的，指针的外围括号是必须的，size表示行数，4表示列数，所以可以想正常数组一样访问二维数组，声明一个4维指针数组，只不过限定了数组的列数 字符串和函数一个字符串函数的例子12345678910111213141516171819202122232425#include&lt;iostream&gt;unsigned int c_in_str(const char * str, char ch);int main()&#123; using namespace std; char a[15] = "emmm..."; char * wail = "unbantu"; unsigned int ms = c_in_str(a, 'm'); unsigned int us = c_in_str(wail, 'u'); cout &lt;&lt; ms &lt;&lt; us &lt;&lt; endl; system("pause"); return 0;&#125;unsigned int c_in_str(const char * str, char ch)&#123; unsigned int count = 0; while (*str) &#123; if (*str == ch) count++; str++; &#125; return count;&#125; 字符串第一个元素的地址作为参数传入，字符串的最后一个字符是 ‘\0’，可以判断结束表示，所以不用传入数组长度，while(*str) 如果要返回字符串函数，可以返回字符串的地址，这样的效率更高 123456789101112131415161718192021222324#include&lt;iostream&gt;char * buildstr(char c, int n);int main()&#123; using namespace std; char * wail = buildstr('c',10); cout &lt;&lt; sizeof(wail) &lt;&lt; endl;//4指向第一个元素的地址 cout &lt;&lt; wail &lt;&lt; endl; delete[] wail; system("pause"); return 0;&#125;char * buildstr(char c, int n)&#123; char * pstr = new char[n + 1];//new一个n个字符的数组，最后一位存储'\0' //pstr指向数组的第一个元素的地址 pstr[n] = '\0'; while (n-- &gt; 0)//先执行n&gt;0逻辑运算，然后再执行n--,再执行循环体 &#123; pstr[n] = c; &#125; return pstr;&#125; 变量pstr的作用于在函数内，所以函数结束时，pstr（而不是字符串）使用的内存将被释放 main中的当字符串不再需要的时候，用delete释放内存 问题：怎样区分一个指针指向整个数组地址还是数组首地址？问题：函数中的new的地址已经在函数结束的时候释放掉为什么在主函数中还需要delete，new和delete配对使用？ 让函数返回一个指针，该指针指向new分配的内存的缺点时，程序员必须记住使用delete,在12章，将知道c++类如何使用==构造函数和析构函数==处理这些细节 函数和结构函数使用原始结构的副本，函数也可以返回结构；与数组名就是数组第一个元素的地址不同的是，结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;，c++还是使用这个运算符表示引用变量 传递和返回结构 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;const int Mins_per_hr = 60;struct travel_time&#123; int hours; int mins;&#125;;travel_time sum(travel_time t1, travel_time t2);//放在结构定义下面void show_time(travel_time t);int main()&#123; using namespace std; travel_time day1 = &#123; 5,45 &#125;; travel_time day2 = &#123; 4,55 &#125;; travel_time trip = sum(day1, day2); show_time(trip); system("pause"); return 0;&#125;travel_time sum(travel_time t1, travel_time t2)//返回结构&#123; travel_time total; total.mins = (t1.mins + t2.mins) % Mins_per_hr; total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr; return total;&#125;void show_time(travel_time t)//传递结构&#123; using namespace std; cout &lt;&lt; t.hours &lt;&lt; "hours, " &lt;&lt; t.mins &lt;&lt; " minutes\n";&#125; 传递结构的地址上面的例子修改如下：12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;const int Mins_per_hr = 60;struct travel_time&#123; int hours; int mins;&#125;;travel_time sum(const travel_time * t1, const travel_time * t2);void show_time(const travel_time * t);int main()&#123; using namespace std; travel_time day1 = &#123; 5,45 &#125;; travel_time day2 = &#123; 4,55 &#125;; travel_time trip = sum(&amp;day1, &amp;day2); show_time(&amp;trip); system("pause"); return 0;&#125;travel_time sum(const travel_time * t1, const travel_time * t2)&#123; travel_time total; total.mins = (t1-&gt;mins + t2-&gt;mins) % Mins_per_hr; total.hours = t1-&gt;hours + t2-&gt;hours + (t1-&gt;mins + t2-&gt;mins) / Mins_per_hr; return total;&#125;void show_time(const travel_time * t)&#123; using namespace std; cout &lt;&lt; t-&gt;hours &lt;&lt; "hours, " &lt;&lt; t-&gt;mins &lt;&lt; " minutes\n";&#125; 函数和string对象1234567891011121314151617#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int Size = 5;void display(const string sa, int n);int main()&#123; string list = "you are very good."; display(list, Size); system("pause"); return 0;&#125;void display(const string sa, int n)&#123; cout &lt;&lt; sa &lt;&lt; endl;&#125; 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int Size = 5;void display(const string sa[], int n);int main()&#123; string list[Size];//string类型的数组 for (int i = 0; i &lt; Size; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; ": "; getline(cin, list[i]); &#125; display(list, Size); system("pause"); return 0;&#125;void display(const string sa[], int n)&#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i + 1 &lt;&lt; ": " &lt;&lt; sa[i] &lt;&lt; endl; &#125;&#125; 函数和array对象123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;array&gt;#include&lt;string&gt;using namespace std;const int Seasons = 5;const array&lt;string, Seasons&gt; Snames = &#123; "spring","summer","fall","winter" &#125;;void show(array&lt;double, Seasons&gt; da);void fill(array&lt;double, Seasons&gt; * pa);int main()&#123; array&lt;double, Seasons&gt; expenses; fill(&amp;expenses); show(expenses); system("pause"); return 0;&#125;void fill(array&lt;double, Seasons&gt; * pa)//需要对pa进行修改，所以是引用&#123; for (int i = 0; i &lt; Seasons; i++) &#123;//Snames是全局变量，可以直接调用 cout &lt;&lt; "enter " &lt;&lt; Snames[i] &lt;&lt; "expenses: "; cin &gt;&gt; (*pa)[i]; &#125;&#125;void show(array&lt;double, Seasons&gt; da)&#123; double total = 0.0; cout &lt;&lt; "\nexpenses\n"; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; Snames[i] &lt;&lt; ":$" &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; &#125; cout &lt;&lt; "total expenses:$" &lt;&lt; total &lt;&lt; endl;&#125; 递归函数指针函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址，可以编写将另一个函数的地址作为参数的函数，这样第一个函数能够找到第二个函数并运行，它允许在不同的时间传递不同函数的地址 获取函数地址要将函数作为参数传递，必须传递函数名。区分函数地址和函数返回值 声明函数指针声明指定函数的返回类型以及函数的参数列表 12double pam(int);//函数原型double (*pf)(int);//声明函数指针 技巧：编写函数原型，然后用1234567891011121314151617181920212223242526273. 使用函数指针来调用函数一个函数指针的例子```cpp#include&lt;iostream&gt;using namespace std;double betsy(int lns);void estimate(int lines, double(*pf)(int));int main()&#123; int code = 7; estimate(code, betsy);//调用函数指针 system(&quot;pause&quot;); return 0;&#125;double betsy(int lns)&#123; return 0.05 * lns;&#125;void estimate(int lines, double(*pf)(int))&#123; cout &lt;&lt; lines &lt;&lt; &quot; lines will tak &quot;; cout &lt;&lt; (*pf)(lines) &lt;&lt; &quot; hours\n&quot;;//调用函数&#125; 简化声明的工具 1auto 1typedef 能够帮助创建类型别名double real;```1234567891011121314151617181920212223242526272829第8章 函数探幽===第9章内存模型和名称空间===第10章 对象和类===实际编程中已经实现了一些对象编程，有先验经验，不做过多的记录类规范组成：- 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口- 类方法定义：描述如何实现成员函数声明Stock类类型的变量，称为对象或实例使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数或者友元函数来访问对象的私有成员。所以公有成员函数是程序和对象的私有成员之间的桥梁。类涉及尽可能将公有接口和实现细节分开，将实现细节放在一起并将他们与抽象分开被称为封装。数据项通常放在私有部分，组成类接口的成员函数放在公有部分不必在类声明中使用关键字`private`，对类对象的默认访问控制- 实现类成员函数定义成员函数时，使用作用域解析运算符`::`来表示函数所属的类；类方法可以访问类的private组件 void Stock::update(double price)123456789101112131415161718192021222324252627282930313233意味着定义的函数是Stock成员Stock类的其他成员函数不必使用作用域解析运算符，就可以使用update()方法。内联方法：其定义位于类声明中的函数都将自动称为内联函数。也可以在类声明之外定义成员函数，并使其称为内联函数，只需在类实现部分中定义函数时使用inline限定符所创建的每个新对象都有自己的存储空间，存储内部变量和类成员，但是同一个类的所有对象共享同一组类方法，即每种方法只有一个副本一个实现面向对象编程的例子Stock.h```cpp#pragma once#include&lt;string&gt;class Stock&#123; std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: void acquire(const std::string &amp; co, long n, double pr); void buy(long num, double price); void sell(long num, double pricec); void update(double price); void show(); Stock();//构造函数 ~Stock();//析构函数&#125;; Stock.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include "Stock.h"void Stock::acquire(const std::string &amp; co, long n, double pr)&#123;//管理某个公司股票首次购买 company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; "number of shares cant be negative; " &lt;&lt; company &lt;&lt; "shares set to 0.\n"; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;void Stock::buy(long num, double price)&#123; if (num &lt; 0) &#123; std::cout &lt;&lt; "number of shares purchased cant be negative. " &lt;&lt; "transaction is aborted.\n"; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price)&#123; using std::cout; if (num &lt; 0) &#123; cout &lt;&lt; "number of shares sold cant be negative.\n"; &#125; else if (num &gt; shares) &#123;//用户试图卖出超过他持有的股票数量 cout &lt;&lt; "you cant sell more than you have!\n"; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price)&#123; share_val = price; set_tot();&#125;void Stock::show()&#123; std::cout &lt;&lt; "company: " &lt;&lt; company &lt;&lt; " shares: " &lt;&lt; shares &lt;&lt; "\n" &lt;&lt; "share price:$" &lt;&lt; share_val &lt;&lt; " total worth:$" &lt;&lt; total_val &lt;&lt; "\n";&#125;Stock::Stock()//类构造函数&#123; company = "no name"; shares = 0; share_val = 0.0; total_val = 0.0;&#125;//Stock::~Stock()//&#123;//&#125; Source.cpp12345678910111213141516171819#include&lt;iostream&gt;#include "Stock.h"int main()&#123; Stock fluffy_the_cat; fluffy_the_cat.acquire("NanoSmart", 20, 12.5); fluffy_the_cat.show(); fluffy_the_cat.buy(15, 19.2); fluffy_the_cat.show(); fluffy_the_cat.sell(400, 20.0); fluffy_the_cat.show(); fluffy_the_cat.buy(30000, 40.12); fluffy_the_cat.show(); fluffy_the_cat.sell(30000, 0.12); fluffy_the_cat.show(); system("pause"); return 0;&#125; 延伸：控制格式cout.setf() cout.precision(3) 类的构造函数和析构函数为类提供被称为构造函数和析构函数的标准函数c++的目标之一是让使用类对象就像使用标准类型一样，主要问题在于数据成员是私有的 解决方法是创造新对象时，自动对它初始化，c++提供了一个特殊的成员函数，类构造函数，专门用于构造新对象，将值赋给他的数据成员。Stock类一个可能的构造函数是名为Stock()的成员函数。构造函数没有声明类型 声明和定义构造函数 通常应提供所有类成员做隐式初始化的默认构造函数 初始化：123Stock first;Stock first = Stock();Stock * prelief = new Stock; 析构函数 用构造函数创建对象后，程序负责跟踪该对象，直到过期为止，对象过期时，程序将自动调用一个特殊的成员函数——析构函数，完成清理工作析构函数的名称在类名前加上~。 析构函数不承担任何重要工作，可以编写为不执行任何操作的函数 通常不应再代码中显式地调用析构函数，如果创建的是静态存储类对象，析构函数再程序结束时自动被调用，如果创建的时自动存储类对象，将再程序执行完代码块时自动被调用。如果对象是通过new创建的，将驻留再栈内存或者自由存储区，使用delete来释放内存时，析构函数将自动被调用 修改上面例子如下： 12345678910111213141516171819#pragma once#include&lt;string&gt;class Stock&#123; std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125;public: void acquire(const std::string &amp; co, long n, double pr); void buy(long num, double price); void sell(long num, double pricec); void update(double price); void show(); Stock();//构造函数 Stock::Stock(const std::string &amp; co, long n, double pr);//另一个构造函数,函数重载 ~Stock();//析构函数&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;iostream&gt;#include "Stock.h"void Stock::acquire(const std::string &amp; co, long n, double pr)&#123;//管理某个公司股票首次购买 company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; "number of shares cant be negative; " &lt;&lt; company &lt;&lt; "shares set to 0.\n"; shares = 0; &#125; else &#123; shares = n; &#125; share_val = pr; set_tot();&#125;void Stock::buy(long num, double price)&#123; if (num &lt; 0) &#123; std::cout &lt;&lt; "number of shares purchased cant be negative. " &lt;&lt; "transaction is aborted.\n"; &#125; else &#123; shares += num; share_val = price; set_tot(); &#125;&#125;void Stock::sell(long num, double price)&#123; using std::cout; if (num &lt; 0) &#123; cout &lt;&lt; "number of shares sold cant be negative.\n"; &#125; else if (num &gt; shares) &#123;//用户试图卖出超过他持有的股票数量 cout &lt;&lt; "you cant sell more than you have!\n"; &#125; else &#123; shares -= num; share_val = price; set_tot(); &#125;&#125;void Stock::update(double price)&#123; share_val = price; set_tot();&#125;void Stock::show()&#123; std::cout &lt;&lt; "company: " &lt;&lt; company &lt;&lt; " shares: " &lt;&lt; shares &lt;&lt; "\n" &lt;&lt; "share price:$" &lt;&lt; share_val &lt;&lt; " total worth:$" &lt;&lt; total_val &lt;&lt; "\n";&#125;Stock::Stock()&#123; company = "no name"; shares = 0; share_val = 0.0; total_val = 0.0;&#125;Stock::Stock(const std::string &amp; co, long n, double pr)&#123; std::cout &lt;&lt; "constructor using " &lt;&lt; co &lt;&lt; " called\n"; company = co; if (n &lt; 0) &#123; std::cout &lt;&lt; "number of shares cant be negative.\n"; shares = 0; &#125; else shares = n; share_val = pr; set_tot();&#125;Stock::~Stock()&#123; std::cout &lt;&lt; "bye, " &lt;&lt; company &lt;&lt; std::endl;&#125; 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;#include "Stock.h"int main()&#123; &#123; Stock stock1("NanoSmart", 12, 20.0); stock1.show(); Stock stock2 = Stock("Boffo", 2, 2.0); stock2.show(); stock1 = stock2; &#125; system("pause"); return 0;&#125; 在主函数中多了一个大括号，析构函数在程序退出其定义所属的代码块时消失，如果没有大括号，代码块将为整个main()，main()执行完毕后调用析构函数，就看不到输出了 注意程序初始化的方式：12Stock stock1(&quot;NanoSmart&quot;, 12, 20.0);Stock stock2 = Stock(&quot;Boffo&quot;, 2, 2.0); 如果构造函数使用了new，则必须提供使用delete的析构函数 this指针每个成员函数都有一个this指针，this指针指向调用对象，如果方法需要引用整个调用对象，则可以使用表达式*this，在函数的括号后面使用const限定符，则不能使用this来修改对象的值，this是指隐式对象的地址，对象本身为*this将下面这段代码加入到stock.cpp文件中 1234567const Stock &amp; Stock::topval(const Stock &amp; s) const&#123; if (s.total_val &gt; total_val) return s; else return *this;//返回隐式对象&#125; 对象数组12345678910111213void Stock::show() const&#123; using std::ios_base; using std::cout; ios_base::fmtflags orig = cout.setf(ios_base::fixed, ios_base::floatfield);//fixed是枚举量 std::streamsize prec = cout.precision(3); std::cout &lt;&lt; "company: " &lt;&lt; company &lt;&lt; " shares: " &lt;&lt; shares &lt;&lt; "\n" &lt;&lt; "share price:$" &lt;&lt; share_val; cout.precision(2); cout&lt;&lt; " total worth:$" &lt;&lt; total_val &lt;&lt; "\n"; cout.setf(orig, ios_base::floatfield); cout.precision(prec);&#125; 123456789101112131415161718#include&lt;iostream&gt;#include&lt;string&gt;#include "Stock.h"int main()&#123; const int size = 2; Stock stocks[size] = &#123; Stock("nano",12.5l,20), Stock("boffo", 20.2l, 1200) &#125;; const Stock * top = &amp;stocks[0];//这里还需要再明确 top = &amp;top-&gt;topval(stocks[1]); top-&gt;show(); system("pause"); return 0;&#125; 类作用域在类中定义的名称的作用域都为整个类，使用类成员名时，必须根据上下文使用直接成员运算符.,间接成员运算符-&gt;或作用域解析运算符::作用域为类的常量—— 使用枚举 1234567class Bakery&#123; private: enum &#123;Months = 12&#125;; double cots[Months]; ...&#125; 使用关键字static1234567class Bakery&#123;private: static const int Months = 12; double costs[Months]; ...&#125; 该变量与其他静态变量存储在一起，而不是存储在对象中，所有Bakery对象共享这一个变量 抽象数据类型emmm，看到这里好像看到了我原来面试的一道题 123456789101112131415#pragma oncetypedef unsigned long Item;//重新命名unsigned longclass Stack&#123; enum &#123;MAX = 10&#125;; Item items[MAX];//栈中存储的数据 int top;//栈顶index,指向栈顶为空的位置public: Stack(); bool isempty() const; bool isfull() const;//隐式对象不可变 bool push(const Item &amp; item);//隐式对象有变化 bool pop(Item &amp; item); ~Stack();&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041#include "Stack.h"Stack::Stack()//创建空栈&#123; top = 0;&#125;bool Stack::isempty() const&#123; return top == 0;&#125;bool Stack::isfull() const&#123; return top == MAX;&#125;bool Stack::push(const Item &amp; item)&#123; if (top &lt; MAX) &#123; items[top++] = item;//先赋值，top++ return true; &#125; else return false;&#125;bool Stack::pop(Item &amp; item)&#123; if (top &gt; 0) &#123; item = items[--top];//top--,赋值 return true; &#125; else return false;&#125;Stack::~Stack()&#123;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;string&gt;#include "Stock.h"#include "Stack.h"using namespace std;int main()&#123; Stack st; char ch; unsigned long po; cout &lt;&lt; "pls. enter A to add a purchase order,\n" &lt;&lt; "P to process a PO,or Q to quit,\n"; while (cin &gt;&gt; ch &amp;&amp; toupper(ch) != 'Q') &#123; while (cin.get() != '\n') continue; if (!isalpha(ch)) &#123; cout &lt;&lt; '\a'; continue; &#125; switch (ch) &#123; case 'A': case 'a':cout &lt;&lt; "enter a po number to add: "; cin &gt;&gt; po; if (st.isfull()) cout &lt;&lt; "stack is full\n"; else st.push(po); break; case 'P': case 'p': if (st.isempty()) cout &lt;&lt; "stack is empty\n"; else &#123; st.pop(po); cout &lt;&lt; po &lt;&lt; " popped\n"; &#125; break; default: break; &#125; &#125; system("pause"); return 0;&#125; 第11章 使用类运算符重载，应用于类对象1operator op() operator +() operator *() 友元函数，允许访问私有数据重载&lt;&lt;运算符，用于输出状态成员rand生成随机值类的自动转换和强制类型转换类转换函数先看到这里，需要提升的时候再接着看]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring入门]]></title>
    <url>%2F2018%2F08%2F12%2FSpring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[从零开始构建spring工程小例子 简单的spring例子环境：idea新建工程步骤参考：https://blog.csdn.net/zzy1078689276/article/details/78732183/ 可以不选择步骤中的archetype我的工程名字是spring-start 工程初始化会下载一些依赖，需要一些时间 编辑pom.xml文件，填写工程所依赖的库的配置信息123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.alisa&lt;/groupId&gt; &lt;artifactId&gt;spring-start&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring3-Example&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--sprint3 deploy--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 配置项规定了工程的编码格式和依赖的包包括:junit和org.springframework.spring-context org.springframework.spring-core 创建目录结构我的目录结构如图所示： 如果右键新建没有class和package,请参考这篇博客：https://blog.csdn.net/qq_27093465/article/details/52912444我设置的java文件夹Sources，resources文件夹是Resources 编辑HelloWorld App SpringBeans文件HelloWorld1234567891011package com.alisa.demo.helloworld;public class HelloWorld &#123; private String name; public void setName(String n)&#123; this.name = n; &#125; public void printHello()&#123; System.out.println("hello:"+name); &#125;&#125; App文件通过getBean方法（参数是id）访问配置文件中的bean标签（可能我的说法不准确)1234567891011121314package com.alisa.demo.spring3_Example;import com.alisa.demo.helloworld.HelloWorld;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml");//声明从SpringBeans.xml获取配置文件 HelloWorld obj = (HelloWorld) context.getBean("helloBean"); obj.printHello(); &#125;&#125; SpringBeans文件中重要的是bean标签的编辑，在一个文件中bean标签的id唯一，class属性定义所连接的java class文件，&lt;property&gt;定义了与class相关的值，这里主要是name和value，我的理解是将class文件中的name变量的值设置为alisa.12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloBean&quot; class=&quot;com.alisa.demo.helloworld.HelloWorld&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;alisa&quot; &gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 运行便可出现结果 实现松耦合在包com.alisa.demo下新建包loosely_coupled,并在此目录下新建Interface和class文件IOutputGenerator实现抽象类12345package com.alisa.demo.loosely_coupled;public interface IOutputGenerator &#123; public void generatorOutput();&#125; CsvOutputGenerator重写上面接口函数1234567package com.alisa.demo.loosely_coupled;public class CsvOutputGenerator implements IOutputGenerator&#123; public void generatorOutput() &#123; System.out.println("creating csv..."); &#125;&#125; JsonOutputGenerator重写继承的接口函数1234567package com.alisa.demo.loosely_coupled;public class JsonOutputGenerator implements IOutputGenerator&#123; public void generatorOutput() &#123; System.out.println("creating json..."); &#125;&#125; OutputHelper文件可以设定当前的OutputGenerator实例对象123456789101112package com.alisa.demo.loosely_coupled;public class OutputHelper &#123; IOutputGenerator outputGenerator; public void generatorOutput()&#123; this.outputGenerator.generatorOutput();//设定实例对象的输出函数 &#125; public void setOutputGenerator(IOutputGenerator outputGenerator) &#123; this.outputGenerator = outputGenerator;//设定实例对象 &#125;&#125; 在resources下新建Spring-Output.xml文件，id为OutputHelper的bean是App文件中所连接的bean，指定java class文件，设置class文件中的outputGenerator值为CsvOutputGenerator(这里从上面的value属性改为ref属性我不是很理解)，可能ref属性会寻找当前配置文件中id属性值为CsvOutputGenerator的bean标签，从而得到该CsvOutputGenerator类的内容12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name=&quot;outputGenerator&quot; ref=&quot;CsvOutputGenerator&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;CsvOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;JsonOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.JsonOutputGenerator&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 修改App文件，没有明确指出所定义的输出实例对象是哪一个，而是通过配置文件来设定12345678910111213141516package com.alisa.demo.spring3_Example;import com.alisa.demo.helloworld.HelloWorld;import com.alisa.demo.loosely_coupled.OutputHelper;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("Spring-Output.xml");//修改配置文件// HelloWorld obj = (HelloWorld) context.getBean("helloBean");// obj.printHello(); OutputHelper outputHelper = (OutputHelper)context.getBean("OutputHelper"); outputHelper.generatorOutput(); &#125;&#125; 实现了通过Spring-Output.xml控制代码输出 Spring Ioc容器Spring中给Bean属性注入value在包com.alisa下新建包spring.bean在该包下新建class文件FileNameGenerator和App123456789101112131415161718192021222324package com.alisa.spring.bean;public class FileNameGenerator &#123; private String name; private String type; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public void printFileName()&#123; System.out.println("filename &amp; filetype is:"+name+" &amp; "+type); &#125;&#125; App12345678910111213package com.alisa.spring.bean;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context; public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml"); FileNameGenerator obj = (FileNameGenerator) context.getBean("FileNameGenerator"); obj.printFileName(); &#125;&#125; 编辑SpringBeans.xml文件123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="helloBean" class="com.alisa.demo.helloworld.HelloWorld"&gt; &lt;property name="name" value="alisa" &gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="FileNameGenerator" class="com.alisa.spring.bean.FileNameGenerator"&gt; &lt;property name="name"&gt; &lt;value&gt;alisa&lt;/value&gt; &lt;/property&gt; &lt;!--&lt;property name="name" value="alisa"&gt;&lt;/property&gt;--&gt; &lt;property name="type"&gt; &lt;value&gt;txt&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--&lt;bean id="FileNameGenerator" class="com.alisa.spring.bean.FileNameGenerator" p:name="alisa" p:type="txt"&gt;&lt;/bean&gt;--&gt;&lt;/beans&gt; 注意到value属性的三种定义方式： name12 &lt;value&gt;alisa&lt;/value&gt;&lt;/property&gt; name13. ```&lt;bean id=&quot;FileNameGenerator&quot; class=&quot;com.alisa.spring.bean.FileNameGenerator&quot; p:name=&quot;alisa&quot; p:type=&quot;txt&quot;&gt;&lt;/bean&gt; 第三种方式需要在开头加上xmlns:p=&quot;http://www.springframework.org/schema/p&quot; Spring Inner Bean—内部嵌套的Bean内置嵌套的Bean支持属性注入和构造函数注入 在实现【松耦合】一节中所提到的ref属性其实就是Bean内部嵌套，所以我之前的猜想是正确的重新回顾那一节的配置文件12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name=&quot;outputGenerator&quot; ref=&quot;CsvOutputGenerator&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;CsvOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;JsonOutputGenerator&quot; class=&quot;com.alisa.demo.loosely_coupled.JsonOutputGenerator&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 利用ref属性引用了CsvOutputGenerator,但是一旦CsvOutputGenerator引用，就不会被别的Bean引用采用下面的方法可以避免这样的问题： 修改方式如下：123456789&lt;!--&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt;--&gt; &lt;!--&lt;property name=&quot;outputGenerator&quot; ref=&quot;CsvOutputGenerator&quot;&gt;&lt;/property&gt;--&gt;&lt;!--&lt;/bean&gt;--&gt;&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;property name=&quot;outputGenerator&quot;&gt; &lt;bean class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt; &lt;/bean&gt; &lt;/property&gt;&lt;/bean&gt; 在内部声明一个Bean，但是我并没有觉得方便，还有一种方式是：12345678910&lt;bean id=&quot;OutputHelper&quot; class=&quot;com.alisa.demo.loosely_coupled.OutputHelper&quot;&gt; &lt;constructor-arg&gt; &lt;bean class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt; &lt;/bean&gt; &lt;/constructor-arg&gt; &lt;!--&lt;property name=&quot;outputGenerator&quot;&gt;--&gt; &lt;!--&lt;bean class=&quot;com.alisa.demo.loosely_coupled.CsvOutputGenerator&quot;&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;/property&gt;--&gt;&lt;/bean&gt; 但是这个例子在我这里显示是错的，还没有搞懂是为什么 Spring Bean Scopes—Bean的作用域Bean的作用域决定了从Spring容器中返回的Bean实例的类型。在Spring中，支持以下5种类型的作用域： singleton——单利模式，由IOC容器返回一个唯一的bean实例 prototype——原型模式，被请求时，每次返回一个新的bean实例 request——每个http request请求返回一个唯一的bean实例 session——每个http session返回一个唯一的bean实例 globalSession——http session全局bean实例 singleton 和prototype区别新建包com.alisa.spring.customer.services在该目录下新建class文件CustomerService和App123456789101112package com.alisa.spring.customer.services;public class CustomerService &#123; String message; public String getMessage()&#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; App12345678910111213141516package com.alisa.spring.customer.services;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringBeans.xml"); CustomerService customerService = (CustomerService)context.getBean("CustomerService"); customerService.setMessage("message by 1"); System.out.println("1:"+customerService.getMessage()); CustomerService customerService2 = (CustomerService)context.getBean("CustomerService"); System.out.println("2:"+customerService2.getMessage()); &#125;&#125; 在SpringBeans.xml文件中新增下面语句，分别将scope参数设置成prototype singleton看下结果 1&lt;bean id=&quot;CustomerService&quot; class=&quot;com.alisa.spring.customer.services.CustomerService&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt; 在prototype模式下每次调用getBean函数都生成一个新的实例 Spring collections—集合类型的Bean主要讲怎样将值注入集合类型： List Set Map Properties 在b包spring下面新建包collections,新建Customer Person App类编辑文件Person12345678910111213141516171819202122232425package com.alisa.spring.collections;public class Person &#123; private String name; private String address; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; @Override public String toString()&#123; return "Person [address="+address+",name="+name+"]"; &#125;&#125; Customer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.alisa.spring.collections;import java.util.List;import java.util.Map;import java.util.Properties;import java.util.Set;public class Customer &#123; private List&lt;Object&gt; lists; private Set&lt;Object&gt; sets; private Map&lt;Object,Object&gt; maps; private Properties pros; public List&lt;Object&gt; getLists()&#123; return lists; &#125; public void setLists(List&lt;Object&gt; lists) &#123; this.lists = lists; &#125; public Set&lt;Object&gt; getSets() &#123; return sets; &#125; public void setSets(Set&lt;Object&gt; sets) &#123; this.sets = sets; &#125; public Map&lt;Object, Object&gt; getMaps() &#123; return maps; &#125; public void setMaps(Map&lt;Object, Object&gt; maps) &#123; this.maps = maps; &#125; public Properties getPros() &#123; return pros; &#125; public void setPros(Properties pros) &#123; this.pros = pros; &#125; private Person person; public Customer(Person person)&#123; this.person = person; &#125; public Customer()&#123;&#125; public void setPerson(Person person) &#123; this.person = person; &#125; @Override public String toString() &#123; return "Customer [person="+person+"]"; &#125;&#125; App1234567891011121314151617181920package com.alisa.spring.collections;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; private static ApplicationContext context;//继承BeanFactory public static void main(String[] args)&#123; context = new ClassPathXmlApplicationContext("SpringCollections.xml"); Customer obj = (Customer) context.getBean("CustomerBean"); System.out.println(obj.getLists().toString()); System.out.println(obj.getMaps().toString()); System.out.println(obj.getPros().toString()); System.out.println(obj.getSets().toString());// [1, Person [address=beijing,name=alisa], 2, Person [address=jilin,name=ben]]// &#123;a=1, b=Person [address=beijing,name=alisa], c=Person [address=jilin,name=ben]&#125;// &#123;admin=admin, support=support&#125;//[1, Person [address=beijing,name=alisa], Person [address=jilin,name=ben]] &#125;&#125; 编辑配置文件SpringCollections.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;CustomerBean&quot; class=&quot;com.alisa.spring.collections.Customer&quot;&gt; &lt;property name=&quot;lists&quot;&gt; &lt;list&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean=&quot;personBean&quot;&gt;&lt;/ref&gt; &lt;value&gt;2&lt;/value&gt; &lt;bean class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ben&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;jilin&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;sets&quot;&gt; &lt;set&gt; &lt;value&gt;1&lt;/value&gt; &lt;ref bean=&quot;personBean&quot;&gt;&lt;/ref&gt; &lt;bean class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ben&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;jilin&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;maps&quot;&gt; &lt;map&gt; &lt;entry key=&quot;a&quot; value=&quot;1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;b&quot; value-ref=&quot;personBean&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;c&quot;&gt; &lt;bean class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;ben&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;jilin&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;pros&quot;&gt; &lt;props&gt; &lt;prop key=&quot;admin&quot;&gt;admin&lt;/prop&gt; &lt;prop key=&quot;support&quot;&gt;support&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;personBean&quot; class=&quot;com.alisa.spring.collections.Person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;alisa&quot;&gt;&lt;/property&gt; &lt;property name=&quot;address&quot; value=&quot;beijing&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; Spring注解的配置注解是为Spring容器提供Bean定义的信息，把XML定义的信息通过类注解描述出来。Spring他容器三大要素：Bean定义，Bean实现类和Spring框架。采用XML配置，Bean定义和Bean实现类本身分离，而采用注解配置，Bean定义在Bean实现类上注解就可以实现。 几种注解的方式： @Component @Autowired Configuration——表示核心配置文件 注解的例子见下一节 Spring自动扫描与自动装配在spring下新建包services dao common在dao下新建CustomerDAO.java, services下新建CustomerService.java common下新建App.java 编辑这几个文件CustomerDAO.java1234567891011package com.alisa.spring.dao;import org.springframework.stereotype.Component;@Componentpublic class CustomerDAO &#123; @Override public String toString()&#123; return "hello this is a dao"; &#125;&#125; CustomerService.java123456789101112131415161718192021222324package com.alisa.spring.services;import com.alisa.spring.dao.CustomerDAO;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class CustomerService &#123; @Autowired CustomerDAO customerDAO;// public CustomerDAO getCustomerDAO() &#123;// return customerDAO;// &#125;//// public void setCustomerDAO(CustomerDAO customerDAO) &#123;// this.customerDAO = customerDAO;// &#125; @Override public String toString() &#123; return "CustomerService [customerDAO="+customerDAO+"]"; &#125;&#125; App.java12345678910111213package com.alisa.spring.common;import com.alisa.spring.services.CustomerService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("SpringCustomer.xml"); CustomerService customerService = (CustomerService) context.getBean("customerService"); System.out.println(customerService); &#125;&#125; 新建配置文件SpringCustomer.xmlbase-package表示组件的存放位置，扫描对应文件夹下的bean(用@Component注释过的)，将这些bean注册到容器中1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--&lt;bean id="customerService" class="com.alisa.spring.services.CustomerService"&gt;--&gt; &lt;!--&lt;property name="customerDAO" ref="customerDAO"&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--&lt;bean id="customerDAO" class="com.alisa.spring.dao.CustomerDAO"&gt;&lt;/bean&gt;--&gt; &lt;context:component-scan base-package="com.alisa.spring"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; @Component表示这个class文件是一个自动扫描组件默认情况下，Spring将把组件class的第一个字母变成小写，来作为自动扫描组件的名称 也可以像下面这样，创建自定义的组件名称123@Service("AAA")public class CustomerService... 需要添加下面的代码1import org.springframework.stereotype.Service; 调用自己定义的组件1CustomerService customerService = (CustomerService) context.getBean("AAA"); 自动扫描组件的注释类型 @Component——自动扫描 @Repository——持久化层的DAO @Service——业务逻辑层的Service @Controller——表示层的Controller 后面三种只是加强代码可读性 可以将上面的例子改成1234567@Repositorypublic class CustomerDAO &#123; @Override public String toString()&#123; return "hello this is a dao"; &#125;&#125; 123456789101112131415161718@Servicepublic class CustomerService &#123; @Autowired CustomerDAO customerDAO;// public CustomerDAO getCustomerDAO() &#123;// return customerDAO;// &#125;//// public void setCustomerDAO(CustomerDAO customerDAO) &#123;// this.customerDAO = customerDAO;// &#125; @Override public String toString() &#123; return "CustomerService [customerDAO="+customerDAO+"]"; &#125;&#125; 自动扫面中过滤组件 include只需要匹配定义的“regex”命名规则，Class前就不用注释 只需要新建配置文件SpringFiltering.xml即可,只要包含Service和DAO的就会被注册到Spring容器12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com.alisa.spring"&gt; &lt;context:include-filter type="regex" expression="com.alisa.spring.dao.*DAO.*"&gt;&lt;/context:include-filter&gt; &lt;context:include-filter type="regex" expression="com.alisa.spring.services.*Service.*"&gt;&lt;/context:include-filter&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; exclude规定组件避免被Spring发现并注册到容器中 自动装配Bean将一个Bean注入到其他的Bean的Property中。Spring支持5种自动装配模式 no——通过ref手动设定 byName——如果一个Bean的name和另一个Bean的property的name相同，自动装配 byType——如果一个bean的数据类型，兼容另一个bean种的property的数据类型，自动装配 constructor——根据构造函数参数的数据类型进行byType模式的自动装配 autodetect——如果发现默认的构造函数，用constructor模式，否则用byType Spring AOP-AdviceSpring AOP专门用于处理系统种分布于各个模块种交叉关注点的问题，拦截一些处理过程。支持4种类型的通知(Advice): 执行前通知 返回一个结果后通知 抛出异常后通知 环绕通知 首先新建几个文件在包spring下新建aop.advice包，在下面新建CustomerService.java和App.java新建配置文件SpringAOPAdvice.xml编辑12345678910111213141516171819202122232425package com.alisa.spring.aop.advice;public class CustomerService &#123; private String name; private String url; public void setName(String name)&#123; this.name = name; &#125; public void setUrl(String url)&#123; this.url = url; &#125; public void printName()&#123; System.out.println("customer name:"+this.name); &#125; public void printUrl()&#123; System.out.println("customer website:"+this.url); &#125; public void printThrowException()&#123; throw new IllegalArgumentException(); &#125;&#125; 12345678910111213141516171819package com.alisa.spring.aop.advice;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class App &#123; public static void main(String[] args)&#123; ApplicationContext context = new ClassPathXmlApplicationContext("SpringAOPAdvice.xml"); CustomerService customerService = (CustomerService) context.getBean("customerService"); customerService.printName(); customerService.printUrl(); try&#123; customerService.printThrowException(); &#125;catch (Exception e) &#123; &#125; &#125;&#125; 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="customerService" class="com.alisa.spring.aop.advice.CustomerService"&gt; &lt;property name="name" value="alisa"&gt;&lt;/property&gt; &lt;property name="url" value="http://"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 新建文件HijackBeforeMethod123456789101112package com.alisa.spring.aop.advice;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class HijackBeforeMethod implements MethodBeforeAdvice &#123; public void before(Method arg0, Object[] args, Object target) throws Throwable &#123; System.out.println("hijackBeforeMethod"); &#125;&#125; 在配置文件种加入新的bean配置HijackBeforeMethod，然后创建一个新的代理，命名为customerServiceProxytarget定义你想劫持哪个bean;interceptNames定义想用哪个class劫持target]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>java</tag>
        <tag>开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础语法]]></title>
    <url>%2F2018%2F08%2F11%2Fjava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[java语法的积累java和scala的不同：Java继承与Java多态 利用文本编辑java程序新建HelloWorld.java文件输入一下内容12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(&quot;hello world&quot;); &#125;&#125; 进入文件所在目录执行javac HelloWorld.java,文件夹下就会多一个HelloWorld.class文件，执行java HelloWorld输出代码结果 java语言基础常量表示12final double PI = 3.14final char A = 'a'; 常量可以首先声明，然后赋值，但是只能赋值一次 java运算符位运算符 &amp;按位与 |按位或 ^按位异或 ~按位补 &lt;&lt;按位左移 &gt;&gt;按位右移 &gt;&gt;&gt;按位右移补零 逻辑运算符 &amp;&amp; || ! ^异或，不同为1 java数组数组的定义和初始化声明数组123int ages[];char sys[];String [] name; 分配空间12int [] ages = &#123;12,14,35&#125;;char [] sym = new char[10]; 可以把一个数组赋值给另一个数组,实际上a1和a2指向了内存中同一个地址，修改其中一个数组，另一个也改变12int [] a1 = &#123;1,2,3&#125;;int [] a2 = a1; 12345int [] ages = &#123;1,23,4&#125;;for(int i = 0 ;i &lt; ages.length;i++)&#123; System.out.println("数组中第"+(i+1)+"个元素是"+ages[i]);&#125; 二维数组1String [][] name = &#123;&#123;"zhao","fdaf"&#125;,&#123;"va","fa"&#125;&#125;; java方法123访问修饰符 返回值类型 方法名(参数列表)&#123; 方法体&#125; 访问修饰符：代表方法允许被访问的权限范围，public protected private一个java方法的小例子12345678910public class PrintScore&#123; public static void main(String[] args)&#123; PrintScore a = new PrintScore(); int rSum; rSum = a.calcSum(2,3); &#125; public int calcSum(int a,int b)&#123; return a+b; &#125;&#125; 方法重载，在Java中通过类中写多个方法，这类方法的方法名相同，参数列表不同（参数个数和参数类型不同）来实现重载 Java类与对象一个类可以包含一下类型变量： 局部变量，在方法中定义的变量 成员变量，定义在类中，方法体之外的变量，在创建对象的时候实例化 类变量， 也叫静态变量，类声明也在类中，方法体之外，但必须声明为static类型 构造方法每个类都有构造方法。如果没有显式地为类构造方法，Java编译器会构建默认构造方法，可以又多个构造方法语法格式为：123public 构造方法名()&#123;&#125; 例子:12345678public class People&#123; double height; int age; public People(double h,int a)&#123; height = h; age = a; &#125;&#125; 123People tt = new People(13,134);tt.height = 12;tt.age = 34; java继承继承可以看作是类与类之间的衍生关系，父类更通用，子类更具体 1class 子类 extends 父类 继承的例子：先创建一个父类Animal123456public class Animal&#123; public int legNum; public void bark()&#123; System.out.println("animal"); &#125;&#125; 再创建一个子类(习惯手写继承)：123public class Dog extends Animal&#123;&#125; 创建一个Test类，作为程序入口1234567public class Test&#123; public static void main(String[] args)&#123; Dog s = new Dog(); a.legNum = 4; a.bark(); &#125;&#125; 继承的特点 子类拥有父类除了private以外的所有属性和方法 子类可以拥有自己的属性和方法 子类可以重写实现父类的方法 Java中的继承是单继承，一个类只有一个父类（这里和scala有所区别） Java实现多继承的一个办法是implements接口 子类方法重写接着上面的例子，修改Dog类,重新运行测试12345public class Dog extends Animal&#123; public void bark()&#123; System.out.println(&quot;bark...&quot;); &#125;&#125; 继承的初始化顺序系统先创建父类对象，再创建子类对象，先初始化属性，再调用构造函数 小知识final关键字可以修饰类、方法、属性和变量 final修饰类，则该类不允许被继承，为最终类 final修饰方法，则方法不允许被重写 final修饰属性，则该类的属性不会进行隐式的初始化或在构造方法中赋值 final修饰变量，则该变量的赋值只有一次 super关键字在子类内部使用，代表父类对象 访问父类的属性super.属性名 访问父类的方法super.bark() 子类构造方法需要调用父类的构造方法时，在子类的构造方法里最前面的位置：super() java多态多态是指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。多态也称作动态绑定，是指在执行期间判断所引用对象的实际类型，根据实际类型调用相应的方法 向上转型下面这段代码接着上一节1Animal b = new Dog(); 由于Dog继承于Animal，所以Dog可以自动向上转型为Animal，所以b是可以指向Dog实例对象的 不能使用一个子类的引用去指向父类的对象Dog a = new Animal()是错的 如果定义了一个指向子类对象的父类引用类型，除了能够引用父类中定义的所有属性和方法外，还可以使用子类强大的功能（子类中重写的方法会覆盖父类的方法），但是对于只存在于子类的方法和属性就不能获取 多态的实现方式多态的实现条件：继承、重写和向上转型多态的实现方式：继承父类进行方法重写，抽象类和抽象方法，接口实现 抽象方法声明语法1abstract void f(); 包含抽象方法的类叫做抽象类，抽象类在定义类时，会加上abstract关键字 使用抽象类的情况 某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法，父类只关注约束子类要实现的方法，而不关注方法如何实现 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，避免子类设计的随意性 抽象类可以没有抽象方法 抽象类的对象不能直接创建，通常是定义引用变量指向子类对象 一个实现抽象类的例子:1234public abstract class TelePhone&#123; public abstract void call(); public abstract void message();&#125; 接口实现abstract关键字允许在类中创建一个或多个没有任何定义的方法，而interface使抽象的概念更向前迈进了一步，会产生一个完全抽象类，根本没有提供任何方法体 12345interface Animal&#123; int y = 5; public void eat(); public void travel();&#125; 接口不能用于实例化对象 接口中所有的方法是抽象方法 接口成员是static final类型 接口支持多继承 多继承的实现方式：123456修饰符 interface A extends 接口1，接口2&#123;&#125;修饰符 class A implements 接口1，接口2&#123;&#125; 一个实现多态的例子“1234public interface Animal&#123; public void bark(); public void travel();&#125; 123public interface Dog&#123; public void eat();&#125; 1234567891011public class Cat implements Animal,Dog&#123; public void bark()&#123; &#125;; public void travel()&#123; &#125;; public void eat()&#123; &#125;;&#125; Cat类必须对接口中的抽象方法重写]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令笔记]]></title>
    <url>%2F2018%2F08%2F11%2Flinux%E5%91%BD%E4%BB%A4%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[日积月累linux命令 需要学会的快捷键 ctrl+d键盘输入结束或者退出终端 ctrl+s暂停当前程序后按下任意键恢复运行 ctrl+z当前程序放到后台运行，回复到前台是fg ctrl+a光标移至行头 ctrl+e光标移至行末 ctrl+k删除光标所在位置到行末 alt+backspace向前删除一个单词 通配符? *12touch asd.txt qaz.txtls *.txt 1touch love_&#123;1..10&#125;_file.txt Linux用户管理查看当前用户属性1who am i 创建用户利用sudo命令创建用户需要root权限，需要知道当前登录用户的密码，且当前用户必须在sudo用户组1sudo adduser lilei 创建用户的同时创建lilei文件夹,切换登录用户，输入密码1su -l lilei 用户注销exit 查看用户组输入下面命令可以看到用户属于的用户组1groups shiyanlou 查看etc/group文件1cat /etc/group | sort 可以使用命令过滤掉一些不想看到的结果1cat /etc/group | grep -E &quot;shiyanlou&quot; 将其他用户加入sudo用户组先切换到要加入sudo用户组的用户12su -l lileisudo ls 使用usermod命令可以为用户添加用户组1234su shiyanlougroups lileisudo usermod -G sudo lileigroups lilei 删除用户1sudo deluser lilei --remove-home Linux 文件基本属性1234[root@www /]# ls -ltotal 64dr-xr-xr-x 2 root root 4096 Dec 14 2012 bindr-xr-xr-x 4 root root 4096 Apr 19 2012 boot 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。 当为[ d ]则是目录 当为[ - ]则是文件； 若是[ l ]则表示为链接文档(link file)； 若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已。 Linux 文件与目录管理 ls: 列出目录 -a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) cd：切换目录 [root@www ~]# cd /root/runoob/ [root@www runoob]# cd ~回到家目录 [root@www runoob]# cd ..回到上一级目录 pwd：显示目前的目录 mkdir：创建一个新的目录 -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～[root@www tmp]# mkdir -m 711 test2 -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！[root@www tmp]# mkdir -p test1/test2/test3/test4 rmdir：删除一个空的目录rmdir [-p] 目录名称 -p ：连同上一级『空的』目录也一起删除 [root@www tmp]# rmdir runoob/ cp: 复制文件或目录 rm: 移除文件或目录 tmp]# rm -i bashrc1rm: remove regular file `bashrc&apos;? y 变更文件所有者现在有两个用户shiyanlou 和lilei,当前用户为shiyanlou,切换到lilei用户创建文件,查看文件所属用户123su -l lilei touch iphone6ll iphone6 切换到shiyanlou用户，更改文件所有者，查看文件所有者123su shiyanlousudo chown shiyanlou iphone6ll iphone6 修改文件权限1chmod 600 iphone6 Linux文件基本操作Linux 文件内容查看 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出 tac 是 cat 的倒著写！ nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容 less 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head 只看头几行 tail 只看尾巴几行 新建文件123touch testmkdir mydirmkdir father/son/grandson 复制文件复制test文件到后面目录复制文件夹需要加上-r参数，将子目录一同复制12cp test father/son/grandsoncp -r father family 删除文件 直接删除 1rm test 删除只读文件会有提示 1234touch testchmod 444 testll testrm test 若不想有提示1rm -f test 删除目录1rm -r family 移动文件与文件重命名123mkdir Doctouch filemv file doc 重命名1mv file1 myfile 编辑文件1vimtutor Linux 磁盘管理 df：列出文件系统的整体磁盘使用量 123456[root@www ~]# df -hFilesystem Size Used Avail Use% Mounted on/dev/hdc2 9.5G 3.7G 5.4G 41% //dev/hdc3 4.8G 139M 4.4G 4% /home/dev/hdc1 99M 11M 83M 12% /boottmpfs 363M 0 363M 0% /dev/shm du：检查磁盘空间使用量 fdisk：用于磁盘分区]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>其他</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自从学了计算机，我得了一种“怪病”]]></title>
    <url>%2F2018%2F08%2F11%2F%E8%87%AA%E4%BB%8E%E5%AD%A6%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%8C%E6%88%91%E5%BE%97%E4%BA%86%E4%B8%80%E7%A7%8D%E2%80%9C%E6%80%AA%E7%97%85%E2%80%9D%2F</url>
    <content type="text"><![CDATA[标题党说的就是我，没跑了我只是在疗伤^&amp;^ 自从学了计算机，我慢慢发现我忘记了怎样享受闲暇的时光。每当放下所有的事，不去想还没有完成的代码、还没有学习的分布式、还没看懂的强化学习，除非让其他事情充实时间，否则我就会“生病”。反而在不断的学习中，体会进步的乐趣，享受高亮的代码所带给我的欢愉。 我的生活是由许多的已完成事项和待办事项组成，仿佛只有这样我才能正常运转，即使是我的课余爱好，都被安排进我的列表里，我渴望挣脱 在许多人的眼里，我是个学霸，勤勤奋奋，也拿着傲人的成绩，在自己的心中，有着不知多久才能填满的欲望鸿沟，这欲望不是拥有多少只mac、ysl，这欲望不是打卡多少次演唱会，这欲望不是去多少个城市几个大洲旅行而是能够凭借自己的努力过上温馨的小日子 小学五年级的时候神州五号飞船成功发射，那时候我的梦想是当一名宇航员，长大后我的梦想不见了 只剩下了愿望 我不知道我要多努力，要努力多久才能满足我的简单又不简单的小愿望 我是一个简单的存在，我知道自己喜欢什么，厌恶什么 我是一个独立的存在，不依靠任何人，内心强大又软弱 我是一个孤独的存在，不孤单 我喜欢窝在屋子里看书，没有人打扰，如果他可以陪着我一起看书，那再好不过，哪怕只有几十平米的出租屋 我喜欢骑车，我觉得那时的我是自由的，是和自然合二为一的，体会耳边的风声，还有不自觉的微笑，哪怕爬坡会累，屁股会痛，骑车会有风险 我喜欢跑步，尤其喜欢设定跑步的目标，我小妹说我活得规规矩矩，我不知道那是怎样的一种感觉，可能享受流汗的感觉 我喜欢画画，但是我很少画画，我的大部分时间都贡献给了增长知识和技能，小时候画画是一种乐趣，却不得要领，现在画画是一种奢望，时间是一种奢侈品，但我想，如果可以我可能是个不错的画师，毕竟我可以坐几个小时不动 我喜欢看科幻魔幻电影和情节发展明显的英剧和美剧，我没有对演员、导演、作者有特别的偏好，只单纯看作品，并喜欢它们所带给我的思考 我喜欢乒乓球，但是我很菜，嗯，基本上每次都会这样说，与乒乓球印象最深的三个场景，第一幕是高中带我乒乓球入门的几个哥们，我的坏底子估计有他们的原因，那可能是个可爱的春天，在老三中露天的操场上有几台孤零零的乒乓球台，我们几个在那里并不正儿八经的打球；第二幕是大一参加师生乒乓球赛，女双，接到了一个难度超大的球，以迷之弧度打到了对方的案边；第三幕是大三的最后一堂乒乓球课上，交叉比赛，最后一组和班上乒乓球打的最好的女生交手，比分不记得了反正我输了，结束后她对我说：你应该参加学校的乒乓球赛。我想可能是因为它们给了我鼓励和信心 我喜欢代码，准确的说是喜欢我能看得懂的代码，每次学习新的代码就会莫名的兴奋，就像我自己的博客，无脑搭建，但是仍然很兴奋，很容易带给我成就感，但是最近看强化学习看的非常难受，我喜欢按照自己的节奏去学习，不喜欢被push得太紧，实际上可能就是我的性子太急了 实际上，我的大部分时间都贡献给了看得懂的看不懂的代码，因为这是我以后赖以生存的基础 我想这也可能算作是物质的一种，为了满足起码的需求，每当我停下来就会有一种危机感，电脑和手机在我的生活中占据了越来越大的比重，每天都提醒自己，不要让它们占据我的睡眠，每天坚持10点到11点半之间睡觉，而且我的睡眠一直不错，这是一件让我感到幸福的事情，即使是假期早晨也会在七点半到八点半之间自然醒，可能在别人看来这是勤奋使然，我发现，自然醒的早起让我有种莫名的开心，可能这是我的身体给我的反馈，就像跑步一样 放假在家的这段时间，每天都很充实，学习、画画、看书、跑步，码代码、看电影，可以说是很幸福了，然而我却希望有一种技能，可以让我防空自我、停止思考、享受闲暇的静谧时光 每当生病的时候，要么有肩膀可以靠一靠，要么写一些无厘头的字 第二天我的病就痊愈了]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-696-788]]></title>
    <url>%2F2018%2F08%2F11%2Fleetcode-string-easy-696-788%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是696,788 题目：696. Count Binary Substrings描述：Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur.例子：1234567Input: &quot;00110011&quot;Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1&apos;s and 0&apos;s: &quot;0011&quot;, &quot;01&quot;, &quot;1100&quot;, &quot;10&quot;, &quot;0011&quot;, and &quot;01&quot;.Notice that some of these substrings repeat and are counted the number of times they occur.Also, &quot;00110011&quot; is not a valid substring because all the 0&apos;s (and 1&apos;s) are not grouped together. 代码：12345678910111213141516171819202122232425262728int Solution696::countBinarySubstrings(string s)&#123; int num = 0; vector&lt;int&gt; group; int index = 0; for (int i = 1; i &lt; s.size(); ++i) &#123; if (s[i] != s[i - 1] &amp;&amp; i != s.size() - 1) &#123; group.push_back(i - index); index = i; &#125; else if (s[i] != s[i - 1] &amp;&amp; i == s.size() - 1)//i和index不在同一个片段 &#123; group.push_back(i - index);//先把i前面的片段长度加入 group.push_back(1);//再将i所在的片段加入 &#125; else if (i == s.size() - 1)//i和index在同一个片段 &#123; group.push_back(i - index + 1); &#125; &#125; for (int i = 1; i &lt; group.size(); ++i) &#123; num += min(group[i], group[i - 1]); &#125; return num;&#125; 解题边界条件： 最后一个元素与前一个元素相同 最后一个元素与前一个元素不同 题目：788. Rotated Digits描述：X is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good?例子：12345Input: 10Output: 4Explanation: There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647bool Solution788::isDiff(int x)&#123; int flag = 0; while (x &gt; 0) &#123; int v = x % 10; if(v == 0 || v == 1 || v == 8)&#123;&#125; else if (flag == 0 &amp;&amp; v == 2 || v == 5 || v == 6 || v == 9)flag = 1; else if(v == 3 || v == 4 || v == 7) return false; x = x / 10; &#125; return flag;&#125;int Solution788::rotatedDigits(int N)&#123; //int num = 0; //int flag; //int invalid;//0-valid 1--invalid //for (int i = 1; i &lt;= N; ++i) //&#123; // flag = 0; // invalid = 0; // string int_string = to_string(i); // for (int j = 0; j &lt; int_string.size(); ++j) // &#123; // if (flag == 0 &amp;&amp; int_string[j] == '2' || int_string[j] == '5' || int_string[j] == '6' || int_string[j] == '9') // &#123; // flag = 1; // &#125; // if (int_string[j] == '3' || int_string[j] == '4' || int_string[j] == '7') // &#123; // invalid = 1;//表示有3，4，7 // break; // &#125; // &#125; // if (!invalid &amp;&amp; flag)++num; //&#125; //return num; int num = 0; while (N &gt; 0) &#123; if (isDiff(N))++num; --N; &#125; return num;&#125; 数字比较比字符串比较速度快 将数字转换成字符串的内置函数to_string() 不要忘记invalid digit比较 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-next主题博客网站优化]]></title>
    <url>%2F2018%2F08%2F11%2Fhexo-next%E4%B8%BB%E9%A2%98%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[最开心的事情莫过于每天早晨起来看一眼我的博客网站了然而我等它等的不耐烦，尤其手机端，更加不能忍 hexo-next主题网站加载慢原因1：加载Google字体慢 解决方法：找到\themes\next\layout_partials\head\external-fonts.swig文件，将fonts.googleapis.com 改成 fonts.useso.com]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清平乐·清枫唱晚]]></title>
    <url>%2F2018%2F08%2F10%2F%E6%B8%85%E5%B9%B3%E4%B9%90%C2%B7%E6%B8%85%E6%9E%AB%E5%94%B1%E6%99%9A%2F</url>
    <content type="text"><![CDATA[今晚读宋词，读着读着就忍不住了，不知道为啥，每次诗词意境的主体都是男性23333 清平乐&lt;/center&gt; 清枫唱晚，小楼把酒酣。满城灯火无人唤，夜夜埙声散。 梦里佳人独倚，惊觉落叶凄凄。恁知平生情意，残阳夜盼归期。 分享下今晚让我手痒痒的词 **清平乐**(王安国) --- 留春不住，费尽莺儿语。满地残红宫锦污，昨夜南园风雨。 小怜初上琵琶，晓来思绕天涯。不肯画堂朱户，春风自在杨花。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宋词分享]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AE%8B%E8%AF%8D%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[分享几首昨天看到的喜欢的宋词 苏幕遮(范仲淹)&lt;/center&gt; 碧云天，黄叶地。秋色连波，波上寒烟翠。山映斜阳天接水，芳草无情，更在斜阳外。 黯乡魂，追旅思。夜夜除非，好梦留人睡。明月高楼休独倚，酒入愁肠，化作相思泪。 清平乐(晏殊)&lt;/center&gt; 红笺小字，说尽平生意，鸿雁在云鱼在水，惆怅此情难寄。 斜阳独倚西楼，遥山恰对帘钩。人面不知何处，绿波依旧东流。 蝶恋花(欧阳修)&lt;/center&gt; 庭院深深深几许？杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。 雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F10%2Fleetcode-string-easy-4-1%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是521,824,20,520附stack string容器用法总结 总结收获 stack用法：empty() pop() push() size() top() string用法：append() insert() substr() append连接 123456basic_string &amp;append( const basic_string &amp;str );//在字符串的末尾添加str,basic_string &amp;append( const char *str );basic_string &amp;append( const basic_string &amp;str, size_type index, size_type len );//在字符串的末尾添加str的子串,子串以index索引开始，长度为lenbasic_string &amp;append( const char *str, size_type num );//在字符串的末尾添加str中的num个字符basic_string &amp;append( size_type num, char ch );//在字符串的末尾添加num个字符chbasic_string &amp;append( input_iterator start, input_iterator end );//在字符串的末尾添加以迭代器start和end表示的字符序列 insert插入 12345678iterator insert( iterator i, const char &amp;ch );basic_string &amp;insert( size_type index, const basic_string &amp;str );basic_string &amp;insert( size_type index, const char *str );basic_string &amp;insert( size_type index1, const basic_string &amp;str, size_type index2, size_type num );basic_string &amp;insert( size_type index, const char *str, size_type num );basic_string &amp;insert( size_type index, size_type num, char ch );void insert( iterator i, size_type num, const char &amp;ch );void insert( iterator i, iterator start, iterator end ); substr 1basic_string substr( size_type index, size_type num = npos );//substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串。 assign赋值 12345basic_string &amp;assign( const basic_string &amp;str );basic_string &amp;assign( const char *str );basic_string &amp;assign( const char *str, size_type num );basic_string &amp;assign( const basic_string &amp;str, size_type index, size_type len );basic_string &amp;assign( size_type num, char ch ); compare小于零 this &lt; str 1234567int compare( const basic_string &amp;str );//比较自己和strint compare( const char *str );int compare( size_type index, size_type length, const basic_string &amp;str );//比较自己的子串和str,子串以index索引开始，长度为lengthint compare( size_type index, size_type length, const basic_string &amp;str, size_type index2,size_type length2 );//比较自己的子串和str的子串，其中index2和length2引用str，index和length引用自己int compare( size_type index, size_type length, const char *str, size_type length2 );//比较自己的子串和str的子串，其中str的子串以索引0开始，长度为length2，自己的子串以index开始，长度为length copy 1size_type copy( char *str, size_type num, size_type index );//拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数 erase 123iterator erase( iterator pos );iterator erase( iterator start, iterator end );basic_string &amp;erase( size_type index = 0, size_type num = npos ); find 1234size_type find( const basic_string &amp;str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找）size_type find( const char *str, size_type index );size_type find( const char *str, size_type index, size_type length );size_type find( char ch, size_type index ); at begin end empty用法同vector容器 题目：521. Longest Uncommon Subsequence I描述：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.例子：12345Input: &quot;aba&quot;, &quot;cdc&quot;Output: 3Explanation: The longest uncommon subsequence is &quot;aba&quot; (or &quot;cdc&quot;), because &quot;aba&quot; is a subsequence of &quot;aba&quot;, but not a subsequence of any other strings in the group of two strings. 代码：1234567int Solution521::findLUSlength(string a, string b)&#123; if (a == b)return -1; else if (a.size() == b.size())return a.size(); else return max(a.size(), b.size());&#125; 思路： 如果两个字符串相等不可能有不相同子序列 如果两个字符串不相等，但是长度相同，则最长的不同子序列就是二者任意一个 上述条件都不符合，则最长的字符串就是最长的不同子序列 题目：824. Goat Latin描述：A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. 例子：12Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot; 代码： 12345678910111213141516171819202122232425262728string Solution824::toGoatLatin(string S)&#123; int j = 0;//当前词开始下标 int k = 1;//记录第k个word unordered_set&lt;char&gt; vowel = &#123; 'a','e','i','o','u','A','E','I','O','U' &#125;; string t; for (int i = 0; i &lt; S.size(); ++i) &#123; if (S[i + 1] == ' ') &#123; if (vowel.find(S[j]) != vowel.end())//是元音 &#123; t.append(S.substr(j, i - j + 1)); &#125; else &#123; t.append(S.substr(j + 1, i - j)); t.append(S.substr(j, 1)); &#125; t.append("ma"); for (int a = 0; a &lt; k; a++)t.append("a"); t.append(" "); j = i + 2; ++k; &#125; &#125; return t;&#125; 收获： string::append() string::substr 题目：20. Valid Parentheses描述：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid.例子：1234Input: &quot;()&quot;Output: trueInput: &quot;([)]&quot;Output: false 代码： 123456789101112131415bool Solution20::isValid(string s)&#123; stack&lt;char&gt; t; for (char c : s) &#123; if (c == '(' || c == '[' || c == '&#123;') t.push(c); else &#123; if (t.empty() || (c == ')' &amp;&amp; t.top() != '(') || (c == ']' &amp;&amp; t.top() != '[') || (c == '&#125;' &amp;&amp; t.top() != '&#123;'))return false; else t.pop(); &#125; &#125; return t.empty();&#125; 收获： stack::push() stack::pop() stack::top() 多重判断条件时将特殊边界条件放在首位，比如t.empty() 题目：520. Detect Capital描述：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way.例子：12Input: &quot;FlaG&quot;Output: False 代码：1234567891011121314151617181920212223242526272829bool Solution520::detectCapitalUse(string word)&#123; //way 1 //int k = 0;//0--首字母大写 1--首字母小写 //int flag = 0;//0--首字母之外都是小写，1--首字母之外都是大写 //int len = word.size(); //for (int i = 0; i &lt; len; ++i) //&#123; // if (word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a' &amp;&amp; i == 0)k = 1; // else if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A' &amp;&amp; k == 1)return false;//首字母小写，中间出现了大写字母 // if (i == 1 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')flag = 1; // if (k == 0 &amp;&amp; i &gt; 1)//首字母大写 // &#123; // if ((flag == 1 &amp;&amp; word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a') || (flag == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A'))return false; // &#125; //&#125; //return true; //way 2 bool firstCapital = false;//首字母小写 int capital = 0;//大写字母个数 for (int i = 0; i &lt; word.size(); ++i) &#123; if (i == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')firstCapital = true; if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')++capital; if (capital &lt; i + 1 &amp;&amp; capital &gt;= 2)return false;//大写字母数目大于等于两个，却小于当前遍历过的字母 &#125; return (capital == 0 || (firstCapital &amp;&amp; capital == 1) || capital == word.size());&#125; 第二种方法的runtime优于第一种方法 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我还不会的markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%88%91%E8%BF%98%E4%B8%8D%E4%BC%9A%E7%9A%84markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[做个总结，少百度 文字加粗1**Cmd Markdown**是我们给出的答案 Cmd Markdown是我们给出的答案 引用12&gt; * 整理知识，学习笔记&gt; * 发布日记，杂文，所见所想 整理知识，学习笔记 发布日记，杂文，所见所想 图片1![图片](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533796313368&amp;di=60846b8d67a743b9d0ee45963a64f2db&amp;imgtype=0&amp;src=http%3A%2F%2Fc.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2Ff9198618367adab4b025268587d4b31c8601e47b.jpg) 链接1[AlisaBen](https://alisaben.github.io) AlisaBen 段落内嵌入代码1`print()` print() 分割线1------ 待办事项1234- [ ] 强化学习- [ ] 读书- [x] 完善博客网站- [x] 画画 [ ] 强化学习 [ ] 读书 [x] 完善博客网站 [x] 画画 代码高亮1var a:Int = 1 删除线1~~删除~~ 删除 表格12345| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \$1600 | 5 || 手机 | \$12 | 12 || 管线 | \$1 | 234 | 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F09%2Fleetcode-string-easy-4%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是344，557，657，804 总结收获 unordered_map,unordered_set,map和set的区别：unordered_map存储机制是哈希表，即unordered_map内部元素是无序的。map是红黑树，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。unordered_set基于哈希表，是无序的。set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。 在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。（外部引用者更为合适） set容器的insert操作不需要提前判定元素存在，如下图： vector和string容器实现了swap方法，内置swap进行了优化，优于自己写的简单交换 暂时不明白string s = &quot;&quot;;和string s;的区别，希望大佬可以指点 题目：344. Reverse String描述：Write a function that takes a string as input and returns the string reversed.例子：12Input: &quot;hello&quot;Output: &quot;olleh&quot; 代码：12345678910string Solution344::reverseString(string s)&#123; int len = s.size(); if (len &lt; 2)return s; for (int i = 0; i &lt; len / 2; i++) &#123; swap(s[i], s[len - i - 1]); &#125; return s;&#125; swap优于自己写的交换 题目:557. Reverse Words in a String III描述：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.例子：12Input: &quot;Let&apos;s take LeetCode contest&quot;Output: &quot;s&apos;teL ekat edoCteeL tsetnoc&quot; 代码：1234567891011121314151617181920string Solution557::reverseWords(string s)&#123; int len = s.size(); int j = 0; for (int i = 0; i &lt; len; i++) &#123; if (i + 1 == len || s[i + 1] == ' ') &#123; int n = i - j + 1; int x = j; while (j &lt;= x + n /2 - 1) &#123; swap(s[j], s[i +x - j]); ++j; &#125; j = i + 2; &#125; &#125; return s;&#125; 在这道题中踩过的坑： 边界条件:i指向最后一个元素的情况 while循环中j不断变化，循环边界需要不变边界 swap交换时元素的下标计算 题目：657. Judge Route Circle描述：Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.例子：1234Input: &quot;UD&quot;Output: trueInput: &quot;LL&quot;Output: false 代码：12345678910111213141516bool Solution657::judgeCircle(string moves)&#123; vector&lt;int&gt; m(4);//L,R,U,D for (auto &amp;c : moves) &#123; if (c == 'L')m[0]++; else if (c == 'R')m[1]++; else if (c == 'U')m[2]++; else m[3]++; &#125; return (m[0] == m[1] &amp;&amp; m[2] == m[3]); //unordered_map&lt;char, int&gt;com; //for (auto &amp;c : moves)com[c]++; //return com['L'] == com['R'] &amp;&amp; com['U'] == com['D'];&#125; 尝试了一下注释掉的方法二runtime很差劲，可能是因为查找比较费时间 题目：804. Unique Morse Code Words描述：International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.For convenience, the full table for the 26 letters of the English alphabet is given below:1[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 例子：1234567891011Example:Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]Output: 2Explanation: The transformation of each word is:&quot;gin&quot; -&gt; &quot;--...-.&quot;&quot;zen&quot; -&gt; &quot;--...-.&quot;&quot;gig&quot; -&gt; &quot;--...--.&quot;&quot;msg&quot; -&gt; &quot;--...--.&quot;There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;. Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 代码：12345678910111213141516171819202122232425262728293031int Solution804::uniqueMorseRepresentations(vector&lt;string&gt;&amp; words)&#123; //int len = words.size(); //if (len &lt; 2)return len; //vector&lt;string&gt; map = &#123; ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.." &#125;; //set&lt;string&gt; compare; //for (string s : words) //&#123; // string temp = ""; // for (char c : s) // &#123; // temp += map[c - 'a']; // &#125; // //if (compare.find(temp) == compare.end()) // compare.insert(temp); //&#125; //return compare.size(); unordered_set&lt;string&gt; compare; for (string &amp;s : words) &#123; string temp; for (char &amp;c : s) &#123; temp += map[c - 'a']; &#125; //if (compare.find(temp) == compare.end()) compare.insert(temp); &#125; return compare.size();&#125; 注释掉的代码是我自己写的，下面的代码是看了runtime比较好的答案，经过对比多次提交比较得到一下几个猜想，有待验证： unordered_set优于set public定义compare优于函数内定义 compare前加上const关键字优于不加 for循环加上&amp;优于不加 set执行insert不需要提前判断集合中是否有该元素 temp不初始化不会报错，且优于初始化 结束更多内容请浏览我的csdn：小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩铅画2-向日葵]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%BD%A9%E9%93%85%E7%94%BB2-%E5%90%91%E6%97%A5%E8%91%B5%2F</url>
    <content type="text"><![CDATA[半年过去了，前段时间翻到了年初的朋友圈看下今年的flag：“2018no flag,多读书多看报，多点佛系情怀，多点珍惜，多点爱，还有就是培养一个新爱好”。这么简单的计划差点都被我搞砸，还有还有半年为期，那就爱好捡起来吧。 上次画画是几个月前看了几集《永恒的紫罗兰花园》，就画了里面邮递员的一个剪影；再上次是高考结束学习了半个月的素描，就是练习排线、投影、静物，画些苹果鸭梨啥的；再上次应该就是初中的时候，凭借一副人像拿了学校画展的二等奖，平时看课外书的时候画些书中的人物剪影。 从小我对色彩的掌握就比较弱，但是很有耐性，选择彩铅也没有什么特别的考究，只是彩铅的画法和素描很像，然后彩铅毁画不太容易，所以就开始了我的新爱好培养。 首先是先用自动铅笔构图，起始在构图的时候自己很小心，尽量不让比例失调，但是因为最初选定的落笔的地方选择了近景叶子而不是向日葵的根部，导致最后向日葵的底部比例有点失调，就把叶子全擦掉重新画的，所以定型原点很重要！还有一点就是在构图的时候有些高光明显的地方也画了边界，可以避免上色的时候不小心画错。 花瓣上色， 第一次尝试这种色调比较少的画，而且我的彩铅只有36色，担心自己的水平画不出来效果，所以一个花瓣一个花瓣开始画，没有采用大范围铺色调的方式，这也可能是我画得慢得原因吧。先用404打底，再铺一层407，留出高光得位置，再阴影得地方加深409，觉得色彩不够可以反复排线，开始排线得时候尽量轻，不然后面不好上色，在阴影比较重得地方适当加入487和478，有些黄得发红得地方加入414和416。 叶子上色，画花瓣得时候很累，画完花瓣差不多已经5个小时左右了，画叶子得时候才知道色彩对我得限制有多大，我的绿色色系只有5只，很难画出向日葵那种深绿得感觉，所以加了很多得480和499，先用463打底，浅涂，然后459加深，可以根据排线来自动调节每种颜色每个位置得深浅，这样能够显出立体得感觉，在阴影较重得地方用459和499、480反复图，绿里透着黑，黑里透着绿。 这是最后的图，不太满意的地方是花芯和近景的叶子，因为是对着图片临摹，没有近距离观察向日葵花芯的小花瓣的形状，不太会画这里，而且画到这里的时候我差不多已经坐着画了10个小时左右，有点累了画的比较随意，还有就是近景叶子我没有太看明白图片中的叶子是怎样分布的，根据阳光照射的向日葵的花瓣的高光分布没有推测出近景叶子是怎样达到花瓣的效果，所以感觉近景叶子的高光阴影有很大的问题，更多的内容请不吝指教~ 还有比较细节的地方是，在勾勒一些颜色交叉边缘阴影时根据阴影映射的颜色来压会比较自然，最后，这幅图用到的颜色：有些是画画中随性加的颜色，没有具体描述。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第18章 高级类型]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC18%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[18.1 单例类型 在下面的例子中book不能调用addChapter方法，因为setTitle方法返回的是this，Scala自动推断类型为Document。1234567891011121314151617class Document&#123; def setTitle(title:String) = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle(&quot;whatever&quot;).setAuthor(&quot;cay&quot;)class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle(&quot;scala&quot;) 修改方法如下：显式声明setTitle方法的返回类型是this.type 1234567891011121314151617class Document&#123; def setTitle(title:String):this.type = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle(&quot;whatever&quot;).setAuthor(&quot;cay&quot;)class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle(&quot;scala&quot;).addChapter(&quot;&quot;) 1234567object Title//单例对象class Document&#123; private var useNextArgAas:Any = null def set(obj:Title.type ):this.type = &#123;useNextArgAas = obj;this&#125; def to(arg:String) = if(useNextArgAas == Title) println(arg)&#125;book.set(Title).to(&quot;scala&quot;) 18.2 类型投影注意下一段代码中的NetWork#Member操作，说明在NetWork中共享Member类 12345678910111213141516class NetWork&#123; class Member(val name:String)&#123; val contacts = new ArrayBuffer[NetWork#Member] &#125; private val members = new ArrayBuffer[Member]() def join(name:String) = &#123; val m = new Member(name) members += m m &#125;&#125;val chatter:NetWork = new NetWorkval myFace:NetWork = new NetWorkval fred :chatter.Member= chatter.join(&quot;fred&quot;)val barney :myFace.Member= myFace.join(&quot;barney&quot;)fred.contacts += barney 18.4 类型别名类型别名必须出现在类或者对象中，不能出现在Scala文件的顶层123type Index = mutable.HashMap[String,(Int,Int)]val a :Index = new Index()a.put(&quot;a&quot;,(1,2)) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第17章-类型参数]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC17%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[17.1 泛型类 12345class Pair[T,S](val first:T,val second:S)&#123; def printf() = println(first,second)&#125;val p = new Pair(42,&quot;string&quot;)p.printf() 17.2 泛型函数12def getMiddle[T](a:Array[T]) = a.length / 2println(getMiddle(Array(4,&quot;56&quot;))) 17.3 类型变量界定12345class Pair[T &lt;: Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair(&quot;23&quot;,&quot;4&quot;)).smaller) 如果不在泛型中加入&lt;: Comparable[T]，则就不知道first是否有compareTo方法，所以添加一个上界T 《： Comparable[T] 但是在类型为Int的时候出现报错，在17.4节中介绍 12345class Pair[T](val first:T,val second:T)&#123; def printf() = println(first,second) def replaceFirst[R &gt;: T](newFirst:R) = new Pair[R](newFirst,second)&#125;(new Pair(&quot;23&quot;,&quot;4&quot;)).replaceFirst(0).printf() 17.4 视图界定在上一节中Int类型出现报错是因为Int不是Comparable[Int]的子类。不过RichInt实现了Comparable[Int],同时还有一个从Int到RichInt的隐式转换。解决方法是视图界定12345class Pair[T &lt;% Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair[Int](3,4)).smaller) &lt;%关系将T被隐式转换成Comparable[T] 用Ordered特质会更好，因为在Comparable的基础上提供了关系操作符1234class Pair[T &lt;% Ordered[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first &lt; second) first else second&#125; 17.5 上下文界定视图界定T &lt;% V要求必须存在一个从T到V的隐式转换。上下文界定的形式是T:M。要求必须存在一个类型为M[T]的隐式值，如1class Pair[T:Ordering] 要求必须存在一个类型为Ordering[T]的隐式值。当声明一个使用隐式值的方法时，需要添加一个隐式参数,比如ord 123class Pair[T:Ordering](val first:T,val second:T)&#123; def smaller(implicit ord:Ordering[T]) = if(ord.compare(first,second) &lt; 0) first else second&#125; 17.11 对象不能泛型不能给对象添加类型参数，比如可变列表 更多内容请见我的csdn:小可爱的博客]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-sort-easy-over]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-sort-easy-over%2F</url>
    <content type="text"><![CDATA[题目列表： 349 350 242 题目349：Intersection of Two Arrays描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order. 代码： 1234567891011121314vector&lt;int&gt; Solution349::intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; set&lt;int&gt;nums1_plus, nums2_plus; nums1_plus.insert(nums1.begin(), nums1.end());//因为集合是不区分元素位置的 nums2_plus.insert(nums2.begin(), nums2.end()); vector&lt;int&gt; res; int len1 = nums1_plus.size(); for (int x : nums1_plus) &#123; if (nums2_plus.find(x) != nums2_plus.end())res.push_back(x); &#125; return res;&#125; 题目350：Intersection of Two Arrays II描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.代码：123456789101112vector&lt;int&gt; Solution350::intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; unordered_map&lt;int, int&gt;nums1_plus, nums2_plus; for (int x : nums1)nums1_plus[x]++; for (int x : nums2)nums2_plus[x]++; vector&lt;int&gt; res; for (auto x : nums1_plus) &#123; if (nums2_plus.find(x.first) != nums2_plus.end())res.insert(res.end(), min(x.second, nums2_plus[x.first]), x.first); &#125; return res;&#125; 题目242： Valid Anagram描述：Given two strings s and t , write a function to determine if t is an anagram of s.例子： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false Note:You may assume the string contains only lowercase alphabets.代码：1234567891011121314151617181920212223242526272829bool Solution242::isAnagram(string s, string t)&#123; //way 1 //if (s.size() != t.size())return false; //unordered_map&lt;char, int&gt; s_plus, t_plus; //for (char x : s)s_plus[x]++; //for (char x : t)t_plus[x]++; //for (auto x : s_plus) //&#123; // if (t_plus.find(x.first) != t_plus.end()) // &#123; // if (x.second != t_plus[x.first]) return false; // &#125; // else // return false; //&#125; //return true; //way 2 if (s.size() != t.size()) return false; vector&lt;int&gt; flag(26);//将26个小写字母映射到对应数组下标，元素为每个字母出现的次数，初始值为0 for (char x : s) flag[x - &apos;a&apos;]++;//计算s字符串中每个字母出现的次数 for (char x : t) &#123; flag[x - &apos;a&apos;]--; if (flag[x - &apos;a&apos;] &lt; 0)return false;//如果两个字符串等长，且不是变换顺序的话，t中一定存在某个字母数大于s &#125; return true;&#125; 在题目242中，第二种方法的runtime优于第一种方法，在非变换顺序的字符串中可以在遍历结束之前结束。 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骗子]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%AA%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我是一个骗子戴着虚伪的面具月亮与我高歌清风为我吹嘘谈笑风生心底住着秘密黑夜降临我来到另一个世界忧伤浸染自说着寂寞的秋的清愁]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第16章 XML处理]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC16%E7%AB%A0-XML%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这是一篇《快学scala》的读书笔记，需要具备Scala语言的基础，欢迎读者与我一起探讨，或者教我新知识呀~ 16.1 XML字面量Scala对xml有内建支持，直接用xml代码就行1234import scala.xml.Elemimport scala.xml.NodeBufferval doc:Elem = &lt;html&gt;&lt;head&gt;&lt;title&gt;Fred&apos;s&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;val item:NodeBuffer = &lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;wilma&lt;/li&gt; 16.2 XML节点Node类是所有XML节点类型的祖先，两个最重要的子类是Text和Elem。用child方法遍历父节点下面的每一个子节点 123val ls:Elem = &lt;a herf=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child) println(x) 输出结果： 1234the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language 代码：123val ls:Elem = &lt;a herf=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child if !x.child.isEmpty) println(x.child) 输出结果：12ArrayBuffer(&lt;li&gt;hello&lt;/li&gt;, scala)ArrayBuffer(yoyo) 通过变成的方式构建节点序列，可以使用NodeBuffer,是ArrayBuffer[Node]的子类，可以被隐式转换为NodeSeq，转换之后就不能再继续修改它，因为xml节点序列是不可变的 12345import scala.xml.&#123;Node, NodeSeq&#125;val items = new NodeBufferitems += &lt;li&gt;Fred&lt;/li&gt;items += &lt;li&gt;Wilma&lt;/li&gt;val nodes:NodeSeq = items 16.3 元素属性要处理某个元素的属性键和值，可以使用attributes属性,返回Option类型的节点序列1234val ls:Elem = &lt;a href=&quot;www.baidu.com&quot;&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;val url: scala.Seq[Node] = ls.attributes(&quot;href&quot;)val url1:String= ls.attributes(&quot;href&quot;).textprintln(url1) 输出结果：www.baidu.com通过调用 text方法返回String类型结果,也可以通过下面的方法避免没有这个属性返回null的结果，如果没有返回空12val url2 = ls.attributes.get(&quot;alt&quot;).getOrElse(Text(&quot;&quot;)) println(url2) 遍历节点的所有属性：12345val elem1 = &lt;p class=&quot;nihao&quot; type=&quot;wawa&quot;&gt;&lt;/p&gt;for(attr &lt;- elem1.attributes) println(attr.key,attr.value.text)val map:Map[String,String] = elem1.attributes.asAttrMapprintln(map) 两种方式都可以遍历节点的所有属性，第一种方式的attr类型是MetaData，第二种方式返回的是键值对的map 16.4 内嵌表达式可以在xml字面量中包含Scala的代码块 123val items = List(2,3,5)val elem = &lt;ul&gt;&#123;for(i &lt;- items)yield &lt;li&gt;&#123;i&#125;&lt;/li&gt;&#125;&lt;/ul&gt;println(elem) 16.5 在属性中使用表达式可以用Scala表达式来计算属性值 123456val e = &lt;a id=&#123;new Atom[Int](1)&#125;&gt;&lt;/a&gt;println(e.attributes(&quot;id&quot;).text)val description = &quot;TOD&quot;val q = &lt;img alt=&#123;if(description == &quot;TODO&quot;) null else description&#125;&gt;yolo&lt;/img&gt;println(q.attributes.get(&quot;alt&quot;).getOrElse(Text(&quot;&quot;))) 16.8 模式匹配可以在模式匹配表达式中使用xml字面量 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println(&quot;img&quot;) case &lt;li&gt;&#123;v&#125;&lt;/li&gt; =&gt; println(v) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println(&quot;lala&quot;) case _ =&gt; println(&quot;&quot;)&#125;) 可以用下面的方式匹配文本12&lt;li&gt;&#123;Text(v)&#125;&lt;/li&gt; =&gt; v&lt;li&gt;v&lt;/li&gt; =&gt; v.text XML模式不能有属性，如果要匹配属性，需要用守卫 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li class=&quot;name&quot;&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println(&quot;img&quot;) case n @ &lt;li&gt;&#123;_&#125;&lt;/li&gt; if (n.attributes(&quot;class&quot;).text == &quot;name&quot;)=&gt; println(n) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println(&quot;lala&quot;) case _ =&gt; println(&quot;&quot;)&#125;) 16.9 修改元素和属性xml节点和节点序列是不可变的，如果要编辑一个节点，需要创建一个拷贝123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = &quot;ol&quot;)println(list2) 结果输出：FredWilma 新旧两个列表的后代是共享的，要添加一个后代，可以像下面这样调用copy123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = &quot;ol&quot;,child = list.child ++ &lt;li&gt;another&lt;/li&gt;)println(list2) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第15章 注解]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC15%E7%AB%A0-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[15.1 什么是注解 注解：插入到代码中以便有工具可以对他们进行处理的标签，工具可以在代码级别运作，也可以被编译器加入了注解信息的类文件 15.2 什么可以被注解可以为类、方法、字段、局部变量和参数添加注解12345@Entity class Credentials@Test def testSomeFeature()&#123;&#125;@BeanProperty var username = _def doSomething(@NotNull message:String)&#123;&#125;@BeanProperty @Id var username = _ 在给主构造器添加注解时，需要将注解放置在构造器之前，并加上一对圆括号 1class Credentials @Inject()&#123;var username:String,var password:String&#125; 可以为表达式添加注解，需要在表达式后加上冒号1(myMap.get(key):@unchecked) match &#123;...&#125; 还可以为类型参数添加注解：1class MyContainer[@specialized T] 针对实际类型的注解应放在类型名称之后1String @cps[Unit] 15.3 注解参数Java注解可以有带名参数，如果参数名是value，名称可以直接略去，如果注解不带参数，圆括号可以略去注解的参数类型只能是： 数值型的字面量 字符串 类字面量 Java枚举 其他注解 上述类型的数组 15.4 注解实现本节主要看下注解类是怎样实现的 注解必须扩展Annotation特质。 1class unchecked extends annotation.Annotation 注解的作用是描述那些被注解的表达式、变量、字段、方法或类型1def check(@NotNull password:String) = &#123;&#125; 好了，注解看到这里我放弃了，并看不懂……]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因吹斯听thing:我的博客网站]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9B%A0%E5%90%B9%E6%96%AF%E5%90%ACthing-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[之前就想过自己搭建一个博客网站，因为自己有记东西的习惯，简书+csdn+有道云，挺麻烦的，今天偶然知道了hexo，感觉这个东西很好，就尝试5分钟搭建，但是实际上不止5分钟呀，中间也遇到了问题，现把我的搭建过程做个记录。 原文链接：5分钟搭建免费个人博客 安装Hexo此步安装命令用的是下面的： 1npm install -g hexo-cli 安装成功之后,会提示hexo的安装目录。我在D盘下新建了Hexo文件夹，执行 1hexo init D:\Hexo 进入到该路径下，初始化网站存储的文件1hexo init username.github.io 根据链接的配置要求进行更改，进入到该文件夹下面1cd username.github.io 执行1hexo s 测试启动可以运行 注意事项： hexo的安装命令有很多，我第一遍安装失败了，遇到了hexo不是内部或外部命令 hexo的文档命名和内容格式 有一定的要求，按照下面的语法新建文档，再编辑新内容1hexo new &quot;doc name&quot; 总结今天学习到的命令 123hexo shexo new &quot;doc name&quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 要好好学习markdown的语法喽~]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学scala》学习笔记--第14章 模式匹配和样例类]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC14%E7%AB%A0%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[此篇文章针对有一定Scala基础的读者 14.1 更好的switch 123456val ch: Char = '*'ch match &#123; case '+' =&gt; println("加法") case '*' =&gt; println("乘法") case _ =&gt; println("木有")&#125; match是一个表达式，而不是语句，会有返回值 1234567val ch: Char = &apos;*&apos;val x:Int = ch match &#123; case &apos;+&apos; =&gt; 0 case &apos;*&apos; =&gt; 1 case _ =&gt; 2&#125;println(x) 14.2 守卫守卫可以是任何布尔条件，在下面的例子中，只有在守卫模式不能匹配的情况下才执行所有模式匹配 123456789val ch:Char = 3var sign:Int = 0ch match &#123; case &apos;+&apos; =&gt; println(&quot;++++&quot;) case &apos;*&apos; =&gt; println(&quot;====&quot;) case _ if ch &gt;= 0 &amp;&amp; ch &lt;= 9 =&gt; sign = ch case _ =&gt; println(&quot;---&quot;)&#125;println(sign) 14.3 模式中的变量case _ 是这种特性的特殊情况，变量名是 _ 12345678910val c: Char = &apos;+&apos;val ch:Char = 9var sign:Int = 0ch match &#123; case &apos;+&apos; =&gt; println(&quot;++++&quot;) case &apos;*&apos; =&gt; println(&quot;====&quot;) case c if c &gt;= 0 &amp;&amp; c &lt;= 9 =&gt; sign = c case _ =&gt; println(&quot;---&quot;)&#125;println(sign) 变量必须以小写字母开头 如果有一个小写字母开头的常量，则需要将它包在反引号中。 14.4 类型模式匹配列表中的每一个元素的类型，将每一个元素映射成 =&gt; 后面的 string 类型 1234567val ls = List(1,3,4,&quot;one&quot;,&quot;two&quot;,4.5)val l = ls.map(_ match &#123; case x:Int =&gt; &quot;int x:&quot; + x case s:String =&gt; &quot;string s:&quot; + s case _ =&gt; &quot;other&quot;&#125;)l.foreach(println) 14.5 匹配组、列表和元组要匹配数组的内容，可以在模式中使用Array表达式, 1234567val arr1 = Array(Array(0),Array(3,4),Array(0,4,6),Array(&quot;fad&quot;,&quot;fff&quot;))arr1.map(_ match &#123; case Array(0) =&gt; println(0) case Array(x,y) =&gt; println(x,y) case Array(0,_*) =&gt; println(&quot;...&quot;)//_*符号匹配数组中余下的内容 case _ =&gt; println(&quot;something&quot;)&#125;) 匹配列表中的元素 12345678val ls = List(List(0),List(3,4),List(0,4,5),List(&quot;fa&quot;,&quot;aaa&quot;,&quot;tttt&quot;))ls.map(_ match &#123; case 0::Nil =&gt; println(0) case x :: y :: Nil =&gt; println(x,y) case 0 :: tail =&gt; println(tail.foreach(println)) case x :: tail =&gt; println(&quot;====&quot;) case _ =&gt; println(&quot;something&quot;)&#125;) 匹配元组 123456val ls = List((0,4),(&quot;fa&quot;,0),(3,4))ls.map(_ match &#123; case (0,_) =&gt; println(0) case (x,y) =&gt; println(x,y) case _ =&gt; println(&quot;something&quot;)&#125;) 14.6 提取器前一节中匹配数组、列表和元素的功能是依靠提取器实现的 ==提取器机制==：带有从对象中提取值得unapply和unapplySeq方法得对象。unapply提取固定数量得对象，而unapplySeq提取得是一个序列 1Array.unapplySeq(arr) 产出一个序列的值。 14.8 for表达式中的模式123val ls = List((1,2),(3,4),(4,5))for ((k,v) &lt;- ls if k % 2 == 1) println(k,v) 14.9 样例类可以用模式匹配来匹配样例类，并将属性值绑定到变量 12345678910case class Dollar(value:Double)case class Currency(value:Double,unit:String)case object Yuanval ls = List(Dollar(2.3),Currency(4.5,&quot;10&quot;),Yuan)ls.map(_ match &#123; case Dollar(v) =&gt; println(s&quot;Dollar:$v&quot;) case Currency(_,u) =&gt; println(s&quot;got $u&quot;) case Yuan =&gt; println(&quot;lalala&quot;) case _ =&gt; println(&quot;----&quot;)&#125;) 样例类实例使用(),样例对象不适用圆括号 ==声明样例类的时候有如下几件事自动发生：== 构造器中的每一个参数都成为val，除非被显式地声明为var 在伴生对象中提供apply方法，可以不用new关键字就能构造出相应的对象，比如Dollar(2.3) 提供unapply方法让模式匹配可以工作 将生成toString,equals,copy方法，除非显式给出定义 14.10 copy方法和带名参数copy方法创建一个与现有对象值相同的新对象，可以用带名参数修改某些属性 1234val amt = Currency(34.2,&quot;RUR&quot;)val price = amt.copy()val price1 = amt.copy(value = 13)val price2 = amt.copy(unit = &quot;CHF&quot;) 14.11 case语句中的中置表示法如果unapply方法产出一个对偶，可以在case语句中使用中置表示法，19章将会看到将解析结果组合在一起的~样例类: 1result match &#123;case p ~ q =&gt; ...&#125; //等同于case ~(p,q) 如果操作符以冒号结尾，则他是从右向左结合的 中置表示法可以用于任何返回对偶的unapply方法： 1234567case object +: &#123; def unapply[T](input: List[T]):Option[(T,List[T])] = if(input.isEmpty) None else Some((input.head,input.tail))&#125;1+:7+:2+:Nil match &#123; case first +: second +: rest =&gt; println(first + second + rest.length)&#125; 14.12 匹配嵌套结构三个样例类继承Item抽象类，Bundle和Boolean类嵌套Article和Bundle样例类，可以用@表示法将嵌套的值绑定到变量 12345678910111213abstract class Itemcase class Article(desc:String,price:Double) extends Item//继承同一个抽象类case class Bundle(desc:String,discount:Double,item:Item) extends Itemval peak = Bundle(&quot;Father&apos;s Day is special&quot;,20.0,Article(&quot;scala is nice&quot;,45.5))case class Boolean(desc:String,dis:Double,item:Item*)//Item抽象类列表val amt = Boolean(&quot;great&quot;,23.3,Bundle(&quot;nice&quot;,45.4,Article(&quot;wonderful&quot;,45.4)),Article(&quot;scala is nice&quot;,45.5))val ls = List(peak,amt)ls.map(_ match &#123; case Bundle(_,_,Article(desc,price)) =&gt; println(s&quot;bundle $&#123;desc&#125;:$&#123;price&#125;&quot;) case Boolean(_,_,art @ Bundle(_,_,_),rest @ _*) =&gt; println(s&quot;boolean $&#123;art.desc&#125;:$&#123;art.discount&#125;,$&#123;rest.head&#125;&quot;) case Boolean(_,_,art @ Bundle(_,_,_),rest) =&gt; println(s&quot;boolean $&#123;art.desc&#125;&quot;)//匹配继承Item抽象类的元素只有两个 case _ =&gt; println(&quot;None&quot;)&#125;) 14.14 密封类当用样例类来做模式匹配的时候，想让编译器帮助确保已经列出了所有可能的选择，要达到这个目的，需要将样例类的通用超类声明为sealed 密封类的所有子类都必须在与该密封类相同的文件中定义。 如果某个类是密封的，那么在编译期所有子类就是可知的，因此==编译器可以检查模式语句的完整性==，让同一组样例类都扩展自某个密封的类或者特质是一个好的做法 12345678910sealed abstract class Amountcase class Red(bottom:Double) extends Amountcase object Green extends Amountcase object Gray extends Amountval color:Amount = Red(3.4)//需要显式声明color的类型，不然就会变成Redcolor match &#123; case Red(_) =&gt; println(&quot;red&quot;) case Green =&gt;println(&quot;green&quot;) case Gray =&gt; println(&quot;fad&quot;)&#125; 14.16 Option类型标准类库的Option类型用样例类来表示那种可能存在，也可能不存在的值。这比空字符串更加清晰，比null做法更加安全。 map类的get方法返回一个Option。如果对于给定的键没有对应的值，则get返回None，如果有值，该值包在Some中返回 请以不要直接使用get方法，返回None的情况可能会使程序死掉，尽量用getOrElse Option[+A]密封抽象类，Some和None继承Option类 14.17 偏函数被包括在花括号内的一组case语句是一个偏函数——==并非对所有输入值都有定义的函数==。它是PartialFunction[A,B]类的一个实例，该类有两个方法：apply方法从匹配到的模式计算函数值，而isDefinedAt方法在输入至少匹配其中一个模式时返回true 1234567val f:PartialFunction[Char,Int] = &#123; case &apos;+&apos; =&gt; 1 case &apos;-&apos; =&gt; -1&#125;println(f(&apos;+&apos;))//1//println(f(&apos;0&apos;))//errorprintln(f.isDefinedAt(&apos;0&apos;))//false]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远方]]></title>
    <url>%2F2018%2F07%2F25%2F%E8%BF%9C%E6%96%B9%2F</url>
    <content type="text"><![CDATA[期盼着远方思念着家乡我有一个姑娘我有一个姑娘舍不得家乡牵挂着远方]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我邮人缚苍龙]]></title>
    <url>%2F2014%2F12%2F01%2F%E7%9C%8B%E6%88%91%E9%82%AE%E4%BA%BA%E7%BC%9A%E8%8B%8D%E9%BE%99%2F</url>
    <content type="text"><![CDATA[芳草垂柳梧桐秀心唤帝都今重又汗洒昌平夜如昼群峰含笑送清秋戎装飒爽为北邮天地苍茫出浩宇看我邮人缚苍龙]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训1]]></title>
    <url>%2F2014%2F12%2F01%2F%E5%86%9B%E8%AE%AD1%2F</url>
    <content type="text"><![CDATA[黄沙不见烈日炎，碧云天，晓风怨。飒爽英姿，真是个超然。勿让云雨匆匆散，月夜下，欢歌连。闲适风景时时盼，舞翩翩，望不断。舟叶水源，回首泪涟涟。待到君心换我心，垂柳下，戎装前。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
