<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[宋词分享]]></title>
    <url>%2F2018%2F08%2F10%2F%E5%AE%8B%E8%AF%8D%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[分享几首昨天看到的喜欢的宋词 苏幕遮(范仲淹)— 碧云天，黄叶地。秋色连波，波上寒烟翠。山映斜阳天接水，芳草无情，更在斜阳外。黯乡魂，追旅思。夜夜除非，好梦留人睡。明月高楼休独倚，酒入愁肠，化作相思泪。 清平乐(晏殊)— 红笺小字，说尽平生意，鸿雁在云鱼在水，惆怅此情难寄。斜阳独倚西楼，遥山恰对帘钩。人面不知何处，绿波依旧东流。 蝶恋花(欧阳修)— 庭院深深深几许？杨柳堆烟，帘幕无重数。玉勒雕鞍游冶处，楼高不见章台路。雨横风狂三月暮，门掩黄昏，无计留春住。泪眼问花花不语，乱红飞过秋千去。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F10%2Fleetcode-string-easy-4-1%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是521,824,20,520附stack string容器用法总结 总结收获 stack用法：empty() pop() push() size() top() string用法：append() insert() substr() append连接 123456basic_string &amp;append( const basic_string &amp;str );//在字符串的末尾添加str,basic_string &amp;append( const char *str );basic_string &amp;append( const basic_string &amp;str, size_type index, size_type len );//在字符串的末尾添加str的子串,子串以index索引开始，长度为lenbasic_string &amp;append( const char *str, size_type num );//在字符串的末尾添加str中的num个字符basic_string &amp;append( size_type num, char ch );//在字符串的末尾添加num个字符chbasic_string &amp;append( input_iterator start, input_iterator end );//在字符串的末尾添加以迭代器start和end表示的字符序列 insert插入 12345678iterator insert( iterator i, const char &amp;ch );basic_string &amp;insert( size_type index, const basic_string &amp;str );basic_string &amp;insert( size_type index, const char *str );basic_string &amp;insert( size_type index1, const basic_string &amp;str, size_type index2, size_type num );basic_string &amp;insert( size_type index, const char *str, size_type num );basic_string &amp;insert( size_type index, size_type num, char ch );void insert( iterator i, size_type num, const char &amp;ch );void insert( iterator i, iterator start, iterator end ); substr 1basic_string substr( size_type index, size_type num = npos );//substr()返回本字符串的一个子串，从index开始，长num个字符。如果没有指定，将是默认值 string::npos。这样，substr()函数将简单的返回从index开始的剩余的字符串。 assign赋值 12345basic_string &amp;assign( const basic_string &amp;str );basic_string &amp;assign( const char *str );basic_string &amp;assign( const char *str, size_type num );basic_string &amp;assign( const basic_string &amp;str, size_type index, size_type len );basic_string &amp;assign( size_type num, char ch ); compare小于零 this &lt; str 1234567int compare( const basic_string &amp;str );//比较自己和strint compare( const char *str );int compare( size_type index, size_type length, const basic_string &amp;str );//比较自己的子串和str,子串以index索引开始，长度为lengthint compare( size_type index, size_type length, const basic_string &amp;str, size_type index2,size_type length2 );//比较自己的子串和str的子串，其中index2和length2引用str，index和length引用自己int compare( size_type index, size_type length, const char *str, size_type length2 );//比较自己的子串和str的子串，其中str的子串以索引0开始，长度为length2，自己的子串以index开始，长度为length copy 1size_type copy( char *str, size_type num, size_type index );//拷贝自己的num个字符到str中（从索引index开始）。返回值是拷贝的字符数 erase 123iterator erase( iterator pos );iterator erase( iterator start, iterator end );basic_string &amp;erase( size_type index = 0, size_type num = npos ); find 1234size_type find( const basic_string &amp;str, size_type index );//返回str在字符串中第一次出现的位置（从index开始查找）size_type find( const char *str, size_type index );size_type find( const char *str, size_type index, size_type length );size_type find( char ch, size_type index ); at begin end empty用法同vector容器 题目：521. Longest Uncommon Subsequence I描述：Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.例子：12345Input: "aba", "cdc"Output: 3Explanation: The longest uncommon subsequence is "aba" (or "cdc"), because "aba" is a subsequence of "aba", but not a subsequence of any other strings in the group of two strings. 代码：1234567int Solution521::findLUSlength(string a, string b)&#123; if (a == b)return -1; else if (a.size() == b.size())return a.size(); else return max(a.size(), b.size());&#125; 思路： 如果两个字符串相等不可能有不相同子序列 如果两个字符串不相等，但是长度相同，则最长的不同子序列就是二者任意一个 上述条件都不符合，则最长的字符串就是最长的不同子序列 题目：824. Goat Latin描述：A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only.We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. 例子：12Input: "I speak Goat Latin"Output: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa" 代码： 12345678910111213141516171819202122232425262728string Solution824::toGoatLatin(string S)&#123; int j = 0;//当前词开始下标 int k = 1;//记录第k个word unordered_set&lt;char&gt; vowel = &#123; 'a','e','i','o','u','A','E','I','O','U' &#125;; string t; for (int i = 0; i &lt; S.size(); ++i) &#123; if (S[i + 1] == ' ') &#123; if (vowel.find(S[j]) != vowel.end())//是元音 &#123; t.append(S.substr(j, i - j + 1)); &#125; else &#123; t.append(S.substr(j + 1, i - j)); t.append(S.substr(j, 1)); &#125; t.append("ma"); for (int a = 0; a &lt; k; a++)t.append("a"); t.append(" "); j = i + 2; ++k; &#125; &#125; return t;&#125; 收获： string::append() string::substr 题目：20. Valid Parentheses描述：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order.Note that an empty string is also considered valid.例子：1234Input: "()"Output: trueInput: "([)]"Output: false 代码： 123456789101112131415bool Solution20::isValid(string s)&#123; stack&lt;char&gt; t; for (char c : s) &#123; if (c == '(' || c == '[' || c == '&#123;') t.push(c); else &#123; if (t.empty() || (c == ')' &amp;&amp; t.top() != '(') || (c == ']' &amp;&amp; t.top() != '[') || (c == '&#125;' &amp;&amp; t.top() != '&#123;'))return false; else t.pop(); &#125; &#125; return t.empty();&#125; 收获： stack::push() stack::pop() stack::top() 多重判断条件时将特殊边界条件放在首位，比如t.empty() 题目：520. Detect Capital描述：Given a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”.Otherwise, we define that this word doesn’t use capitals in a right way.例子：12Input: "FlaG"Output: False 代码：1234567891011121314151617181920212223242526272829bool Solution520::detectCapitalUse(string word)&#123; //way 1 //int k = 0;//0--首字母大写 1--首字母小写 //int flag = 0;//0--首字母之外都是小写，1--首字母之外都是大写 //int len = word.size(); //for (int i = 0; i &lt; len; ++i) //&#123; // if (word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a' &amp;&amp; i == 0)k = 1; // else if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A' &amp;&amp; k == 1)return false;//首字母小写，中间出现了大写字母 // if (i == 1 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')flag = 1; // if (k == 0 &amp;&amp; i &gt; 1)//首字母大写 // &#123; // if ((flag == 1 &amp;&amp; word[i] &lt;= 'z' &amp;&amp; word[i] &gt;= 'a') || (flag == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A'))return false; // &#125; //&#125; //return true; //way 2 bool firstCapital = false;//首字母小写 int capital = 0;//大写字母个数 for (int i = 0; i &lt; word.size(); ++i) &#123; if (i == 0 &amp;&amp; word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')firstCapital = true; if (word[i] &lt;= 'Z' &amp;&amp; word[i] &gt;= 'A')++capital; if (capital &lt; i + 1 &amp;&amp; capital &gt;= 2)return false;//大写字母数目大于等于两个，却小于当前遍历过的字母 &#125; return (capital == 0 || (firstCapital &amp;&amp; capital == 1) || capital == word.size());&#125; 第二种方法的runtime优于第一种方法 结束更多内容请浏览我的csdn：小可爱的博客源码请见我的GitHub：AlisaBen]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我还不会的markdown语法]]></title>
    <url>%2F2018%2F08%2F09%2F%E6%88%91%E8%BF%98%E4%B8%8D%E4%BC%9A%E7%9A%84markdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[做个总结，少百度 文字加粗1**Cmd Markdown**是我们给出的答案 Cmd Markdown是我们给出的答案 引用12&gt; * 整理知识，学习笔记&gt; * 发布日记，杂文，所见所想 整理知识，学习笔记 发布日记，杂文，所见所想 图片1![图片](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1533796313368&amp;di=60846b8d67a743b9d0ee45963a64f2db&amp;imgtype=0&amp;src=http%3A%2F%2Fc.hiphotos.baidu.com%2Fimage%2Fpic%2Fitem%2Ff9198618367adab4b025268587d4b31c8601e47b.jpg) 链接1[AlisaBen](https://alisaben.github.io) AlisaBen 段落内嵌入代码1`print()` print() 分割线1------ 待办事项1234- [ ] 强化学习- [ ] 读书- [x] 完善博客网站- [x] 画画 强化学习 读书 完善博客网站 画画 代码高亮1var a:Int = 1 删除线1~~删除~~ 删除 表格12345| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \$1600 | 5 || 手机 | \$12 | 12 || 管线 | \$1 | 234 | 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-string-easy-4]]></title>
    <url>%2F2018%2F08%2F09%2Fleetcode-string-easy-4%2F</url>
    <content type="text"><![CDATA[每天坚持写几道leetcode,希望几个月后我就不再是小白今天的题目是344，557，657，804 总结收获 unordered_map,unordered_set,map和set的区别：unordered_map存储机制是哈希表，即unordered_map内部元素是无序的。map是红黑树，map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。unordered_set基于哈希表，是无序的。set实现了红黑树的平衡二叉检索树的数据结构，插入元素时，它会自动调整二叉树的排列，把元素放到适当的位置，以保证每个子树根节点键值大于左子树所有节点的键值，小于右子树所有节点的键值；另外，还得保证根节点左子树的高度与右子树高度相等。平衡二叉检索树使用中序遍历算法，检索效率高于vector、deque和list等容器，另外使用中序遍历可将键值按照从小到大遍历出来。 在编程中要尽可能多的使用const，这样可以获得编译器的帮助，以便写出健壮性的代码。（外部引用者更为合适） set容器的insert操作不需要提前判定元素存在，如下图： vector和string容器实现了swap方法，内置swap进行了优化，优于自己写的简单交换 暂时不明白string s = &quot;&quot;;和string s;的区别，希望大佬可以指点 题目：344. Reverse String描述：Write a function that takes a string as input and returns the string reversed.例子：12Input: "hello"Output: "olleh" 代码：12345678910string Solution344::reverseString(string s)&#123; int len = s.size(); if (len &lt; 2)return s; for (int i = 0; i &lt; len / 2; i++) &#123; swap(s[i], s[len - i - 1]); &#125; return s;&#125; swap优于自己写的交换 题目:557. Reverse Words in a String III描述：Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.例子：12Input: "Let's take LeetCode contest"Output: "s'teL ekat edoCteeL tsetnoc" 代码：1234567891011121314151617181920string Solution557::reverseWords(string s)&#123; int len = s.size(); int j = 0; for (int i = 0; i &lt; len; i++) &#123; if (i + 1 == len || s[i + 1] == ' ') &#123; int n = i - j + 1; int x = j; while (j &lt;= x + n /2 - 1) &#123; swap(s[j], s[i +x - j]); ++j; &#125; j = i + 2; &#125; &#125; return s;&#125; 在这道题中踩过的坑： 边界条件:i指向最后一个元素的情况 while循环中j不断变化，循环边界需要不变边界 swap交换时元素的下标计算 题目：657. Judge Route Circle描述：Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.例子：1234Input: "UD"Output: trueInput: "LL"Output: false 代码：12345678910111213141516bool Solution657::judgeCircle(string moves)&#123; vector&lt;int&gt; m(4);//L,R,U,D for (auto &amp;c : moves) &#123; if (c == 'L')m[0]++; else if (c == 'R')m[1]++; else if (c == 'U')m[2]++; else m[3]++; &#125; return (m[0] == m[1] &amp;&amp; m[2] == m[3]); //unordered_map&lt;char, int&gt;com; //for (auto &amp;c : moves)com[c]++; //return com['L'] == com['R'] &amp;&amp; com['U'] == com['D'];&#125; 尝试了一下注释掉的方法二runtime很差劲，可能是因为查找比较费时间 题目：804. Unique Morse Code Words描述：International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.For convenience, the full table for the 26 letters of the English alphabet is given below:1[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. 例子：1234567891011Example:Input: words = ["gin", "zen", "gig", "msg"]Output: 2Explanation: The transformation of each word is:"gin" -&gt; "--...-.""zen" -&gt; "--...-.""gig" -&gt; "--...--.""msg" -&gt; "--...--."There are 2 different transformations, "--...-." and "--...--.". Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 代码：12345678910111213141516171819202122232425262728293031int Solution804::uniqueMorseRepresentations(vector&lt;string&gt;&amp; words)&#123; //int len = words.size(); //if (len &lt; 2)return len; //vector&lt;string&gt; map = &#123; ".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.." &#125;; //set&lt;string&gt; compare; //for (string s : words) //&#123; // string temp = ""; // for (char c : s) // &#123; // temp += map[c - 'a']; // &#125; // //if (compare.find(temp) == compare.end()) // compare.insert(temp); //&#125; //return compare.size(); unordered_set&lt;string&gt; compare; for (string &amp;s : words) &#123; string temp; for (char &amp;c : s) &#123; temp += map[c - 'a']; &#125; //if (compare.find(temp) == compare.end()) compare.insert(temp); &#125; return compare.size();&#125; 注释掉的代码是我自己写的，下面的代码是看了runtime比较好的答案，经过对比多次提交比较得到一下几个猜想，有待验证： unordered_set优于set public定义compare优于函数内定义 compare前加上const关键字优于不加 for循环加上&amp;优于不加 set执行insert不需要提前判断集合中是否有该元素 temp不初始化不会报错，且优于初始化 结束更多内容请浏览我的csdn：小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彩铅画2-向日葵]]></title>
    <url>%2F2018%2F08%2F08%2F%E5%BD%A9%E9%93%85%E7%94%BB2-%E5%90%91%E6%97%A5%E8%91%B5%2F</url>
    <content type="text"><![CDATA[半年过去了，前段时间翻到了年初的朋友圈看下今年的flag：“2018no flag,多读书多看报，多点佛系情怀，多点珍惜，多点爱，还有就是培养一个新爱好”。这么简单的计划差点都被我搞砸，还有还有半年为期，那就爱好捡起来吧。 上次画画是几个月前看了几集《永恒的紫罗兰花园》，就画了里面邮递员的一个剪影；再上次是高考结束学习了半个月的素描，就是练习排线、投影、静物，画些苹果鸭梨啥的；再上次应该就是初中的时候，凭借一副人像拿了学校画展的二等奖，平时看课外书的时候画些书中的人物剪影。 从小我对色彩的掌握就比较弱，但是很有耐性，选择彩铅也没有什么特别的考究，只是彩铅的画法和素描很像，然后彩铅毁画不太容易，所以就开始了我的新爱好培养。 首先是先用自动铅笔构图，起始在构图的时候自己很小心，尽量不让比例失调，但是因为最初选定的落笔的地方选择了近景叶子而不是向日葵的根部，导致最后向日葵的底部比例有点失调，就把叶子全擦掉重新画的，所以定型原点很重要！还有一点就是在构图的时候有些高光明显的地方也画了边界，可以避免上色的时候不小心画错。 花瓣上色， 第一次尝试这种色调比较少的画，而且我的彩铅只有36色，担心自己的水平画不出来效果，所以一个花瓣一个花瓣开始画，没有采用大范围铺色调的方式，这也可能是我画得慢得原因吧。先用404打底，再铺一层407，留出高光得位置，再阴影得地方加深409，觉得色彩不够可以反复排线，开始排线得时候尽量轻，不然后面不好上色，在阴影比较重得地方适当加入487和478，有些黄得发红得地方加入414和416。 叶子上色，画花瓣得时候很累，画完花瓣差不多已经5个小时左右了，画叶子得时候才知道色彩对我得限制有多大，我的绿色色系只有5只，很难画出向日葵那种深绿得感觉，所以加了很多得480和499，先用463打底，浅涂，然后459加深，可以根据排线来自动调节每种颜色每个位置得深浅，这样能够显出立体得感觉，在阴影较重得地方用459和499、480反复图，绿里透着黑，黑里透着绿。 这是最后的图，不太满意的地方是花芯和近景的叶子，因为是对着图片临摹，没有近距离观察向日葵花芯的小花瓣的形状，不太会画这里，而且画到这里的时候我差不多已经坐着画了10个小时左右，有点累了画的比较随意，还有就是近景叶子我没有太看明白图片中的叶子是怎样分布的，根据阳光照射的向日葵的花瓣的高光分布没有推测出近景叶子是怎样达到花瓣的效果，所以感觉近景叶子的高光阴影有很大的问题，更多的内容请不吝指教~ 还有比较细节的地方是，在勾勒一些颜色交叉边缘阴影时根据阴影映射的颜色来压会比较自然，最后，这幅图用到的颜色：有些是画画中随性加的颜色，没有具体描述。]]></content>
      <categories>
        <category>绘画</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第18章 高级类型]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC18%E7%AB%A0-%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[18.1 单例类型 在下面的例子中book不能调用addChapter方法，因为setTitle方法返回的是this，Scala自动推断类型为Document。1234567891011121314151617class Document&#123; def setTitle(title:String) = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle("whatever").setAuthor("cay")class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle("scala") 修改方法如下：显式声明setTitle方法的返回类型是this.type 1234567891011121314151617class Document&#123; def setTitle(title:String):this.type = &#123; this &#125; def setAuthor(author:String) = &#123; this &#125;&#125;val article = new Document()article.setTitle("whatever").setAuthor("cay")class Book extends Document&#123; def addChapter(chapter:String) = &#123; this &#125;&#125;val book = new Book()book.setTitle("scala").addChapter("") 1234567object Title//单例对象class Document&#123; private var useNextArgAas:Any = null def set(obj:Title.type ):this.type = &#123;useNextArgAas = obj;this&#125; def to(arg:String) = if(useNextArgAas == Title) println(arg)&#125;book.set(Title).to("scala") 18.2 类型投影注意下一段代码中的NetWork#Member操作，说明在NetWork中共享Member类 12345678910111213141516class NetWork&#123; class Member(val name:String)&#123; val contacts = new ArrayBuffer[NetWork#Member] &#125; private val members = new ArrayBuffer[Member]() def join(name:String) = &#123; val m = new Member(name) members += m m &#125;&#125;val chatter:NetWork = new NetWorkval myFace:NetWork = new NetWorkval fred :chatter.Member= chatter.join("fred")val barney :myFace.Member= myFace.join("barney")fred.contacts += barney 18.4 类型别名类型别名必须出现在类或者对象中，不能出现在Scala文件的顶层123type Index = mutable.HashMap[String,(Int,Int)]val a :Index = new Index()a.put("a",(1,2)) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记-第17章-类型参数]]></title>
    <url>%2F2018%2F08%2F07%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC17%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[17.1 泛型类 12345class Pair[T,S](val first:T,val second:S)&#123; def printf() = println(first,second)&#125;val p = new Pair(42,"string")p.printf() 17.2 泛型函数12def getMiddle[T](a:Array[T]) = a.length / 2println(getMiddle(Array(4,"56"))) 17.3 类型变量界定12345class Pair[T &lt;: Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair("23","4")).smaller) 如果不在泛型中加入&lt;: Comparable[T]，则就不知道first是否有compareTo方法，所以添加一个上界T 《： Comparable[T] 但是在类型为Int的时候出现报错，在17.4节中介绍 12345class Pair[T](val first:T,val second:T)&#123; def printf() = println(first,second) def replaceFirst[R &gt;: T](newFirst:R) = new Pair[R](newFirst,second)&#125;(new Pair("23","4")).replaceFirst(0).printf() 17.4 视图界定在上一节中Int类型出现报错是因为Int不是Comparable[Int]的子类。不过RichInt实现了Comparable[Int],同时还有一个从Int到RichInt的隐式转换。解决方法是视图界定12345class Pair[T &lt;% Comparable[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first.compareTo(second) &lt; 0) first else second&#125;println((new Pair[Int](3,4)).smaller) &lt;%关系将T被隐式转换成Comparable[T] 用Ordered特质会更好，因为在Comparable的基础上提供了关系操作符1234class Pair[T &lt;% Ordered[T]](val first:T,val second:T)&#123; def printf() = println(first,second) def smaller = if(first &lt; second) first else second&#125; 17.5 上下文界定视图界定T &lt;% V要求必须存在一个从T到V的隐式转换。上下文界定的形式是T:M。要求必须存在一个类型为M[T]的隐式值，如1class Pair[T:Ordering] 要求必须存在一个类型为Ordering[T]的隐式值。当声明一个使用隐式值的方法时，需要添加一个隐式参数,比如ord 123class Pair[T:Ordering](val first:T,val second:T)&#123; def smaller(implicit ord:Ordering[T]) = if(ord.compare(first,second) &lt; 0) first else second&#125; 17.11 对象不能泛型不能给对象添加类型参数，比如可变列表 更多内容请见我的csdn:小可爱的博客]]></content>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-sort-easy-over]]></title>
    <url>%2F2018%2F08%2F07%2Fleetcode-sort-easy-over%2F</url>
    <content type="text"><![CDATA[题目列表： 349 350 242 题目349：Intersection of Two Arrays描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].Note:Each element in the result must be unique.The result can be in any order. 代码： 1234567891011121314vector&lt;int&gt; Solution349::intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; set&lt;int&gt;nums1_plus, nums2_plus; nums1_plus.insert(nums1.begin(), nums1.end());//因为集合是不区分元素位置的 nums2_plus.insert(nums2.begin(), nums2.end()); vector&lt;int&gt; res; int len1 = nums1_plus.size(); for (int x : nums1_plus) &#123; if (nums2_plus.find(x) != nums2_plus.end())res.push_back(x); &#125; return res;&#125; 题目350：Intersection of Two Arrays II描述：Given two arrays, write a function to compute their intersection.例子：Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].Note:Each element in the result should appear as many times as it shows in both arrays.The result can be in any order.代码：123456789101112vector&lt;int&gt; Solution350::intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2)&#123; unordered_map&lt;int, int&gt;nums1_plus, nums2_plus; for (int x : nums1)nums1_plus[x]++; for (int x : nums2)nums2_plus[x]++; vector&lt;int&gt; res; for (auto x : nums1_plus) &#123; if (nums2_plus.find(x.first) != nums2_plus.end())res.insert(res.end(), min(x.second, nums2_plus[x.first]), x.first); &#125; return res;&#125; 题目242： Valid Anagram描述：Given two strings s and t , write a function to determine if t is an anagram of s.例子： Input: s = “anagram”, t = “nagaram” Output: true Input: s = “rat”, t = “car” Output: false Note:You may assume the string contains only lowercase alphabets.代码：1234567891011121314151617181920212223242526272829bool Solution242::isAnagram(string s, string t)&#123; //way 1 //if (s.size() != t.size())return false; //unordered_map&lt;char, int&gt; s_plus, t_plus; //for (char x : s)s_plus[x]++; //for (char x : t)t_plus[x]++; //for (auto x : s_plus) //&#123; // if (t_plus.find(x.first) != t_plus.end()) // &#123; // if (x.second != t_plus[x.first]) return false; // &#125; // else // return false; //&#125; //return true; //way 2 if (s.size() != t.size()) return false; vector&lt;int&gt; flag(26);//将26个小写字母映射到对应数组下标，元素为每个字母出现的次数，初始值为0 for (char x : s) flag[x - 'a']++;//计算s字符串中每个字母出现的次数 for (char x : t) &#123; flag[x - 'a']--; if (flag[x - 'a'] &lt; 0)return false;//如果两个字符串等长，且不是变换顺序的话，t中一定存在某个字母数大于s &#125; return true;&#125; 在题目242中，第二种方法的runtime优于第一种方法，在非变换顺序的字符串中可以在遍历结束之前结束。 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>c++</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[骗子]]></title>
    <url>%2F2018%2F08%2F06%2F%E9%AA%97%E5%AD%90%2F</url>
    <content type="text"><![CDATA[我是一个骗子戴着虚伪的面具月亮与我高歌清风为我吹嘘谈笑风生心底住着秘密黑夜降临我来到另一个世界忧伤浸染自说着寂寞的秋的清愁]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第16章 XML处理]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC16%E7%AB%A0-XML%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[这是一篇《快学scala》的读书笔记，需要具备Scala语言的基础，欢迎读者与我一起探讨，或者教我新知识呀~ 16.1 XML字面量Scala对xml有内建支持，直接用xml代码就行1234import scala.xml.Elemimport scala.xml.NodeBufferval doc:Elem = &lt;html&gt;&lt;head&gt;&lt;title&gt;Fred's&lt;/title&gt;&lt;/head&gt;&lt;/html&gt;val item:NodeBuffer = &lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;wilma&lt;/li&gt; 16.2 XML节点Node类是所有XML节点类型的祖先，两个最重要的子类是Text和Elem。用child方法遍历父节点下面的每一个子节点 123val ls:Elem = &lt;a herf="www.baidu.com"&gt;the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child) println(x) 输出结果： 1234the&lt;em&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language 代码：123val ls:Elem = &lt;a herf="www.baidu.com"&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;for(x &lt;- ls.child if !x.child.isEmpty) println(x.child) 输出结果：12ArrayBuffer(&lt;li&gt;hello&lt;/li&gt;, scala)ArrayBuffer(yoyo) 通过变成的方式构建节点序列，可以使用NodeBuffer,是ArrayBuffer[Node]的子类，可以被隐式转换为NodeSeq，转换之后就不能再继续修改它，因为xml节点序列是不可变的 12345import scala.xml.&#123;Node, NodeSeq&#125;val items = new NodeBufferitems += &lt;li&gt;Fred&lt;/li&gt;items += &lt;li&gt;Wilma&lt;/li&gt;val nodes:NodeSeq = items 16.3 元素属性要处理某个元素的属性键和值，可以使用attributes属性,返回Option类型的节点序列1234val ls:Elem = &lt;a href="www.baidu.com"&gt;the&lt;em&gt;&lt;li&gt;hello&lt;/li&gt;scala&lt;/em&gt;&lt;em&gt;yoyo&lt;/em&gt;language&lt;/a&gt;val url: scala.Seq[Node] = ls.attributes("href")val url1:String= ls.attributes("href").textprintln(url1) 输出结果：www.baidu.com通过调用 text方法返回String类型结果,也可以通过下面的方法避免没有这个属性返回null的结果，如果没有返回空12val url2 = ls.attributes.get("alt").getOrElse(Text("")) println(url2) 遍历节点的所有属性：12345val elem1 = &lt;p class="nihao" type="wawa"&gt;&lt;/p&gt;for(attr &lt;- elem1.attributes) println(attr.key,attr.value.text)val map:Map[String,String] = elem1.attributes.asAttrMapprintln(map) 两种方式都可以遍历节点的所有属性，第一种方式的attr类型是MetaData，第二种方式返回的是键值对的map 16.4 内嵌表达式可以在xml字面量中包含Scala的代码块 123val items = List(2,3,5)val elem = &lt;ul&gt;&#123;for(i &lt;- items)yield &lt;li&gt;&#123;i&#125;&lt;/li&gt;&#125;&lt;/ul&gt;println(elem) 16.5 在属性中使用表达式可以用Scala表达式来计算属性值 123456val e = &lt;a id=&#123;new Atom[Int](1)&#125;&gt;&lt;/a&gt;println(e.attributes("id").text)val description = "TOD"val q = &lt;img alt=&#123;if(description == "TODO") null else description&#125;&gt;yolo&lt;/img&gt;println(q.attributes.get("alt").getOrElse(Text(""))) 16.8 模式匹配可以在模式匹配表达式中使用xml字面量 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println("img") case &lt;li&gt;&#123;v&#125;&lt;/li&gt; =&gt; println(v) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println("lala") case _ =&gt; println("")&#125;) 可以用下面的方式匹配文本12&lt;li&gt;&#123;Text(v)&#125;&lt;/li&gt; =&gt; v&lt;li&gt;v&lt;/li&gt; =&gt; v.text XML模式不能有属性，如果要匹配属性，需要用守卫 123456789var nodeLs = List(&lt;img/&gt;)nodeLs = &lt;li class="name"&gt;yolo&lt;/li&gt; :: nodeLsnodeLs = &lt;ul&gt;lala&lt;li&gt;yilia&lt;/li&gt;&lt;/ul&gt; :: nodeLsnodeLs.foreach(_ match &#123; case &lt;img/&gt; =&gt; println("img") case n @ &lt;li&gt;&#123;_&#125;&lt;/li&gt; if (n.attributes("class").text == "name")=&gt; println(n) case &lt;ul&gt;&#123;_*&#125;&lt;/ul&gt; =&gt; println("lala") case _ =&gt; println("")&#125;) 16.9 修改元素和属性xml节点和节点序列是不可变的，如果要编辑一个节点，需要创建一个拷贝123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = "ol")println(list2) 结果输出：FredWilma 新旧两个列表的后代是共享的，要添加一个后代，可以像下面这样调用copy123val list = &lt;ul&gt;&lt;li&gt;Fred&lt;/li&gt;&lt;li&gt;Wilma&lt;/li&gt;&lt;/ul&gt;val list2 = list.copy(label = "ol",child = list.child ++ &lt;li&gt;another&lt;/li&gt;)println(list2) 更多内容请见我的csdn:小可爱的博客]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学Scala》学习笔记--第15章 注解]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6Scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC15%E7%AB%A0-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[15.1 什么是注解 注解：插入到代码中以便有工具可以对他们进行处理的标签，工具可以在代码级别运作，也可以被编译器加入了注解信息的类文件 15.2 什么可以被注解可以为类、方法、字段、局部变量和参数添加注解12345@Entity class Credentials@Test def testSomeFeature()&#123;&#125;@BeanProperty var username = _def doSomething(@NotNull message:String)&#123;&#125;@BeanProperty @Id var username = _ 在给主构造器添加注解时，需要将注解放置在构造器之前，并加上一对圆括号 1class Credentials @Inject()&#123;var username:String,var password:String&#125; 可以为表达式添加注解，需要在表达式后加上冒号1(myMap.get(key):@unchecked) match &#123;...&#125; 还可以为类型参数添加注解：1class MyContainer[@specialized T] 针对实际类型的注解应放在类型名称之后1String @cps[Unit] 15.3 注解参数Java注解可以有带名参数，如果参数名是value，名称可以直接略去，如果注解不带参数，圆括号可以略去注解的参数类型只能是： 数值型的字面量 字符串 类字面量 Java枚举 其他注解 上述类型的数组 15.4 注解实现本节主要看下注解类是怎样实现的 注解必须扩展Annotation特质。 1class unchecked extends annotation.Annotation 注解的作用是描述那些被注解的表达式、变量、字段、方法或类型1def check(@NotNull password:String) = &#123;&#125; 好了，注解看到这里我放弃了，并看不懂……]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因吹斯听thing:我的博客网站]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9B%A0%E5%90%B9%E6%96%AF%E5%90%ACthing-%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[之前就想过自己搭建一个博客网站，因为自己有记东西的习惯，简书+csdn+有道云，挺麻烦的，今天偶然知道了hexo，感觉这个东西很好，就尝试5分钟搭建，但是实际上不止5分钟呀，中间也遇到了问题，现把我的搭建过程做个记录。 原文链接：5分钟搭建免费个人博客 安装Hexo此步安装命令用的是下面的： 1npm install -g hexo-cli 安装成功之后,会提示hexo的安装目录。我在D盘下新建了Hexo文件夹，执行 1hexo init D:\Hexo 进入到该路径下，初始化网站存储的文件1hexo init username.github.io 根据链接的配置要求进行更改，进入到该文件夹下面1cd username.github.io 执行1hexo s 测试启动可以运行 注意事项： hexo的安装命令有很多，我第一遍安装失败了，遇到了hexo不是内部或外部命令 hexo的文档命名和内容格式 有一定的要求，按照下面的语法新建文档，再编辑新内容1hexo new "doc name" 总结今天学习到的命令 123hexo shexo new "doc name"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 要好好学习markdown的语法喽~]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《快学scala》学习笔记--第14章 模式匹配和样例类]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E5%BF%AB%E5%AD%A6scala%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC14%E7%AB%A0%20%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%92%8C%E6%A0%B7%E4%BE%8B%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[此篇文章针对有一定Scala基础的读者 14.1 更好的switch 123456val ch: Char = '*'ch match &#123; case '+' =&gt; println("加法") case '*' =&gt; println("乘法") case _ =&gt; println("木有")&#125; match是一个表达式，而不是语句，会有返回值 1234567val ch: Char = '*'val x:Int = ch match &#123; case '+' =&gt; 0 case '*' =&gt; 1 case _ =&gt; 2&#125;println(x) 14.2 守卫守卫可以是任何布尔条件，在下面的例子中，只有在守卫模式不能匹配的情况下才执行所有模式匹配 123456789val ch:Char = 3var sign:Int = 0ch match &#123; case '+' =&gt; println("++++") case '*' =&gt; println("====") case _ if ch &gt;= 0 &amp;&amp; ch &lt;= 9 =&gt; sign = ch case _ =&gt; println("---")&#125;println(sign) 14.3 模式中的变量case _ 是这种特性的特殊情况，变量名是 _ 12345678910val c: Char = '+'val ch:Char = 9var sign:Int = 0ch match &#123; case '+' =&gt; println("++++") case '*' =&gt; println("====") case c if c &gt;= 0 &amp;&amp; c &lt;= 9 =&gt; sign = c case _ =&gt; println("---")&#125;println(sign) 变量必须以小写字母开头 如果有一个小写字母开头的常量，则需要将它包在反引号中。 14.4 类型模式匹配列表中的每一个元素的类型，将每一个元素映射成 =&gt; 后面的 string 类型 1234567val ls = List(1,3,4,"one","two",4.5)val l = ls.map(_ match &#123; case x:Int =&gt; "int x:" + x case s:String =&gt; "string s:" + s case _ =&gt; "other"&#125;)l.foreach(println) 14.5 匹配组、列表和元组要匹配数组的内容，可以在模式中使用Array表达式, 1234567val arr1 = Array(Array(0),Array(3,4),Array(0,4,6),Array("fad","fff"))arr1.map(_ match &#123; case Array(0) =&gt; println(0) case Array(x,y) =&gt; println(x,y) case Array(0,_*) =&gt; println("...")//_*符号匹配数组中余下的内容 case _ =&gt; println("something")&#125;) 匹配列表中的元素 12345678val ls = List(List(0),List(3,4),List(0,4,5),List("fa","aaa","tttt"))ls.map(_ match &#123; case 0::Nil =&gt; println(0) case x :: y :: Nil =&gt; println(x,y) case 0 :: tail =&gt; println(tail.foreach(println)) case x :: tail =&gt; println("====") case _ =&gt; println("something")&#125;) 匹配元组 123456val ls = List((0,4),("fa",0),(3,4))ls.map(_ match &#123; case (0,_) =&gt; println(0) case (x,y) =&gt; println(x,y) case _ =&gt; println("something")&#125;) 14.6 提取器前一节中匹配数组、列表和元素的功能是依靠提取器实现的 ==提取器机制==：带有从对象中提取值得unapply和unapplySeq方法得对象。unapply提取固定数量得对象，而unapplySeq提取得是一个序列 1Array.unapplySeq(arr) 产出一个序列的值。 14.8 for表达式中的模式123val ls = List((1,2),(3,4),(4,5))for ((k,v) &lt;- ls if k % 2 == 1) println(k,v) 14.9 样例类可以用模式匹配来匹配样例类，并将属性值绑定到变量 12345678910case class Dollar(value:Double)case class Currency(value:Double,unit:String)case object Yuanval ls = List(Dollar(2.3),Currency(4.5,"10"),Yuan)ls.map(_ match &#123; case Dollar(v) =&gt; println(s"Dollar:$v") case Currency(_,u) =&gt; println(s"got $u") case Yuan =&gt; println("lalala") case _ =&gt; println("----")&#125;) 样例类实例使用(),样例对象不适用圆括号 ==声明样例类的时候有如下几件事自动发生：== 构造器中的每一个参数都成为val，除非被显式地声明为var 在伴生对象中提供apply方法，可以不用new关键字就能构造出相应的对象，比如Dollar(2.3) 提供unapply方法让模式匹配可以工作 将生成toString,equals,copy方法，除非显式给出定义 14.10 copy方法和带名参数copy方法创建一个与现有对象值相同的新对象，可以用带名参数修改某些属性 1234val amt = Currency(34.2,"RUR")val price = amt.copy()val price1 = amt.copy(value = 13)val price2 = amt.copy(unit = "CHF") 14.11 case语句中的中置表示法如果unapply方法产出一个对偶，可以在case语句中使用中置表示法，19章将会看到将解析结果组合在一起的~样例类: 1result match &#123;case p ~ q =&gt; ...&#125; //等同于case ~(p,q) 如果操作符以冒号结尾，则他是从右向左结合的 中置表示法可以用于任何返回对偶的unapply方法： 1234567case object +: &#123; def unapply[T](input: List[T]):Option[(T,List[T])] = if(input.isEmpty) None else Some((input.head,input.tail))&#125;1+:7+:2+:Nil match &#123; case first +: second +: rest =&gt; println(first + second + rest.length)&#125; 14.12 匹配嵌套结构三个样例类继承Item抽象类，Bundle和Boolean类嵌套Article和Bundle样例类，可以用@表示法将嵌套的值绑定到变量 12345678910111213abstract class Itemcase class Article(desc:String,price:Double) extends Item//继承同一个抽象类case class Bundle(desc:String,discount:Double,item:Item) extends Itemval peak = Bundle("Father's Day is special",20.0,Article("scala is nice",45.5))case class Boolean(desc:String,dis:Double,item:Item*)//Item抽象类列表val amt = Boolean("great",23.3,Bundle("nice",45.4,Article("wonderful",45.4)),Article("scala is nice",45.5))val ls = List(peak,amt)ls.map(_ match &#123; case Bundle(_,_,Article(desc,price)) =&gt; println(s"bundle $&#123;desc&#125;:$&#123;price&#125;") case Boolean(_,_,art @ Bundle(_,_,_),rest @ _*) =&gt; println(s"boolean $&#123;art.desc&#125;:$&#123;art.discount&#125;,$&#123;rest.head&#125;") case Boolean(_,_,art @ Bundle(_,_,_),rest) =&gt; println(s"boolean $&#123;art.desc&#125;")//匹配继承Item抽象类的元素只有两个 case _ =&gt; println("None")&#125;) 14.14 密封类当用样例类来做模式匹配的时候，想让编译器帮助确保已经列出了所有可能的选择，要达到这个目的，需要将样例类的通用超类声明为sealed 密封类的所有子类都必须在与该密封类相同的文件中定义。 如果某个类是密封的，那么在编译期所有子类就是可知的，因此==编译器可以检查模式语句的完整性==，让同一组样例类都扩展自某个密封的类或者特质是一个好的做法 12345678910sealed abstract class Amountcase class Red(bottom:Double) extends Amountcase object Green extends Amountcase object Gray extends Amountval color:Amount = Red(3.4)//需要显式声明color的类型，不然就会变成Redcolor match &#123; case Red(_) =&gt; println("red") case Green =&gt;println("green") case Gray =&gt; println("fad")&#125; 14.16 Option类型标准类库的Option类型用样例类来表示那种可能存在，也可能不存在的值。这比空字符串更加清晰，比null做法更加安全。 map类的get方法返回一个Option。如果对于给定的键没有对应的值，则get返回None，如果有值，该值包在Some中返回 请以不要直接使用get方法，返回None的情况可能会使程序死掉，尽量用getOrElse Option[+A]密封抽象类，Some和None继承Option类 14.17 偏函数被包括在花括号内的一组case语句是一个偏函数——==并非对所有输入值都有定义的函数==。它是PartialFunction[A,B]类的一个实例，该类有两个方法：apply方法从匹配到的模式计算函数值，而isDefinedAt方法在输入至少匹配其中一个模式时返回true 1234567val f:PartialFunction[Char,Int] = &#123; case '+' =&gt; 1 case '-' =&gt; -1&#125;println(f('+'))//1//println(f('0'))//errorprintln(f.isDefinedAt('0'))//false]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远方]]></title>
    <url>%2F2018%2F07%2F25%2F%E8%BF%9C%E6%96%B9%2F</url>
    <content type="text"><![CDATA[期盼着远方思念着家乡我有一个姑娘我有一个姑娘舍不得家乡牵挂着远方]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看我邮人缚苍龙]]></title>
    <url>%2F2014%2F12%2F01%2F%E7%9C%8B%E6%88%91%E9%82%AE%E4%BA%BA%E7%BC%9A%E8%8B%8D%E9%BE%99%2F</url>
    <content type="text"><![CDATA[芳草垂柳梧桐秀心唤帝都今重又汗洒昌平夜如昼群峰含笑送清秋戎装飒爽为北邮天地苍茫出浩宇看我邮人缚苍龙]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[军训1]]></title>
    <url>%2F2014%2F12%2F01%2F%E5%86%9B%E8%AE%AD1%2F</url>
    <content type="text"><![CDATA[黄沙不见烈日炎，碧云天，晓风怨。飒爽英姿，真是个超然。勿让云雨匆匆散，月夜下，欢歌连。闲适风景时时盼，舞翩翩，望不断。舟叶水源，回首泪涟涟。待到君心换我心，垂柳下，戎装前。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>诗词</tag>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
